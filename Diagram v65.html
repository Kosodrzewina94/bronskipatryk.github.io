<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Process Diagram</title>
	<link rel="icon" href="favicon.png" type="image/png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            --bridgestone-red: #DA291C;
            --bridgestone-red-darker: #a71005;
            --bridgestone-black: #000000;
            --bridgestone-grey: #666666;
        }

        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; background-color: #f4f4f4; min-height: 100vh; overflow-x: hidden; box-sizing: border-box; }
        .top-bar { 
            width: 100%; max-width: none; display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 15px;
            box-sizing: border-box; position: relative; z-index: 1000; background-color: #f4f4f4; 
            border-bottom: 3px solid var(--bridgestone-red);
        }
        .main-controls { background-color: #fff; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; gap: 10px; align-items: center; flex-wrap: wrap; flex-grow: 1; }
        .main-controls button, .main-controls input[type="search"],
        #shortcut-show-dependencies-button, 
        #shortcut-simulate-impact-button { 
            padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; 
        }
        .main-controls button:hover, .main-controls input[type="search"]:hover,
        #shortcut-show-dependencies-button:hover:not(:disabled),
        #shortcut-simulate-impact-button:hover:not(:disabled) { 
            background-color: #ddd; 
        }

        #shortcut-show-dependencies-button,
        #shortcut-simulate-impact-button {
            padding: 8px;
            line-height: 1;
        }

        #shortcut-show-dependencies-button svg,
        #shortcut-simulate-impact-button svg {
            vertical-align: middle;
        }

        #shortcut-show-dependencies-button:disabled,
        #shortcut-simulate-impact-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #ccc !important;
        }
        #shortcut-show-dependencies-button:disabled:hover,
        #shortcut-simulate-impact-button:disabled:hover {
             background-color: #ccc !important;
        }


        .menu-container { position: relative; display: inline-block; }
        #menu-button {
            background-color: var(--bridgestone-red);
            color: white;
            border: 1px solid var(--bridgestone-red-darker);
        }
        #menu-button:hover {
            background-color: var(--bridgestone-red-darker);
            color: white;
        }

        #menu-content {
            display: none;
            position: absolute;
            background-color: #fff;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1001;
            padding: 12px 16px;
            border-radius: 4px;
            margin-top: 5px;
            min-width: 250px;
            max-height: 70vh;
            overflow-y: auto;
        }
        #menu-content button, #menu-content label#json-file-input-label {
            display: block;
            width: 100%;
            margin-bottom: 8px;
            text-align: left;
            box-sizing: border-box;
            padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px;
            cursor: pointer; background-color: #e9e9e9; font-size: 0.9em;
        }
         #menu-content button:hover, #menu-content label#json-file-input-label:hover {
            background-color: #ddd;
        }
        #menu-content span#json-file-name { display: block; margin-top: -4px; margin-bottom: 8px; font-size: 0.8em; }
        #json-file-input { display: none; }

        #menu-content h4 {
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 0.75em;
            color: var(--bridgestone-grey, #555);
            text-transform: uppercase;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
            font-weight: bold;
        }
        #menu-content h4:first-of-type {
            margin-top: 0;
        }
        #menu-content hr {
            border: 0;
            height: 1px;
            background-color: #ddd;
            margin: 12px 0;
        }
        .menu-item-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }
        .menu-item-group label {
            font-size: 0.9em;
            white-space: nowrap;
            margin-bottom: 0;
        }
        .menu-item-group select, .menu-item-group .delete-view-config-container button {
            padding: 6px 10px;
            border: 1px solid #ccc; border-radius: 4px; cursor: pointer;
            background-color: #f0f0f0; font-size: 0.85em;
            flex-grow: 1;
        }
         .menu-item-group .delete-view-config-container button {
            padding: 6px 8px;
            font-size: 0.8em;
            flex-grow: 0;
        }
        .sheet-multi-select-container, .delete-view-config-container {
            position: relative;
            display: inline-block;
        }
         #menu-content .sheet-multi-select-container button {
            width: auto;
            display: inline-block;
         }


        #sheet-multi-select-dropdown {
            display: none;
            position: absolute;
            background-color: #fff;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1002;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 5px;
            min-width: 180px;
            max-height: 200px;
            overflow-y: auto;
            left: 0;
        }
        #sheet-multi-select-options label { display: block; margin-bottom: 5px; font-weight: normal; font-size: 0.9em; }
        #sheet-multi-select-options input[type="checkbox"] { margin-right: 5px; }

        .delete-view-config-container { position: relative; display: inline-block; }
        #delete-view-config-dropdown {
            display: none;
            position: absolute;
            background-color: #fff;
            box-shadow: 0px 2px 8px rgba(0,0,0,0.15);
            z-index: 1003;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 2px;
            min-width: 150px;
            max-height: 150px;
            overflow-y: auto;
            right: 0;
        }
        #delete-view-config-dropdown .delete-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            display: block;
            white-space: nowrap;
        }
        #delete-view-config-dropdown .delete-item:hover {
            background-color: #f0f0f0;
        }


        #diagram-container { 
            width: 100%; max-width: none; height: 75vh; 
            border: 2px solid var(--bridgestone-red);
            position: relative; overflow: auto; background-color: #fff; margin-bottom: 20px; cursor: grab; box-sizing: border-box; 
        }
        #diagram-container:active { cursor: grabbing; }
        #diagram-zoom-pane { position: relative; width: 100%; height: 100%; transform-origin: 0 0; min-width: 100%; min-height: 100%; }
        #simulation-ghost-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 4;
        }
        
        #welcome-message-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(255, 255, 255, 0.97);
            z-index: 50;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 30px;
            box-sizing: border-box;
            font-size: 1.1em;
            color: #333;
        }
        #welcome-message-overlay h2 {
            color: var(--bridgestone-red);
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        #welcome-message-overlay p {
            margin-bottom: 15px;
            line-height: 1.7;
            max-width: 650px;
        }
        #welcome-message-overlay strong {
            color: var(--bridgestone-red-darker);
            font-weight: 600;
        }
         #welcome-message-overlay .highlight-path {
            font-weight: bold;
            color: #0056b3;
        }
        #welcome-message-overlay .tutorial-prompt {
            margin-top: 25px;
            font-size: 0.95em;
            color: #555;
        }
        #welcome-message-overlay .tutorial-prompt .highlight-path {
            cursor: pointer;
            text-decoration: underline;
        }

        .axis { position: absolute; font-size: 10px; color: #555; z-index: 1; padding: 3px 5px; border-radius: 3px; box-sizing: border-box; }
        #sticky-y-axis, #sticky-x-axis { position: fixed; background-color: rgba(244, 244, 244, 0.92); z-index: 20; overflow: hidden; box-sizing: border-box; border: 1px solid #ccc; }
        #sticky-y-axis .axis, #sticky-x-axis .axis { background-color: rgba(255,255,255,0.8); border: 1px solid #eee; color: #333; white-space: nowrap; cursor: pointer !important; pointer-events: auto !important; transition: background-color 0.2s, border-color 0.2s; }
        #sticky-x-axis .axis { text-align: center; }
        #sticky-y-axis .axis:hover, #sticky-x-axis .axis:hover { background-color: #e0e0e0; border-color: #ccc; }
        #sticky-y-axis .axis.active-axis-filter, #sticky-x-axis .axis.active-axis-filter { background-color: #d1eaff; border-color: #a6cfff; font-weight: bold; }
        
        .process-node {
            position: absolute; background-color: #aedff7; border: 1px solid #5da9d4; padding: 5px 7px;
            font-size: 9px; text-align: center; cursor: pointer; border-radius: 4px;
            white-space: nowrap; box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, background-color 0.3s, border-color 0.3s, opacity 0.3s, top 0.2s ease-out, left 0.2s ease-out;
            z-index: 5; box-sizing: border-box;
        }
        .process-node.can-hover:hover { transform: scale(1.05); box-shadow: 2px 2px 5px rgba(0,0,0,0.2); z-index: 10; }
        .process-node.selected { border-width: 2px !important; z-index: 11 !important; }
        .process-node.dependent-input { border-width: 2px; }
        .process-node.dependent-output { border-width: 2px; }
        .process-node.filtered-out-general, .process-node.filtered-out-axis { opacity: 0.1 !important; z-index: 3 !important; pointer-events: none !important; }
        .process-node.dimmed-selection { opacity: 0.25 !important; z-index: 4 !important; }
        .process-node.search-highlight { border: 2px solid #ff8c00 !important; background-color: #ffe0b3 !important; z-index: 12 !important; }
        .process-node.search-dimmed { opacity: 0.15 !important; z-index: 2 !important; pointer-events: none !important; }
        .process-node.tree-highlight-dimmed { opacity: 0.1 !important; z-index: 1 !important; pointer-events: none !important; }
        .process-node .node-type-symbol {
            position: absolute;
            top: 1px;
            right: 2px;
            font-size: 7px;
            font-weight: bold;
            color: #333;
            background-color: rgba(255, 255, 255, 0.6);
            padding: 0px 2px;
            border-radius: 2px;
            line-height: 1;
            user-select: none;
        }

        .process-node.simulation-target-node {
            box-shadow: 0 0 8px 2px gold !important;
            z-index: 25 !important;
        }
        .process-node.simulation-new-node {
            border: 2px dashed #17a2b8 !important;
            background-color: #e0f7fa !important;
            z-index: 26 !important;
        }
        .process-node.simulation-new-node::after {
            content: "➕";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #17a2b8;
        }
        .process-node.simulation-removed {
            opacity: 0.4 !important;
            border-style: dashed !important;
            border-color: #dc3545 !important;
            background-color: #f8d7da !important;
        }
         .process-node.simulation-removed::after {
            content: "🚫";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #dc3545;
        }
        .process-node.simulation-shifted {
             border-color: #fd7e14 !important;
        }
        .process-node.simulation-shifted::after {
            content: "↔️";
            position: absolute;
            bottom: -12px; left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
        }
        .process-node.simulation-affected-dependent {
            background-color: #ffc107 !important;
            border: 2px solid #e65100 !important;
            opacity: 1 !important;
            z-index: 20 !important;
        }
         .process-node.simulation-affected-dependent::before {
            content: "🔗";
            position: absolute;
            top: -12px; left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
        }
        .process-node.simulation-output-at-risk {
            background-color: #fff3cd !important;
            border: 2px solid #FF8C00 !important;
            opacity: 1 !important;
            z-index: 20 !important;
        }
        .process-node.simulation-output-at-risk::before {
            content: "⏳";
            position: absolute;
            top: -12px; left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #FF8C00;
        }
        .process-node.simulation-input-conflict {
            background-color: #f8d7da !important;
            border: 2px solid #FF4500 !important;
            opacity: 1 !important;
            z-index: 20 !important;
        }
        .process-node.simulation-input-conflict::before {
            content: "❗";
            position: absolute;
            top: -12px; left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #FF4500;
        }

        .process-node.simulation-dimmed-others {
            opacity: 0.2 !important;
            pointer-events: none !important;
            z-index: 2 !important;
        }
        .process-node.simulation-temporary-node {
            filter: grayscale(30%) opacity(80%);
            border-style: dotted !important;
        }
        .simulation-ghost-node {
            position: absolute;
            opacity: 0.35;
            border-style: dashed !important;
            border-color: #777 !important;
            background-color: rgba(174, 223, 247, 0.3) !important;
            pointer-events: none;
            z-index: 3;
            transition: none !important;
        }
        #dependency-svg .simulation-impact-path-arrow {
            stroke-width: 3.5px !important;
        }


        #dependency-svg .simulation-arrow {
            stroke-width: 2.5px;
        }
        #dependency-svg .simulation-arrow-broken {
            stroke-width: 2.5px;
            stroke: #dc3545;
            stroke-dasharray: 4, 4;
        }


        .bottom-controls-container { width: 100%; max-width: none; display: flex; flex-direction: column; gap: 10px; box-sizing: border-box; }
        .colors-toggle-bar { background-color: #fff; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #toggle-colors-button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; width: 100%; text-align: left;}
        #toggle-colors-button:hover { background-color: #ddd; }
        .visual-controls { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-top: 0;}
        .visual-controls label { font-size: 0.9em; }
        .visual-controls input[type="color"] { padding: 0; width: 30px; height: 30px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        #process-details { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #process-details h3 { margin-top: 0; color: #333; }
        #process-details p { margin: 6px 0; font-size: 0.9em; line-height: 1.4; }
        #process-details strong { color: #111; min-width: 150px; display: inline-block; }
        #process-details button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #4CAF50; color: white; margin-top: 10px; font-size: 0.9em; }
        #process-details button:hover { background-color: #45a049; }
        #dependency-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        #dependency-svg line { stroke-width: 2px; }
        #dependency-svg .flow-dot { }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .modal-content h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 20px; }
        .modal-content label { display: block; margin-top: 12px; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; color: #555; }
        .modal-content input[type="text"], .modal-content input[type="time"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: calc(100% - 16px); padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; box-sizing: border-box; }
        .modal-content textarea { min-height: 60px; resize: vertical; }
        .modal-content .button-group { margin-top: 25px; text-align: right; }
        .modal-content button { padding: 10px 18px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.95em; }
        .modal-content .save-button { background-color: #4CAF50; color: white; }
        .modal-content .save-button:hover { background-color: #45a049; }
        .modal-content .cancel-button { background-color: #aaa; color: white; margin-left: 10px; }
        .modal-content .cancel-button:hover { background-color: #999; }
        .modal-content .delete-button { background-color: #f44336; color: white; margin-right: auto; float: left; }
        .modal-content .delete-button:hover { background-color: #e53935; }
        .modal-content input.invalid, .modal-content textarea.invalid, .modal-content select.invalid { border-color: red; }
        .modal-content .error-message { color: red; font-size: 0.8em; margin-top: 2px; display: block; min-height: 1em; }
        
        #filter-panel, #converter-panel, #simulation-panel, #tutorial-panel {
            position: fixed; top: 0;
            width: 350px;
            height: 100%;
            background-color: #f8f9fa;
            padding: 20px; box-sizing: border-box; overflow-y: auto;
            transition: transform 0.3s ease-in-out; z-index: 999;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        }
        #filter-panel, #simulation-panel, #tutorial-panel { right: 0; transform: translateX(100%); }
        #filter-panel.open, #simulation-panel.open, #tutorial-panel.open { transform: translateX(0); }
        
        #converter-panel { left: 0; transform: translateX(-100%); }
        #converter-panel.open { transform: translateX(0); }
        
        .close-panel-button { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 1.8em; cursor: pointer; line-height: 1; }
        #filter-panel h3, #converter-panel h3, #simulation-panel h3, #tutorial-panel h3 { margin-top: 0; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        
        .filter-item-group { margin-bottom: 15px; }
        .filter-item-group label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 0.95em; }
        .filter-item-group select, .filter-item-group input[type="time"] { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background-color: white; box-sizing: border-box; margin-bottom: 5px;}
        .filter-item-group select[multiple] { height: auto; min-height: 60px; }
        #apply-filters-button { width: 100%; padding: 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; margin-top: 15px; }
        #apply-filters-button:hover { background-color: #0056b3; }
        
        #converter-panel h1 { font-size: 1.4em; color: #333; margin-bottom: 10px; }
        #converter-panel p { font-size: 0.9em; line-height: 1.4; margin-bottom: 15px; }
        #converter-panel .warning { color: #856404; background-color: #fff3cd; border: 1px solid #ffeeba; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.85em; }
        #converter-panel input[type="file"] { display: block; width: 100%; margin-bottom: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        #converter-panel button { padding: 10px 15px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; width: 100%; margin-top: 5px; }
        #converter-panel button:hover { background-color: #218838; }
        #converter-panel button:disabled { background-color: #ccc; cursor: not-allowed; }
        #converter-status { margin-top: 15px; font-style: italic; font-size: 0.9em; }
		#converter-status pre {
		white-space: pre-wrap; 
		word-wrap: break-word; 
		font-family: monospace;
		font-size: 0.9em;
		padding: 5px;
		background-color: #f0f0f0;
		border: 1px solid #ddd;
		border-radius: 3px;
		max-height: 150px;
		overflow-y: auto;
		margin-top: 5px;
		}
        #converter-panel pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto; font-size: 0.8em; margin-top: 10px; }
        
        #simulation-panel p { font-size: 0.95em; margin-bottom: 10px;}
        .simulation-type-selector-group { display: flex; justify-content: space-around; margin-bottom: 15px; }
        .simulation-type-button {
            padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px;
            background-color: #f0f0f0; cursor: pointer; font-size: 0.9em;
            flex-grow: 1; text-align: center; margin: 0 5px;
        }
        .simulation-type-button.active { background-color: #007bff; color: white; border-color: #0056b3; }
        .simulation-type-button:hover:not(.active) { background-color: #e0e0e0; }

        #simulation-shift-inputs label, #simulation-add-inputs label { font-size: 0.9em; margin-top: 8px; display: block; }
        #simulation-shift-inputs input[type="number"], #simulation-shift-inputs input[type="text"],
        #simulation-add-inputs input[type="text"], #simulation-add-inputs input[type="number"], #simulation-add-inputs select {
            width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
            background-color: white; box-sizing: border-box; margin-bottom: 10px;
        }
        #simulation-add-inputs h4 { font-size: 1em; margin-bottom: 10px; color: #555;}
        #simulation-add-inputs .error-message { font-size: 0.8em; color: red; min-height: 1em; margin-bottom: 5px;}

        #simulation-impact-info h4 { margin-top: 15px; margin-bottom: 8px; font-size: 1em; border-top: 1px dashed #ccc; padding-top: 10px; }
        #simulation-impact-list { list-style-type: disc; padding-left: 20px; font-size: 0.9em; max-height: 180px; overflow-y:auto; }
        #simulation-impact-list li { margin-bottom: 4px; }

        .simulation-scenario-management { margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd; }
        .simulation-scenario-management label { font-size: 0.9em; display: block; margin-bottom: 5px; }
        .simulation-scenario-management select { width: calc(100% - 110px); margin-right: 10px; }
        .simulation-scenario-management button { width: auto; padding: 8px 10px; font-size: 0.85em; margin-left: 5px; }

        #export-simulation-report-button { 
            background-color:#17a2b8; color:white; display:none; margin-top: 10px; 
            width: calc(100% - 20px); margin-left: 10px; margin-right: 10px; box-sizing: border-box;
        }


        #dynamic-fields-container { margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 15px; }
        .page-footer { 
            text-align: center; 
            margin-top: 25px;
            padding: 10px; 
            padding-top: 15px;
            font-size: 0.8em; 
            color: #333;
            border-top: 1px solid var(--bridgestone-red);
        }

        body.presentation-mode { padding: 0; overflow: hidden; }
        body.presentation-mode .top-bar { position: fixed; top: 0; left: 0; width: 100%; z-index: 1001; padding: 5px 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); justify-content: space-between; }
        body.presentation-mode .main-controls { background-color: transparent; box-shadow: none; padding: 0; flex-grow: 0; order: 1; }
        
        body.presentation-mode .menu-container { display: none !important; }
        body.presentation-mode #toggle-presentation-mode-button { display: inline-block !important; }
        body.presentation-mode #search-process-input { display: inline-block !important; }
        body.presentation-mode #reset-button { display: inline-block !important; }
        body.presentation-mode #shortcut-show-dependencies-button,
        body.presentation-mode #shortcut-simulate-impact-button {
            display: inline-block !important;
        }
        body.presentation-mode #toggle-filter-panel-button { display: inline-block !important; margin-left: 10px !important; order: 0 !important; }
        body.presentation-mode #toggle-mini-map-button { display: inline-block !important; order: 2; margin-left: auto; }

        body.presentation-mode #diagram-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; padding-top: 45px; box-sizing: border-box; border: none; margin: 0; }

        body.presentation-mode .colors-toggle-bar,
        body.presentation-mode .visual-controls,
        body.presentation-mode #process-details,
        body.presentation-mode #converter-panel,
        body.presentation-mode #simulation-panel,
        body.presentation-mode #tutorial-panel,
        body.presentation-mode .modal,
        body.presentation-mode .page-footer, 
        body.presentation-mode #link-handle-trigger,    
        body.presentation-mode .unlink-handle,           
        body.presentation-mode #dependency-panel-container
         { display: none !important; }


        #mini-map-wrapper { position: fixed; top: 55px; right: 10px; width: 180px; height: 135px; border: 1px solid #999; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0,0,0,0.2); z-index: 990; overflow: hidden; display: none; }
        #mini-map-svg { width: 100%; height: 100%; display: block; }
        #mini-map-viewport-rect { fill: rgba(0, 100, 255, 0.2); stroke: rgba(0, 100, 255, 0.8); stroke-width: 1px; }
        .mini-map-node { stroke: #777; stroke-width: 0.5px; }

        #dependency-panel-container {
            position: fixed;
            top: 60px;
            width: 50vw;
            min-width: 400px;
            max-width: 800px;
            right: -50vw;
			display: flex; 
            transition: right 0.3s ease-in-out; 
            height: calc(100vh - 80px);
            background-color: #f0f0f0;
            border-left: 2px solid #ccc;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            z-index: 998;
            flex-direction: column;
        }
        #dependency-panel-container.visible {
            right: 0;
			display: flex; 
        }
        #dependency-panel-title-bar { padding: 15px 20px; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; background-color: #e9ecef; }
        #dependency-panel-title-bar h3 { margin: 0; font-size: 1.1em; flex-grow: 1; }
        #highlight-tree-nodes-button {
             padding: 5px 10px; font-size: 0.85em; margin-left: 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;
        }
        #highlight-tree-nodes-button:hover { background-color: #0056b3; }
        .close-dependency-panel-button { font-size: 1.5em; border: none; background: none; cursor: pointer; line-height: 1; margin-left: 15px; }

        #dependency-tree-content { flex-grow: 1; overflow: auto; padding: 10px; background-color: #fdfdfd; }
        #dependency-tree-svg { display: block; min-width: 100%; }
        .dep-tree-node rect { fill: #e0e8ff; stroke: #6b7add; stroke-width: 1px; rx: 3; ry: 3; }
        .dep-tree-node.selected-root rect { fill: #c0c8ef; stroke: #3e4f9a; stroke-width: 1.5px; }
        .dep-tree-node.not-in-view rect { fill: #efefef; stroke: #aaa; stroke-dasharray: 2,2; }
        .dep-tree-node text { font-size: 9px; text-anchor: middle; dominant-baseline: middle; fill: #333; pointer-events: none; }
        .dep-tree-node text.toggle-text { font-size: 12px; text-anchor: start; cursor: pointer; fill: #555; }
        .dep-tree-node text.toggle-text:hover { fill: #007bff; }
        .dep-tree-link { stroke: #888; stroke-width: 1.5px; fill: none; }
        .dep-tree-node.clickable { cursor: pointer; }
        .dep-tree-node.clickable:hover rect { filter: brightness(95%); }
        .dep-tree-node.path-highlight rect { fill: #f0c475; stroke: #d69d3a; stroke-width: 1.5px; }
        .dep-tree-link.path-highlight { stroke: #d69d3a; stroke-width: 2.5px; }

        #menu-dependency-panel-trigger.disabled { 
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #ccc !important;
        }
        #menu-dependency-panel-trigger.disabled:hover {
            background-color: #ccc !important;
        }
        #menu-dependency-panel-trigger svg {
            vertical-align: middle; margin-right: 5px;
        }


        #link-handle-trigger, .unlink-handle
         {
            position: absolute;
            width: 14px;
            height: 14px;
            color: white;
            border-radius: 50%;
            display: none; 
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            user-select: none;
            line-height: 14px;
        }
        #link-handle-trigger { background-color: #28a745; cursor: grab; }
        #link-handle-trigger:hover { background-color: #218838; }

        .unlink-handle { background-color: #f44336; cursor: pointer; }
        .unlink-handle:hover { background-color: #d32f2f; }

        .temp-link-line { stroke: #28a745; stroke-width: 2.5px; stroke-dasharray: 5,5; pointer-events: none; }
        .process-node.link-target-hover { outline: 2px dashed #28a745; outline-offset: 2px; }
        #toggle-mini-map-button:hover { background-color: #ddd; }

        #tutorial-panel h4 { margin-top: 20px; margin-bottom: 8px; color: var(--bridgestone-red); border-bottom: 1px solid #eee; padding-bottom: 5px;}
        #tutorial-panel p, #tutorial-panel li { font-size: 0.9em; line-height: 1.6; margin-bottom: 10px; }
        #tutorial-panel ul { padding-left: 20px; list-style-type: disc; }
        #tutorial-panel .code-like { 
            background-color: #e9e9e9; 
            padding: 2px 5px; 
            border-radius: 3px; 
            font-family: monospace; 
            color: var(--bridgestone-red-darker);
        }

        #menu-button {
            position: relative;
            padding-left: 28px;
        }
        #menu-button::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 8px solid white;
        }

        .modal-content {
            border-top: 4px solid var(--bridgestone-red);
        }

        .page-footer {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bridgestone-footer-symbol {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            fill: var(--bridgestone-red);
        }
		.context-menu {
            display: none;
            position: absolute;
            z-index: 1010;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 5px 0;
            min-width: 150px;
        }
        .context-menu-item {
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        #notification-bar {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #333;
            color: white;
            padding: 10px 15px;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.9em;
            line-height: 1.4;
            box-sizing: border-box;
        }
        #notification-message {
            display: inline-block;
            max-width: calc(100% - 50px);
            text-align: left;
            vertical-align: middle;
        }
        #notification-message pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: rgba(0,0,0,0.1);
            padding: 5px;
            border-radius: 3px;
            margin-top: 5px;
            font-size: 0.95em;
            max-height: 100px;
            overflow-y: auto;
        }
        #notification-close {
            float: right;
            background: none;
            border: none;
            color: white;
            font-size: 1.3em;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            padding: 0 5px;
            margin-left: 10px;
        }
    </style>

    <style>
        body.dark-mode {
            background-color: #121212;
            color: #e0e0e0;
        }

        body.dark-mode .top-bar {
            background-color: #1e1e1e;
            border-bottom: 3px solid var(--bridgestone-red);
        }

        body.dark-mode .main-controls {
            background-color: #2a2a2a;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        body.dark-mode .main-controls button,
        body.dark-mode .main-controls input[type="search"],
        body.dark-mode #shortcut-show-dependencies-button,
        body.dark-mode #shortcut-simulate-impact-button {
            background-color: #333;
            color: #e0e0e0;
            border-color: #555;
        }

        body.dark-mode .main-controls button:hover:not(:disabled),
        body.dark-mode .main-controls input[type="search"]:hover,
        body.dark-mode #shortcut-show-dependencies-button:hover:not(:disabled),
        body.dark-mode #shortcut-simulate-impact-button:hover:not(:disabled) {
            background-color: #444;
            border-color: #777;
        }
        
        body.dark-mode #shortcut-show-dependencies-button:disabled,
        body.dark-mode #shortcut-simulate-impact-button:disabled {
            background-color: #444 !important;
            color: #888 !important;
            opacity: 0.6;
        }
        body.dark-mode #shortcut-show-dependencies-button:disabled:hover,
        body.dark-mode #shortcut-simulate-impact-button:disabled:hover {
            background-color: #444 !important;
        }

        body.dark-mode #toggle-filter-panel-button {
            background-color: #333 !important;
            color: #e0e0e0 !important;
            border: 1px solid #555 !important;
        }
        body.dark-mode #toggle-filter-panel-button:hover {
            background-color: #444 !important;
            border-color: #777 !important;
        }

        body.dark-mode #toggle-mini-map-button {
            background-color: #333 !important;
            color: #e0e0e0 !important;
            border: 1px solid #555 !important;
        }
        body.dark-mode #toggle-mini-map-button:hover {
            background-color: #444 !important;
            border-color: #777 !important;
        }
        
        body.dark-mode #menu-dependency-panel-trigger.disabled {
            background-color: #444 !important;
            color: #888 !important;
        }
        body.dark-mode #menu-dependency-panel-trigger.disabled:hover {
            background-color: #444 !important;
        }
        body.dark-mode #menu-dependency-panel-trigger svg {
            stroke: #e0e0e0;
        }

        body.dark-mode #menu-button {
            background-color: var(--bridgestone-red);
            color: white;
            border: 1px solid var(--bridgestone-red-darker);
        }
        body.dark-mode #menu-button:hover {
            background-color: var(--bridgestone-red-darker);
            color: white;
        }
        body.dark-mode #menu-button svg {
            fill: white;
        }


        body.dark-mode #diagram-container {
            background-color: #1e1e1e;
            border-color: var(--bridgestone-red);
        }
        
        body.dark-mode #welcome-message-overlay {
            background-color: rgba(30, 30, 30, 0.97);
            color: #e0e0e0;
        }
        body.dark-mode #welcome-message-overlay h2 {
            color: var(--bridgestone-red);
        }
        body.dark-mode #welcome-message-overlay strong {
            color: #f5f5f5;
        }
        body.dark-mode #welcome-message-overlay .highlight-path {
            color: #64b5f6;
        }


        body.dark-mode .process-node {
            background-color: #2c3e50;
            border-color: #4a657a;
            color: #e0e0e0;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }
        body.dark-mode .process-node.can-hover:hover {
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            border-color: #608da8;
        }
        body.dark-mode .process-node.selected {
            border-color: var(--bridgestone-red) !important;
            box-shadow: 0 0 8px var(--bridgestone-red) !important;
        }
        body.dark-mode .process-node.search-highlight {
            background-color: #5c431f !important;
            border-color: #ff8c00 !important;
            color: #fff !important;
        }
         body.dark-mode .process-node .node-type-symbol {
            color: #111;
            background-color: rgba(200, 200, 200, 0.7);
        }
        body.dark-mode #dependency-svg line {
            stroke: #aaa;
        }

        body.dark-mode .modal-content {
            background-color: #2b2b2b;
            color: #e0e0e0;
            border: 1px solid #444;
            border-top: 4px solid var(--bridgestone-red);
        }
        body.dark-mode .modal-content h3 {
            border-bottom: 1px solid #444;
        }
        body.dark-mode .modal-content label {
            color: #ccc;
        }
        body.dark-mode .modal-content input[type="text"],
        body.dark-mode .modal-content input[type="time"],
        body.dark-mode .modal-content textarea,
        body.dark-mode .modal-content input[type="number"],
        body.dark-mode .modal-content select {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
        }
        body.dark-mode .modal-content input.invalid,
        body.dark-mode .modal-content textarea.invalid,
        body.dark-mode .modal-content select.invalid {
            border-color: #e57373;
        }
        body.dark-mode .modal-content .error-message {
            color: #e57373;
        }
        body.dark-mode .modal-content .save-button { background-color: #4CAF50; color: white; }
        body.dark-mode .modal-content .save-button:hover { background-color: #45a049; }
        body.dark-mode .modal-content .cancel-button { background-color: #777; color: white; }
        body.dark-mode .modal-content .cancel-button:hover { background-color: #666; }
        body.dark-mode .modal-content .delete-button { background-color: #f44336; color: white; }
        body.dark-mode .modal-content .delete-button:hover { background-color: #e53935; }


        body.dark-mode #filter-panel,
        body.dark-mode #converter-panel,
        body.dark-mode #simulation-panel,
        body.dark-mode #tutorial-panel {
            background-color: #252525;
            color: #e0e0e0;
            box-shadow: -2px 0 5px rgba(0,0,0,0.3);
        }
        body.dark-mode #filter-panel h3, 
        body.dark-mode #converter-panel h3, 
        body.dark-mode #simulation-panel h3,
        body.dark-mode #tutorial-panel h3 {
            border-bottom: 1px solid #444;
        }
        body.dark-mode #filter-panel select, 
        body.dark-mode #filter-panel input[type="time"],
        body.dark-mode #simulation-panel input[type="number"], 
        body.dark-mode #simulation-panel input[type="text"],
        body.dark-mode #simulation-panel select,
        body.dark-mode #converter-panel input[type="file"]
         {
            background-color: #333;
            color: #e0e0e0;
            border-color: #555;
        }
        body.dark-mode #apply-filters-button,
        body.dark-mode #converter-panel button,
        body.dark-mode #simulation-panel button {
            background-color: #007bff;
            color: white;
        }
        body.dark-mode #apply-filters-button:hover,
        body.dark-mode #converter-panel button:hover,
        body.dark-mode #simulation-panel button:hover {
             background-color: #0056b3;
        }
        body.dark-mode #converter-panel .warning {
            color: #ffe082;
            background-color: #4e4010;
            border: 1px solid #a1883b;
        }
        body.dark-mode #converter-status pre, body.dark-mode #converter-panel pre {
            background-color: #1c1c1c;
            border: 1px solid #444;
            color: #ccc;
        }


        body.dark-mode #process-details {
            background-color: #2a2a2a;
            color: #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        body.dark-mode #process-details h3 { color: #f0f0f0; }
        body.dark-mode #process-details strong { color: #f5f5f5; }
        body.dark-mode #process-details button {
            background-color: #555; color: #fff; border-color: #777;
        }
        body.dark-mode #process-details button:hover { background-color: #666; }
        body.dark-mode #initiate-simulation-button {
            background-color: #b08d0f;
            color: black;
        }
         body.dark-mode #initiate-simulation-button:hover {
            background-color: #c9a326;
        }


        body.dark-mode .colors-toggle-bar, body.dark-mode .visual-controls {
            background-color: #2a2a2a;
            color: #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        body.dark-mode #toggle-colors-button {
            background-color: #333;
            color: #e0e0e0;
            border-color: #555;
        }
        body.dark-mode #toggle-colors-button:hover {
            background-color: #444;
        }
        body.dark-mode .visual-controls input[type="color"] {
             border-color: #555;
        }


        body.dark-mode #sticky-y-axis, body.dark-mode #sticky-x-axis {
            background-color: rgba(30, 30, 30, 0.92);
            border-color: #444;
        }
        body.dark-mode #sticky-y-axis .axis, body.dark-mode #sticky-x-axis .axis {
            background-color: rgba(50,50,50,0.8);
            border-color: #333;
            color: #ccc;
        }
        body.dark-mode #sticky-y-axis .axis:hover, body.dark-mode #sticky-x-axis .axis:hover {
            background-color: #404040;
            border-color: #555;
        }
        body.dark-mode #sticky-y-axis .axis.active-axis-filter, 
        body.dark-mode #sticky-x-axis .axis.active-axis-filter {
            background-color: #004c8c;
            border-color: #007bff;
            color: #fff;
        }

        body.dark-mode .page-footer {
            color: #aaa;
            border-top: 1px solid var(--bridgestone-red);
        }
        body.dark-mode .bridgestone-footer-symbol {
             fill: var(--bridgestone-red);
        }

        body.dark-mode #notification-bar {
            background-color: #424242;
            color: #e0e0e0;
        }
        body.dark-mode #notification-bar[style*="var(--bridgestone-red)"],
        body.dark-mode #notification-bar[style*="#DA291C"] {
            background-color: var(--bridgestone-red);
            color: white;
        }
        body.dark-mode #notification-bar[style*="#ffc107"] {
            background-color: #4e4010;
            color: #ffe082;
        }
        body.dark-mode #notification-bar[style*="#28a745"] {
            background-color: #1a5c2d;
            color: #c8e6c9;
        }
        body.dark-mode #notification-message pre {
            background-color: rgba(0,0,0,0.2);
            color: #f0f0f0;
        }
        body.dark-mode #notification-close {
            color: #e0e0e0;
        }
        
        body.dark-mode #menu-content,
        body.dark-mode #sheet-multi-select-dropdown,
        body.dark-mode #delete-view-config-dropdown,
        body.dark-mode .context-menu {
            background-color: #333;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.4);
            color: #e0e0e0;
            border: 1px solid #555;
        }
        body.dark-mode #menu-content button,
        body.dark-mode #menu-content .menu-item-group select {
            background-color: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #5f5f5f;
        }
        body.dark-mode #menu-content button:hover,
        body.dark-mode #menu-content .menu-item-group select:hover {
             background-color: #4a4a4a;
             border-color: #777;
        }

        body.dark-mode #menu-content label#json-file-input-label {
            background-color: #555 !important; 
            color: #e0e0e0 !important;
            border: 1px solid #777 !important;
        }
        body.dark-mode #menu-content label#json-file-input-label:hover {
            background-color: #666 !important;
            border-color: #888 !important;
        }

        body.dark-mode #sheet-multi-select-options label:hover,
        body.dark-mode .context-menu-item:hover,
        body.dark-mode #delete-view-config-dropdown .delete-item:hover {
            background-color: #404040;
        }
        body.dark-mode #menu-content h4 {
            color: #bbb;
            border-bottom-color: #555;
        }
        body.dark-mode #menu-content hr {
            background-color: #555;
        }


        body.dark-mode #dependency-panel-container {
            background-color: #252525;
            border-left: 2px solid #444;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
        }
        body.dark-mode #dependency-panel-title-bar {
            background-color: #1e1e1e;
            border-bottom: 1px solid #444;
            color: #e0e0e0;
        }
        body.dark-mode #dependency-tree-content {
            background-color: #2c2c2c;
        }
        body.dark-mode .dep-tree-node rect {
            fill: #3a4b5d;
            stroke: #5c7a96;
        }
        body.dark-mode .dep-tree-node.selected-root rect {
            fill: #4e647a;
            stroke: #7c9cb8;
        }
        body.dark-mode .dep-tree-node.not-in-view rect {
            fill: #444;
            stroke: #666;
        }
        body.dark-mode .dep-tree-node text {
            fill: #c0c0c0;
        }
        body.dark-mode .dep-tree-node text.toggle-text {
             fill: #aaa;
        }
        body.dark-mode .dep-tree-node text.toggle-text:hover {
             fill: #007bff;
        }
        body.dark-mode .dep-tree-link {
            stroke: #777;
        }
        body.dark-mode .dep-tree-node.path-highlight rect {
            fill: #b08d0f;
            stroke: #c9a326;
        }
        body.dark-mode .dep-tree-link.path-highlight {
            stroke: #c9a326;
        }

        body.dark-mode .process-node.simulation-target-node {
            box-shadow: 0 0 8px 2px gold !important;
        }
        body.dark-mode .process-node.simulation-new-node {
            border: 2px dashed #17a2b8 !important;
            background-color: #1a3f45 !important;
        }
        body.dark-mode .process-node.simulation-new-node::after {
            color: #17a2b8;
        }
        body.dark-mode .process-node.simulation-removed {
            border-color: #dc3545 !important;
            background-color: #5a2d32 !important;
        }
        body.dark-mode .process-node.simulation-removed::after {
            color: #dc3545;
        }
        body.dark-mode .process-node.simulation-affected-dependent {
            background-color: #b08d0f !important;
            border: 2px solid #e65100 !important;
        }
        body.dark-mode .process-node.simulation-output-at-risk {
            background-color: #4e4010 !important;
            border: 2px solid #FF8C00 !important;
        }
        body.dark-mode .process-node.simulation-input-conflict {
            background-color: #5a2d32 !important;
            border: 2px solid #FF4500 !important;
        }
        body.dark-mode .simulation-ghost-node {
            border-color: #555 !important;
            background-color: rgba(44, 62, 80, 0.3) !important;
        }

        body.dark-mode #mini-map-wrapper {
            border: 1px solid #555;
            background-color: rgba(40, 40, 40, 0.9);
            box-shadow: 0 0 10px rgba(0,0,0,0.4);
        }
        body.dark-mode #mini-map-viewport-rect {
            fill: rgba(0, 100, 255, 0.3);
            stroke: rgba(0, 100, 255, 0.9);
        }
        body.dark-mode .mini-map-node {
            stroke: #555;
        }

        body.dark-mode #tutorial-panel h4 {
            color: var(--bridgestone-red);
            border-bottom: 1px solid #444;
        }
        body.dark-mode #tutorial-panel .code-like {
            background-color: #333;
            color: #ffccc7;
        }

        body.dark-mode.presentation-mode .top-bar {
            background-color: #121212;
        }
        body.dark-mode.presentation-mode #diagram-container {
            background-color: #121212;
        }

    </style>
</head>
<body>
    <div id="notification-bar">
        <span id="notification-message"></span>
        <button id="notification-close">&times;</button>
    </div>

    <div class="top-bar">
        <div class="main-controls">
            <div class="menu-container">
                <button id="menu-button" title="Access application menu">
                    <svg class="bridgestone-button-symbol" version="1.2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1531 1373" width="14" height="14">
                        <title>Bridgestone Symbol</title>
                        <style> .s0, .s1 { fill: currentColor; } </style>
                        <path id="path137_btn" fill-rule="evenodd" class="s0" d="m1519.9 340.3c-51.9 209.9-197.4 267.7-341.5 292.5-5.8 0.7-2.9 6.6 0 7.3 170.4 35.9 277.2 174.1 223 378.1-67.2 249.3-252.2 353.9-590.1 353.9h-802.2c-8.8 0-11.7-10.3-5.9-16.8 205.5-258.2 534.6-599.6 806.6-833.6 8.1-6.6 18.3 0.7 16.1 10.2l-185.7 645.7h117.7c59.3 0 121.4-48.3 137.5-106.1l306.4-1070.5q9.5-0.7 19-0.7c192.3-3.6 354 119.9 299.1 340z"/>
                        <path id="path151_btn" class="s1" d="m188.3 784.9l187.2-654.4c18.2-68 92.8-129.5 168.2-129.5h571.8c9.5 0 13.2 13.2 5.1 17.6-296.9 203.3-655.9 504.5-916.3 775.1-6.5 6.6-19 0.7-16-8.8z"/>
                    </svg>
                    Menu
                </button>
                <div id="menu-content">
                    <h4>Data Management</h4>
                    <label for="json-file-input" id="json-file-input-label" title="Load JSON File">Load JSON</label>
                    <input type="file" id="json-file-input" accept=".json">
                    <span id="json-file-name"></span>
                    <button id="load-sharepoint-button" title="Load data from a predefined SharePoint link">Load from SharePoint</button>
                    <button id="export-xlsx-button" title="Export current diagram data to an XLSX file">Export XLSX</button>
                    <button id="toggle-converter-panel-button" title="Open panel to Load / Convert XLSX files to JSON format">Load / Convert XLSX</button>
                    <button id="clear-saved-state-button" title="Clear current diagram state (filters, zoom etc.). Saved View Configs will NOT be deleted.">Clear State</button>
                    
                    <hr>
                    <h4>View & Display</h4>
                    <div class="menu-item-group">
                        <div class="sheet-multi-select-container">
                            <button id="sheet-multi-select-button" title="Select sheets to view">Sheets ▼</button>
                            <div id="sheet-multi-select-dropdown">
                                <div><label><input type="checkbox" id="sheet-select-all-checkbox"> Select All</label></div>
                                <div id="sheet-multi-select-options">
                                    <p style="font-size:0.9em; color:#777;">Load data to see sheets.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="menu-item-group">
                        <label for="process-type-view-selector">Type View:</label>
                        <select id="process-type-view-selector" title="Select process types to view">
                            <option value="All" selected>All Types</option>
                            <option value="Standard">Standard Only</option>
                        </select>
                    </div>
                    <div class="menu-item-group">
                        <label for="view-config-selector">Load View:</label>
                        <select id="view-config-selector" title="Load a saved view configuration">
                            <option value="">- Select View -</option>
                        </select>
                        <div class="delete-view-config-container">
                            <button id="delete-view-config-button" title="Open menu to delete a view configuration">🗑️</button>
                            <div id="delete-view-config-dropdown">
                                <div style="font-size:0.9em; color:#777; padding: 8px 12px; text-align: center;">No views to delete.</div>
                            </div>
                        </div>
                    </div>
                    <button id="save-view-config-button" title="Save current filters and colors as a named view configuration">Save View Config</button>
                    <button id="toggle-dark-mode-button" title="Toggle Dark Mode">Dark Theme</button>

                    <hr>
                    <h4>Editing & Tools</h4>
                    <button id="add-process-button" title="Add a new process to the current sheet view">Add Process</button>
                    <button id="toggle-dependency-edit-button" title="Toggle dependency editing mode">Enable Dependency Editing</button>
                    <button id="menu-dependency-panel-trigger" title="Show Dependencies in Panel (select a node first)">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                            <circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle>
                            <circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                        </svg>
                        Show Dependencies
                    </button>
                    
                    <hr>
                    <h4>Help</h4>
                    <button id="toggle-tutorial-panel-button" title="Open tutorial panel">Tutorial / Help</button>
                </div>
            </div>

            <div class="search-group">
                <input type="search" id="search-process-input" placeholder="Search processes..." title="Search by ID, Short name, Description">
            </div>
            <button id="reset-button" title="Reset diagram zoom, scroll, filters, and selections to default">Reset View</button>
            
            <button id="shortcut-show-dependencies-button" title="Show Dependencies for Selected Process" disabled>
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                    <circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle>
                    <circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                </svg>
            </button>
            <button id="shortcut-simulate-impact-button" title="Simulate Impact for Selected Process" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                </svg>
            </button>

            <button id="toggle-presentation-mode-button" title="Toggle Presentation Mode">Presentation</button>
        </div>
        <button id="toggle-filter-panel-button" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; margin-left:10px;" title="Open panel to filter processes based on their attributes">Filters</button>
        <button id="toggle-mini-map-button" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; margin-left:5px;" title="Toggle Mini-Map">M</button>
    </div>

    <div id="diagram-container">
        <div id="diagram-zoom-pane">
            <svg id="dependency-svg"></svg>
            <div id="simulation-ghost-layer"></div>
            <div id="link-handle-trigger" title="Add dependency">+</div>
            <div id="welcome-message-overlay">
                <h2>Welcome to the Interactive Process Diagram!</h2>
                <p>To get started and visualize your processes, please load your data.</p>
                <p>
                    <strong>Recommended method:</strong>
                    <ol style="text-align: left; display: inline-block; margin-top: 10px;">
                        <li style="margin-bottom: 8px;">
                            Go to <span class="highlight-path">Menu &gt; Load from SharePoint</span> in the top-left menu.
                        </li>
                        <li style="margin-bottom: 8px;">
                            This will initiate a download of an <strong>XLSX</strong> file. Save it to your computer.
                        <li style="margin-bottom: 8px;">
                            In the converter panel that opens, click 'Choose File', select the XLSX file you just downloaded.
                        </li>
                        <li>
                            Click the <strong>'Convert and Load to Diagram'</strong> button.
                        </li>
                    </ol>
                </p>
                <p>Alternatively, if you already have a compatible JSON file, you can use <span class="highlight-path">Menu &gt; Load JSON</span>.</p>
                <p class="tutorial-prompt">
                    For more detailed instructions and to learn about all features, check out the 
                    <span class="highlight-path" onclick="document.getElementById('toggle-tutorial-panel-button').click(); document.getElementById('menu-content').style.display='none';">Tutorial</span> 
                    (available under <span class="highlight-path">Menu &gt; Tutorial / Help</span>).
                </p>
            </div>
        </div>
    </div>

    <div id="dependency-panel-container">
        <div id="dependency-panel-title-bar">
            <h3 id="dependency-panel-title">Process Dependencies</h3>
            <button id="highlight-tree-nodes-button" title="Highlight only these processes on the main diagram">Highlight Tree Nodes</button>
            <button id="close-dependency-panel-button" class="close-dependency-panel-button" title="Close dependency panel">&times;</button>
        </div>
        <div id="dependency-tree-content">
            <svg id="dependency-tree-svg"></svg>
        </div>
    </div>

    <div class="bottom-controls-container">
        <div class="colors-toggle-bar">
            <button id="toggle-colors-button" title="Show/Hide color controls">Colours 🎨</button>
        </div>
        <div class="visual-controls" style="display: none;">
            <label for="node-color">Process (default):</label>
            <input type="color" id="node-color" value="#aedff7" title="Default Process Node Color">
            <label for="lightning-color">Lightning:</label>
            <input type="color" id="lightning-color" value="#00ff00" title="Selected Node Lightning Effect Color">
            <label for="input-process-color">Input Process:</label>
            <input type="color" id="input-process-color" value="#90ee90" title="Input Dependent Process Color">
            <label for="output-process-color">Output Process:</label>
            <input type="color" id="output-process-color" value="#ffb6c1" title="Output Dependent Process Color">
            <label for="input-arrow-color">Input Arrow (Std):</label>
            <input type="color" id="input-arrow-color" value="#50c878" title="Input Dependency Arrow Color (Standard)">
            <label for="output-arrow-color">Output Arrow (Std):</label>
            <input type="color" id="output-arrow-color" value="#ff7f7f" title="Output Dependency Arrow Color (Standard)">

            <label for="blocking-node-color">Blocking Process:</label>
            <input type="color" id="blocking-node-color" value="#ffcc80" title="Blocking Process Node Color">
            <label for="informational-node-color">Informational Process:</label>
            <input type="color" id="informational-node-color" value="#b3e5fc" title="Informational Process Node Color">

            <label for="input-arrow-blocking-color">Input Arrow (Block):</label>
            <input type="color" id="input-arrow-blocking-color" value="#FF0000" title="Input Blocking Dependency Arrow Color">
            <label for="output-arrow-blocking-color">Output Arrow (Block):</label>
            <input type="color" id="output-arrow-blocking-color" value="#FF0000" title="Output Blocking Dependency Arrow Color">

            <label for="input-arrow-informational-color">Input Arrow (Info):</label>
            <input type="color" id="input-arrow-informational-color" value="#0000FF" title="Input Informational Dependency Arrow Color">
            <label for="output-arrow-informational-color">Output Arrow (Info):</label>
            <input type="color" id="output-arrow-informational-color" value="#0000FF" title="Output Informational Dependency Arrow Color">
        </div>
        <div id="process-details">
            <h3>Process Details</h3>
            <p>Click on a process in the diagram to see its details here.</p>
        </div>
    </div>

    <div id="process-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Add/Edit Process</h3>
            <input type="hidden" id="process-edit-id">
            <!-- MODIFICATION START: Added Sheet Selector -->
            <div>
                <label for="process-target-sheet-modal">Target Sheet:</label>
                <select id="process-target-sheet-modal"></select>
                <span class="error-message" id="error-process-target-sheet-modal"></span>
            </div>
            <!-- MODIFICATION END: Added Sheet Selector -->
            <div><label for="process-id-modal">ID (unique within its sheet):</label><input type="text" id="process-id-modal"><span class="error-message" id="error-process-id-modal"></span></div>
            <div><label for="process-short-name-modal">Short name:</label><input type="text" id="process-short-name-modal"><span class="error-message" id="error-process-short-name-modal"></span></div>
            <div><label for="process-wd-modal">WD (number, e.g., -5, 0, 3):</label><input type="number" id="process-wd-modal"><span class="error-message" id="error-process-wd-modal"></span></div>
            <div><label for="process-due-time-modal">Due time (HH:MM or HH:MM:SS):</label><input type="text" id="process-due-time-modal" placeholder="HH:MM or HH:MM:SS"><span class="error-message" id="error-process-due-time-modal"></span></div>
            <div><label for="process-dependencies-modal">Dependencies (IDs separated by semicolons, e.g., FA.1;FA.2_B;FA.3_I):</label><input type="text" id="process-dependencies-modal"><span class="error-message" id="error-process-dependencies-modal"></span></div>
            <div><label for="process-checklist-modal">Checklist:</label><input type="text" id="process-checklist-modal"><span class="error-message" id="error-process-checklist-modal"></span></div>
            <div><label for="process-company-codes-modal">Company Codes:</label><input type="text" id="process-company-codes-modal"><span class="error-message" id="error-process-company-codes-modal"></span></div>
            <div><label for="process-critical-modal">Critical (C/N):</label><input type="text" id="process-critical-modal"><span class="error-message" id="error-process-critical-modal"></span></div>
            <div><label for="process-description-modal">Description:</label><textarea id="process-description-modal" rows="3"></textarea><span class="error-message" id="error-process-description-modal"></span></div>
            <div><label for="process-frequency-modal">Frequency:</label><input type="text" id="process-frequency-modal"><span class="error-message" id="error-process-frequency-modal"></span></div>
            <div><label for="process-input-what-modal">Input (What):</label><input type="text" id="process-input-what-modal"><span class="error-message" id="error-process-input-what-modal"></span></div>
            <div><label for="process-input-who-modal">Input "Who":</label><input type="text" id="process-input-who-modal"><span class="error-message" id="error-process-input-who-modal"></span></div>
            <div><label for="process-output-who-modal">Output (Who):</label><input type="text" id="process-output-who-modal"><span class="error-message" id="error-process-output-who-modal"></span></div>
            <div><label for="process-responsibility-conso-modal">Responsibility - Conso:</label><input type="text" id="process-responsibility-conso-modal"><span class="error-message" id="error-process-responsibility-conso-modal"></span></div>
            <div><label for="process-process-type-modal">Process Type:</label>
                <select id="process-process-type-modal">
                    <option value="standard" selected>Standard</option>
                    <option value="blocking">Blocking</option>
                    <option value="informational">Informational</option>
                </select>
                <span class="error-message" id="error-process-process-type-modal"></span>
            </div>
            <div id="dynamic-fields-container"></div>
            <div class="button-group">
                <button id="delete-process-button" class="delete-button" style="display:none;">Delete</button>
                <button id="save-process-button" class="save-button">Save</button>
                <button id="cancel-process-button" class="cancel-button">Cancel</button>
            </div>
        </div>
    </div>

    <div id="filter-panel">
        <button id="close-filter-panel-button" class="close-panel-button" title="Close Filters">&times;</button>
        <h3>Filters</h3>
        <div id="filter-options-container">
            <p>Load data to see filter options.</p>
        </div>
        <button id="apply-filters-button">Apply Filters</button>
    </div>

    <div id="converter-panel">
        <button id="close-converter-panel-button" class="close-panel-button" title="Close Converter">&times;</button>
        <h1>XLSX to JSON Converter</h1>
        <p>Select an XLSX file. Each sheet will be converted. The output JSON will be an object with sheet names as keys.</p>
        <div class="warning">
            <strong>Important:</strong> Ensure column names in your XLSX file match expected keys (e.g., "ID", "Short name", "Process Type"). The converter will attempt to process all sheets.
        </div>
        <input type="file" id="xlsxFileInputConverter" accept=".xlsx, .xls">
        <button id="convertButtonConverter">Convert and Download JSON</button>
        <button id="convertAndLoadButtonConverter" style="margin-top: 10px; background-color: #17a2b8;">Convert and Load to Diagram</button>
        <div id="converter-status"></div>
        <h3>Generated JSON Preview (first 3 records of first sheet):</h3>
        <pre id="converterJsonPreview"></pre>
    </div>

    <div id="simulation-panel">
        <button id="close-simulation-panel-button" class="close-panel-button" title="Close Simulation Panel">&times;</button>
        <h3>Simulation Mode</h3>
        <p>Simulating impact for: <strong id="simulation-target-name">N/A</strong> (<span id="simulation-target-id-display"></span>)</p>
        
        <div class="simulation-type-selector-group">
            <button class="simulation-type-button active" data-simtype="remove" title="Remove Process">🗑️ Remove</button>
            <button class="simulation-type-button" data-simtype="shift" title="Shift Process Timing">↔️ Shift</button>
            <button class="simulation-type-button" data-simtype="add" title="Add New Process (Simulate)">➕ Add</button>
        </div>
        <input type="hidden" id="active-simulation-type" value="remove">


        <div id="simulation-shift-inputs" style="display:none; border-top: 1px solid #ddd; padding-top: 15px;">
            <label for="simulation-new-wd">New WD:</label>
            <input type="number" id="simulation-new-wd">
            <div class="error-message" id="error-simulation-new-wd" style="font-size: 0.8em; color: red; min-height: 1em;"></div>

            <label for="simulation-new-due-time">New Due Time (HH:MM or HH:MM:SS):</label>
            <input type="text" id="simulation-new-due-time" placeholder="HH:MM or HH:MM:SS">
            <div class="error-message" id="error-simulation-new-due-time" style="font-size: 0.8em; color: red; min-height: 1em;"></div>
        </div>
        
        <div id="simulation-add-inputs" style="display:none; border-top: 1px solid #ddd; padding-top: 15px; margin-top: 10px;">
            <h4>New Process Details (for Simulation)</h4>
            <div><label for="sim-add-id">ID (unique for simulation):</label><input type="text" id="sim-add-id"><span class="error-message" id="error-sim-add-id"></span></div>
            <div><label for="sim-add-short-name">Short Name:</label><input type="text" id="sim-add-short-name"><span class="error-message" id="error-sim-add-short-name"></span></div>
            <div><label for="sim-add-wd">WD:</label><input type="number" id="sim-add-wd"><span class="error-message" id="error-sim-add-wd"></span></div>
            <div><label for="sim-add-due-time">Due Time (HH:MM:SS):</label><input type="text" id="sim-add-due-time" placeholder="HH:MM:SS"><span class="error-message" id="error-sim-add-due-time"></span></div>
            <div><label for="sim-add-dependencies">Dependencies (IDs;...):</label><input type="text" id="sim-add-dependencies" placeholder="e.g., P1;P2_B;P3_I"><span class="error-message" id="error-sim-add-dependencies"></span></div>
            <div><label for="sim-add-process-type">Process Type:</label>
                <select id="sim-add-process-type">
                    <option value="standard" selected>Standard</option>
                    <option value="blocking">Blocking</option>
                    <option value="informational">Informational</option>
                </select>
                <span class="error-message" id="error-sim-add-process-type"></span>
            </div>
        </div>

        <div style="margin-top: 15px; display:flex; justify-content: space-between; align-items: center;">
            <button id="run-simulation-button" style="background-color:#007bff; color:white; flex-grow: 1; margin-right:5px;">Run Simulation</button>
            <button id="undo-simulation-params-button" title="Undo parameter changes in this panel" style="padding: 8px 10px; display: none;">↩️ Undo Params</button>
        </div>
        <button id="end-simulation-button" style="background-color:#6c757d; color:white; display:none; width:100%; margin-top:10px;">End Simulation</button>
        <button id="export-simulation-report-button" style="background-color:#17a2b8; color:white; display:none; margin-top:10px; width:100%;">Export Simulation Report</button>
        
        <div class="simulation-scenario-management">
            <label for="simulation-scenario-selector">Load Scenario:</label>
            <div style="display:flex;">
                <select id="simulation-scenario-selector" title="Load a saved simulation scenario">
                    <option value="">- Select Scenario -</option>
                </select>
                <button id="load-simulation-scenario-button" title="Load Selected Scenario">Load</button>
            </div>
            <button id="save-simulation-scenario-button" title="Save current simulation parameters as a new scenario" style="width:100%; margin-top:10px;">Save Current Scenario</button>
        </div>
        
        <div id="simulation-impact-info" style="margin-top:20px;">
            <div id="simulation-impact-list-container">
            </div>
        </div>
    </div>

    <div id="tutorial-panel">
        <button id="close-tutorial-panel-button" class="close-panel-button" title="Close Tutorial">&times;</button>
        <h3>Interactive Diagram Tutorial</h3>

        <h4>Introduction</h4>
        <p>Welcome to the Interactive Process Diagram! This tool helps you visualize, analyze, and understand complex process flows and their dependencies. Use this guide to learn about its features.</p>

        <h4>Loading Data</h4>
        <p>There are a few ways to get your process data into the diagram:</p>
        <ul>
            <li><strong>From SharePoint (Recommended for initial load):</strong>
                <ol>
                    <li>Go to <span class="code-like">Menu &gt; Load from SharePoint</span>.</li>
                    <li>This will download an XLSX file. Save it to your computer.</li>
                    <li>In the panel, select the downloaded XLSX file and click <strong>'Convert and Load to Diagram'</strong>.</li>
                </ol>
            </li>
            <li><strong>Load JSON File:</strong> If you have a pre-formatted JSON file, use <span class="code-like">Menu &gt; Load JSON</span>.</li>
            <li><strong>Load / Convert XLSX File:</strong> If you have an XLSX file (not from SharePoint or needing re-conversion), use <span class="code-like">Menu &gt; Load / Convert XLSX</span>. You can then either download the converted JSON or load it directly.</li>
        </ul>
        <p>The diagram expects specific column headers in your data (e.g., "ID", "Short name", "WD", "Due time", "Dependencies", "Process Type").</p>

        <h4>Understanding Process Nodes & Diagram Area</h4>
        <ul>
            <li>Each box (node) represents a process. It displays the "Short name".</li>
            <li>"WD" (Working Day) and "Due time" determine its position on the X (time/day) and Y (time of day) axes.</li>
            <li>Nodes can be of type "Standard", "Blocking" (shown with a 'B' symbol), or "Informational" (shown with an 'I' symbol). This affects dependency interpretation and can be set in your data or via the edit modal.</li>
            <li>Sticky axes (top and left) help you understand the timeline even when scrolled.</li>
        </ul>

        <h4>Navigating the Diagram</h4>
        <ul>
            <li><strong>Zoom:</strong> Use your mouse wheel to zoom in and out.</li>
            <li><strong>Pan:</strong> Click and drag the diagram background to move around.</li>
            <li><strong>Mini-Map:</strong> Toggle the Mini-Map using the 'M' button in the top right. It shows an overview and your current viewport.</li>
            <li><strong>Reset View:</strong> Click 'Reset View' to return to the default zoom and position.</li>
        </ul>

        <h4>Filtering and Searching</h4>
        <ul>
            <li><strong>Filters:</strong> Click the 'Filters' button to open the filter panel. You can filter processes based on various attributes like "Company Codes", "Frequency", "WD", "Due time", etc. Click 'Apply Filters'.</li>
            <li><strong>Search:</strong> Use the "Search processes..." bar to find nodes by ID, Short name, or Description. Matching nodes will be highlighted, others dimmed.</li>
            <li><strong>Axis Filtering:</strong> Click on a WD label (e.g., "WD 0") on the top sticky X-axis or a time label (e.g., "08:00") on the left sticky Y-axis to filter processes for that specific day or hour. Click again to clear.</li>
        </ul>

        <h4>Interacting with Nodes</h4>
        <ul>
            <li><strong>Selection:</strong> Click on a node to select it.
                <ul>
                    <li>The selected node will be highlighted.</li>
                    <li>Its direct inputs and outputs will also be highlighted with distinct colors.</li>
                    <li>Other non-related nodes will be dimmed.</li>
                    <li>Arrow lines will show dependencies to/from the selected node.</li>
                </ul>
            </li>
            <li><strong>Process Details:</strong> When a node is selected, its detailed information appears in the "Process Details" panel at the bottom. From here, you can edit the process or initiate a simulation.</li>
            <li><strong>Dependency Tree Panel:</strong> When a node is selected, the <span class="code-like">Menu &gt; Show Dependencies</span> option becomes active. Click it to open a side panel showing a hierarchical tree of its inputs and outputs.</li>
        </ul>

        <h4>Editing Dependencies</h4>
        <ol>
            <li>Go to <span class="code-like">Menu &gt; Enable Dependency Editing</span>.</li>
            <li>Click on a process node to select it.</li>
            <li>To add a dependency:
                <ul>
                    <li>A green '+' handle will appear on the right side of the selected node.</li>
                    <li>Click and drag this '+' handle to another process node (the target).</li>
                    <li>When you release the mouse button over the target node, a context menu will appear. Select the type of dependency: "Standard", "Blocking", or "Informational".</li>
                </ul>
            </li>
            <li>To remove a dependency:
                <ul>
                    <li>Red '-' handles will appear on the top-right of nodes that are direct outputs of the selected node.</li>
                    <li>Click the '-' handle on a dependent node to remove that specific link.</li>
                </ul>
            </li>
            <li>Disable editing via <span class="code-like">Menu &gt; Disable Dependency Editing</span>.</li>
        </ol>
        <p>Dependencies are stored in the "Dependencies" field of a process, separated by semicolons (e.g., <span class="code-like">ID1;ID2_B;ID3_I</span>). Suffixes <span class="code-like">_B</span> and <span class="code-like">_I</span> denote Blocking and Informational types, respectively.</p>

        <h4>Simulation Mode</h4>
        <p>This mode allows you to see the potential impact of changes without altering your actual data.</p>
        <ol>
            <li>Select a process node.</li>
            <li>In the "Process Details" panel, click the 'Simulate Impact' button.</li>
            <li>The Simulation Panel will open. Choose a simulation type:
                <ul>
                    <li><strong>Remove Process:</strong> See what happens if the target process is removed.</li>
                    <li><strong>Shift Process:</strong> Change the target process's WD and/or Due Time to see effects.</li>
                    <li><strong>Add Process (Simulate):</strong> Define a new process (ID, WD, Time, Dependencies) to see how its addition would affect the flow around the initially selected process.</li>
                </ul>
            </li>
            <li>Click 'Run Simulation'. The diagram will update to show:
                <ul>
                    <li>The target node (removed, shifted, or newly added).</li>
                    <li>Affected dependent nodes (e.g., those losing an input, potentially delayed outputs, or inputs with timing conflicts).</li>
                    <li>A summary of impacts will be listed in the panel.</li>
                </ul>
            </li>
            <li>Click 'Update Simulation' to try different parameters, or 'End Simulation' to return to normal view. You can also 'Export Simulation Report'.</li>
        </ol>

        <h4>Presentation Mode</h4>
        <p>Click the 'Presentation' button for a clean, full-screen view ideal for showcasing the diagram. Most UI controls are hidden. Click 'Presentation' again to exit.</p>

        <h4>View Configurations</h4>
        <ul>
            <li><strong>Save View:</strong> After setting up desired filters, colors (via the 'Colours 🎨' toggle), and process type views, go to <span class="code-like">Menu &gt; Save View Config</span> to save this setup with a name.</li>
            <li><strong>Load View:</strong> Use the "Load View:" dropdown in the <span class="code-like">Menu</span> to quickly apply a previously saved configuration.</li>
            <li><strong>Delete View:</strong> Use the trash icon next to "Load View:" in the <span class="code-like">Menu</span> to delete saved configurations.</li>
        </ul>

        <h4>Common Errors & Tips</h4>
        <ul>
            <li><strong>"JSON Parse Error" / "Error reading file":</strong> The JSON file you're trying to load is invalid. Check its syntax carefully (e.g., for missing commas, quotes, brackets). Online JSON validators can help.</li>
            <li><strong>"XLSX Validation Failed":</strong> The XLSX file is missing critical columns like "ID", "WD", or "Due time", or the data in these columns is not in the expected format (e.g., "WD" should be a number, "Due time" should be HH:MM:SS). Check the specific error messages in the Converter panel.</li>
            <li><strong>"Process not found":</strong> An action (like editing or simulation) was attempted on a process ID that doesn't exist in the currently loaded data or selected sheet view.</li>
            <li><strong>Performance:</strong> Very large diagrams (many thousands of nodes or complex dependencies) might experience slower rendering or interactions. Filtering data to smaller subsets can help.</li>
            <li><strong>Saving Data:</strong> Changes made (like adding/editing processes or dependencies) are currently stored in your browser's local storage. To permanently save changes to a file, use <span class="code-like">Menu &gt; Export XLSX</span>.</li>
        </ul>

    </div>


    <div id="mini-map-wrapper">
        <svg id="mini-map-svg"></svg>
    </div>

	<div id="dependency-type-menu" class="context-menu">
    <div class="context-menu-item" data-type="standard">Standard</div>
    <div class="context-menu-item" data-type="blocking">Blocking (_B)</div>
    <div class="context-menu-item" data-type="informational">Informational (_I)</div>
	</div>

<script>
    const dependencyTypeMenu = document.getElementById('dependency-type-menu');
    let pendingLinkSourceId = null;
    let pendingLinkSourceSheet = null;
    let pendingLinkTargetId = null;
    let pendingLinkTargetProcess = null; 
    let lastMouseUpEvent = null; 
    let processesData = {};
    let selectedSheetViews = [];
    let allDataSourceSheetNames = [];
    let currentProcessTypeView = "All";
    let sheetColors = ['#aedff7', '#f7aeae', '#aef7af', '#f7d9ae', '#aeaef7', '#f7aef7', '#aff7f7', '#cccccc', '#99ccff', '#ffcc99'];

    let currentZoom = 1;
    const diagramContainer = document.getElementById('diagram-container');
    const diagramPane = document.getElementById('diagram-zoom-pane');
    const svgLayer = document.getElementById('dependency-svg');
    const simulationGhostLayer = document.getElementById('simulation-ghost-layer');
    const detailsPane = document.getElementById('process-details');
    const fileInput = document.getElementById('json-file-input');
    const jsonFileNameSpan = document.getElementById('json-file-name');

    const modal = document.getElementById('process-modal');
    const modalTitle = document.getElementById('modal-title');
    const saveProcessButton = document.getElementById('save-process-button');
    const cancelProcessButton = document.getElementById('cancel-process-button');
    const deleteProcessButton = document.getElementById('delete-process-button');
    const dynamicFieldsContainer = document.getElementById('dynamic-fields-container');
	
	const XLSX_REQUIRED_KEYS = new Set(["ID", "Short name", "WD", "Due time"]);
    const XLSX_KEY_VALIDATION_SAMPLES = 5; 

    const filterPanel = document.getElementById('filter-panel');
    const filterOptionsContainer = document.getElementById('filter-options-container');
    const toggleFilterPanelButton = document.getElementById('toggle-filter-panel-button');
    const closeFilterPanelButton = document.getElementById('close-filter-panel-button');
    const applyFiltersButton = document.getElementById('apply-filters-button');

    const converterPanel = document.getElementById('converter-panel');
    const toggleConverterPanelButton = document.getElementById('toggle-converter-panel-button');
    const closeConverterPanelButton = document.getElementById('close-converter-panel-button');
    const xlsxFileInputConverter = document.getElementById('xlsxFileInputConverter');
    const convertButtonConverter = document.getElementById('convertButtonConverter');
    const convertAndLoadButtonConverter = document.getElementById('convertAndLoadButtonConverter');
    const converterStatusDiv = document.getElementById('converter-status');
    const converterJsonPreview = document.getElementById('converterJsonPreview');

    const searchInput = document.getElementById('search-process-input');
    const togglePresentationModeButton = document.getElementById('toggle-presentation-mode-button');
    const clearSavedStateButton = document.getElementById('clear-saved-state-button');
    const toggleDependencyEditButton = document.getElementById('toggle-dependency-edit-button');
    const loadSharePointButton = document.getElementById('load-sharepoint-button');


    const sheetMultiSelectButton = document.getElementById('sheet-multi-select-button');
    const sheetMultiSelectDropdown = document.getElementById('sheet-multi-select-dropdown');
    const sheetMultiSelectOptions = document.getElementById('sheet-multi-select-options');
    const sheetSelectAllCheckbox = document.getElementById('sheet-select-all-checkbox');

    const processTypeViewSelector = document.getElementById('process-type-view-selector');
    const menuButton = document.getElementById('menu-button');
    const menuContent = document.getElementById('menu-content');

    const toggleColorsButton = document.getElementById('toggle-colors-button');
    const visualControlsContainer = document.querySelector('.visual-controls');
    const bottomControlsContainer = document.querySelector('.bottom-controls-container'); 


    const saveViewConfigButton = document.getElementById('save-view-config-button');
    const loadViewConfigSelector = document.getElementById('view-config-selector');
    const deleteViewConfigButton = document.getElementById('delete-view-config-button');
    const deleteViewConfigDropdown = document.getElementById('delete-view-config-dropdown');


    const LOCAL_STORAGE_KEY = 'interactiveProcessDiagram_V23_MainState';
    const VIEW_CONFIGS_STORAGE_KEY = 'diagramViewConfigurations_V23';
    const SIMULATION_SCENARIOS_STORAGE_KEY = 'diagramSimulationScenarios_V23';


    const miniMapWrapper = document.getElementById('mini-map-wrapper');
    const miniMapSvg = document.getElementById('mini-map-svg');
    let miniMapViewportRect = null;
    let overallDiagramBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    const toggleMiniMapButton = document.getElementById('toggle-mini-map-button');

    const dependencyPanelContainer = document.getElementById('dependency-panel-container');
    const dependencyPanelTitle = document.getElementById('dependency-panel-title');
    const dependencyTreeContent = document.getElementById('dependency-tree-content');
    const dependencyTreeSvg = document.getElementById('dependency-tree-svg');
    const menuDependencyPanelTrigger = document.getElementById('menu-dependency-panel-trigger');
    const closeDependencyPanelBtn = document.getElementById('close-dependency-panel-button');
    const highlightTreeNodesButton = document.getElementById('highlight-tree-nodes-button');

    const linkHandleTrigger = document.getElementById('link-handle-trigger'); 
    let isLinking = false;
    let linkStartProcessId = null;
    let linkStartProcessSheet = null;
    let tempLinkLine = null;
    let dependencyEditingEnabled = false; 


    const simulationPanel = document.getElementById('simulation-panel');
    const closeSimulationPanelButton = document.getElementById('close-simulation-panel-button');
    const simulationTargetNameSpan = document.getElementById('simulation-target-name');
    const simulationTargetIdSpan = document.getElementById('simulation-target-id-display');
    
    const simulationTypeSelectorGroup = document.querySelector('.simulation-type-selector-group');
    const activeSimulationTypeInput = document.getElementById('active-simulation-type');
    
    const simulationShiftInputsDiv = document.getElementById('simulation-shift-inputs');
    const simulationAddInputsDiv = document.getElementById('simulation-add-inputs'); 
    const simulationNewWdInput = document.getElementById('simulation-new-wd');
    const simulationNewDueTimeInput = document.getElementById('simulation-new-due-time');
    const runSimulationButton = document.getElementById('run-simulation-button');
    const endSimulationButton = document.getElementById('end-simulation-button');
    const exportSimulationReportButton = document.getElementById('export-simulation-report-button'); 
    const simulationImpactListContainer = document.getElementById('simulation-impact-list-container'); 
    const undoSimulationParamsButton = document.getElementById('undo-simulation-params-button');
    const saveSimulationScenarioButton = document.getElementById('save-simulation-scenario-button');
    const loadSimulationScenarioButton = document.getElementById('load-simulation-scenario-button');
    const simulationScenarioSelector = document.getElementById('simulation-scenario-selector');
    
    let isSimulationModeActive = false;
    let simulationTargetProcessId = null;
    let simulationTargetProcessSheet = null;
    let currentSimulationType = 'remove'; 
    let simulatedShiftWd = null;
    let simulatedShiftDueTime = null;
    let simulatedNewProcessData = null; 
    let originalSimulatedNodeStyles = { top: null, left: null, zIndex: null, ghostElement: null };
    let previousSimulationParams = {};
    let currentImpactPaths = [];

    const notificationBar = document.getElementById('notification-bar');
    const notificationMessageSpan = document.getElementById('notification-message');
    const notificationCloseButton = document.getElementById('notification-close');
    let notificationTimeout;

    const tutorialPanel = document.getElementById('tutorial-panel');
    const toggleTutorialPanelButton = document.getElementById('toggle-tutorial-panel-button');
    const closeTutorialPanelButton = document.getElementById('close-tutorial-panel-button');
    const welcomeMessageOverlay = document.getElementById('welcome-message-overlay');

    const shortcutShowDependenciesButton = document.getElementById('shortcut-show-dependencies-button');
    const shortcutSimulateImpactButton = document.getElementById('shortcut-simulate-impact-button');


    const SVG_NS = "http://www.w3.org/2000/svg";
    const DEP_TREE_MAX_DEPTH = 3; 
    let topBarHeight = 0;

    let currentDependencyTreeRootProcess = null;
    let currentTreeInputsData = [];
    let currentTreeOutputsData = [];
    let dependencyTreeNodeMap = new Map(); 


    let temporaryActiveFilters = {};
    let currentAppliedFilters = {};
    let currentAxisFilter = { type: null, value: null, valueEnd: null };
    let currentlySelectedProcessId = null;
    let nodeLayouts = {};

    let isTreeHighlightActive = false;
    let highlightedTreeNodesIds = new Set();

    const PADDING = 60;
    const NODE_BASE_WIDTH = 80;
    const NODE_HEIGHT = 26;
    const VERTICAL_NODE_PADDING = 6;
    const Y_AXIS_LABEL_WIDTH_ORIGINAL = 55;
    const STICKY_Y_AXIS_WIDTH = Y_AXIS_LABEL_WIDTH_ORIGINAL;
    const STICKY_X_AXIS_HEIGHT = 25;
    const SCROLLBAR_HEIGHT_ESTIMATE = 18;
    let gTimeBins = [];
    let gUniqueDataWds = [];
    let gUniqueDueTimeHours = [];
    let gWdColumnWidth = 0;
    let gPlotHeight = 0;
    let gTimeBinSizeSec = 3600;
    let gDiagramPanePadding = PADDING;
    let gYAxisLabelWidthOriginal = Y_AXIS_LABEL_WIDTH_ORIGINAL;
    let stickyYAxisContainer = null;
    let stickyXAxisContainer = null;
    let stickyAxisInitialized = false;

    const SHAREPOINT_DOWNLOAD_LINK = "https://salesbridge.sharepoint.com/sites/BSEMIA-BSBEBS/Quality/_layouts/download.aspx?SourceUrl=https://salesbridge.sharepoint.com/sites/BSEMIA-BSBEBS/Quality/Test%20RTR/processes_multisheet_converted%20%20(4).xlsx";

    let configColors = {
        node: '#aedff7',
		blockingNode: '#ffcc80',
        informationalNode: '#b3e5fc',
        lightning: '#00ff00',
        inputProcess: '#90ee90',
        outputProcess: '#ffb6c1',
        inputArrow: '#50c878',
        outputArrow: '#ff7f7f',
        inputArrowBlocking: '#FF0000',
        outputArrowBlocking: '#FF0000',
        inputArrowInformational: '#0000FF',
        outputArrowInformational: '#0000FF',
        nodeSymbolColor: '#333333'
    };

    const expectedDiagramKeys = [
        "ID", "Short name", "WD", "Due time", "Dependencies",
        "Checklist", "Company Codes", "Critical (C) or Non-Critical (N)",
        "Description", "Frequency", "Input (What)", "Input \"Who\"",
        "Output (Who)", "Responsibility - Conso", "Process Type"
    ];
    const JSON_VALIDATION_REQUIRED_KEYS = ["ID", "WD", "Due time"];


    // MODIFICATION: Added _targetSheet for modal internal use (not saved to process data with this key)
    const allProcessFields = [
        // { idSuffix: "target-sheet-modal", jsonKey: "_targetSheet", type: "sheet-select", label: "Target Sheet" }, // Placeholder for form logic
        { idSuffix: "id-modal", jsonKey: "ID", type: "text", readOnlyEdit: false, required: true }, // Made ID editable
        { idSuffix: "short-name-modal", jsonKey: "Short name", type: "text", required: true },
        { idSuffix: "wd-modal", jsonKey: "WD", type: "number", required: true },
        { idSuffix: "due-time-modal", jsonKey: "Due time", type: "custom-time", required: true },
        { idSuffix: "dependencies-modal", jsonKey: "Dependencies", type: "text" },
        { idSuffix: "checklist-modal", jsonKey: "Checklist", type: "text" },
        { idSuffix: "company-codes-modal", jsonKey: "Company Codes", type: "text" },
        { idSuffix: "critical-modal", jsonKey: "Critical (C) or Non-Critical (N)", type: "text" },
        { idSuffix: "description-modal", jsonKey: "Description", type: "textarea" },
        { idSuffix: "frequency-modal", jsonKey: "Frequency", type: "text" },
        { idSuffix: "input-what-modal", jsonKey: "Input (What)", type: "text" },
        { idSuffix: "input-who-modal", jsonKey: "Input \"Who\"", type: "text" },
        { idSuffix: "output-who-modal", jsonKey: "Output (Who)", type: "text" },
        { idSuffix: "responsibility-conso-modal", jsonKey: "Responsibility - Conso", type: "text" },
        { idSuffix: "process-process-type-modal", jsonKey: "Process Type", type: "select", options: ["standard", "blocking", "informational"], default: "standard" }
    ];
    const excludedFilterKeys = new Set(["ID", "Short name", "Dependencies", "Description"]);
    const multiSelectFilterKeys = new Set(["Checklist", "Company Codes", "Critical (C) or Non-Critical (N)", "Frequency", "Input (What)", "Input \"Who\"", "Output (Who)", "Responsibility - Conso", "WD"]);


    notificationCloseButton.addEventListener('click', () => {
        notificationBar.style.display = 'none';
        if (notificationTimeout) clearTimeout(notificationTimeout);
    });

    fileInput.addEventListener('change', handleJsonFileSelect);
    document.getElementById('reset-button').addEventListener('click', () => {
        if (isSimulationModeActive) endSimulation();
        currentZoom = 1;
        diagramPane.style.transform = `scale(${currentZoom})`;
        fullReset();
        diagramContainer.scrollTop = 0;
        diagramContainer.scrollLeft = 0;
        requestAnimationFrame(() => {
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
        });
        saveStateToLocalStorage();
    });
    document.getElementById('add-process-button').addEventListener('click', openAddModal);
    document.getElementById('export-xlsx-button').addEventListener('click', exportToXlsx);
    loadSharePointButton.addEventListener('click', handleLoadFromSharePoint);


    menuButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isMenuOpen = menuContent.style.display === 'block';
        if (!isMenuOpen) { 
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            tutorialPanel.classList.remove('open'); 
            dependencyPanelContainer.classList.remove('visible');
            sheetMultiSelectDropdown.style.display = 'none';
            deleteViewConfigDropdown.style.display = 'none';
            simulationPanel.classList.remove('open');
            updateAllDependencyAndSimShortcutButtonsState();
        }
        menuContent.style.display = isMenuOpen ? 'none' : 'block';
    });

    sheetMultiSelectButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isDropdownOpen = sheetMultiSelectDropdown.style.display === 'block';
        if (!isDropdownOpen) { 
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            tutorialPanel.classList.remove('open'); 
            dependencyPanelContainer.classList.remove('visible');
            deleteViewConfigDropdown.style.display = 'none';
            simulationPanel.classList.remove('open');
        }
        sheetMultiSelectDropdown.style.display = isDropdownOpen ? 'none' : 'block';
    });

    sheetSelectAllCheckbox.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        const checkboxes = sheetMultiSelectOptions.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = isChecked);
        handleSheetSelectionChange();
    });


    toggleConverterPanelButton.addEventListener('click', () => {
        converterPanel.classList.toggle('open');
        filterPanel.classList.remove('open');
        tutorialPanel.classList.remove('open'); 
        dependencyPanelContainer.classList.remove('visible');
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        simulationPanel.classList.remove('open');
    });

    toggleTutorialPanelButton.addEventListener('click', () => {
        tutorialPanel.classList.toggle('open');
        filterPanel.classList.remove('open');
        converterPanel.classList.remove('open');
        dependencyPanelContainer.classList.remove('visible');
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        simulationPanel.classList.remove('open');
    });
    closeTutorialPanelButton.addEventListener('click', () => tutorialPanel.classList.remove('open'));


    toggleFilterPanelButton.addEventListener('click', () => {
        filterPanel.classList.toggle('open');
        converterPanel.classList.remove('open');
        tutorialPanel.classList.remove('open'); 
        dependencyPanelContainer.classList.remove('visible');
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        simulationPanel.classList.remove('open');
    });
    closeFilterPanelButton.addEventListener('click', () => filterPanel.classList.remove('open'));
    applyFiltersButton.addEventListener('click', applyGeneralFilters);
    closeConverterPanelButton.addEventListener('click', () => converterPanel.classList.remove('open'));
    convertButtonConverter.addEventListener('click', handleConvertXlsxToJson);
    convertAndLoadButtonConverter.addEventListener('click', handleConvertAndLoadXlsxToDiagram);


    toggleColorsButton.addEventListener('click', () => {
        const isHidden = visualControlsContainer.style.display === 'none' || visualControlsContainer.style.display === '';
        visualControlsContainer.style.display = isHidden ? 'flex' : 'none';
        toggleColorsButton.textContent = isHidden ? 'Colours 🎨 (Hide)' : 'Colours 🎨 (Show)';
        saveStateToLocalStorage();
    });

    saveProcessButton.addEventListener('click', saveProcess);
    cancelProcessButton.addEventListener('click', closeModal);
    deleteProcessButton.addEventListener('click', deleteCurrentProcess);

    saveViewConfigButton.addEventListener('click', saveCurrentViewConfiguration);
    loadViewConfigSelector.addEventListener('change', loadSelectedViewConfiguration);

    deleteViewConfigButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isDeleteDropdownOpen = deleteViewConfigDropdown.style.display === 'block';
        if (!isDeleteDropdownOpen) { 
            sheetMultiSelectDropdown.style.display = 'none';
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            tutorialPanel.classList.remove('open'); 
            dependencyPanelContainer.classList.remove('visible');
            simulationPanel.classList.remove('open');
            populateDeleteViewDropdown(); 
        }
        deleteViewConfigDropdown.style.display = isDeleteDropdownOpen ? 'none' : 'block';
    });

    toggleDependencyEditButton.addEventListener('click', () => {
        const currentStatus = dependencyEditingEnabled ? "Enabled" : "Disabled";
        const desiredAction = dependencyEditingEnabled ? "Disable" : "Enable";
        const confirmationMessage = `Dependency editing is currently ${currentStatus}. Do you want to ${desiredAction} it?`;

        if (confirm(confirmationMessage)) { 
            dependencyEditingEnabled = !dependencyEditingEnabled;
            updateDependencyEditButtonText();
            positionActionIcons(); 
            saveStateToLocalStorage();
            showNotification(`Dependency editing has been ${dependencyEditingEnabled ? "Enabled" : "Disabled"}.`, 'info');
        }
        menuContent.style.display = 'none';
        updateAllDependencyAndSimShortcutButtonsState();
    });


    window.addEventListener('click', (event) => {
        if (event.target == modal) closeModal();

        if (
            !menuButton.contains(event.target) && !menuContent.contains(event.target) &&
            !sheetMultiSelectButton.contains(event.target) && !sheetMultiSelectDropdown.contains(event.target) &&
            !deleteViewConfigButton.contains(event.target) && !deleteViewConfigDropdown.contains(event.target) &&
            !diagramContainer.contains(event.target) &&
            !dependencyPanelContainer.contains(event.target) &&
            !filterPanel.contains(event.target) &&
            !converterPanel.contains(event.target) &&
            !tutorialPanel.contains(event.target) && 
            !simulationPanel.contains(event.target) && 
            event.target !== menuDependencyPanelTrigger &&
            !menuDependencyPanelTrigger.contains(event.target) &&
            event.target !== linkHandleTrigger &&
            !event.target.classList.contains('unlink-handle') &&
            !event.target.closest('.top-bar') && 
            !event.target.closest('.bottom-controls-container') && 
            !event.target.closest('.modal') &&
            !notificationBar.contains(event.target) 
            ) {
            if (currentlySelectedProcessId && !isTreeHighlightActive && !isSimulationModeActive) { 
                clearSelectionHighlightsAndDimming();
                currentlySelectedProcessId = null;
                displayProcessDetails(null);
                hideActionIcons();
                updateAllDependencyAndSimShortcutButtonsState();
            } else if (isTreeHighlightActive && !diagramPane.contains(event.target) && !dependencyPanelContainer.contains(event.target) && !event.target.closest('.top-bar') && !event.target.closest('.bottom-controls-container')) { 
                isTreeHighlightActive = false;
                highlightedTreeNodesIds.clear();
                clearSelectionHighlightsAndDimming();
                currentlySelectedProcessId = null;
                displayProcessDetails(null);
                hideActionIcons();
                renderDiagramAndRestoreState();
                updateAllDependencyAndSimShortcutButtonsState();
            }
        }

        if (
            (!menuButton.contains(event.target) && !menuContent.contains(event.target)) &&
            (!sheetMultiSelectButton.contains(event.target) && !sheetMultiSelectDropdown.contains(event.target)) &&
            (!deleteViewConfigButton.contains(event.target) && !deleteViewConfigDropdown.contains(event.target)) &&
            (!dependencyTypeMenu.contains(event.target) && event.target !== linkHandleTrigger) && 
            (!filterPanel.contains(event.target) && event.target !== toggleFilterPanelButton) &&
            (!converterPanel.contains(event.target) && event.target !== toggleConverterPanelButton && event.target !== loadSharePointButton) && 
            (!tutorialPanel.contains(event.target) && event.target !== toggleTutorialPanelButton) && 
            (!simulationPanel.contains(event.target) && event.target !== closeSimulationPanelButton && (document.getElementById('initiate-simulation-button') ? event.target !== document.getElementById('initiate-simulation-button') : true) && event.target !== shortcutSimulateImpactButton) &&
            (!dependencyPanelContainer.contains(event.target) && event.target !== menuDependencyPanelTrigger && !menuDependencyPanelTrigger.contains(event.target) && event.target !== closeDependencyPanelBtn && event.target !== shortcutShowDependenciesButton) &&
            !modal.contains(event.target) && 
            !diagramContainer.contains(event.target) && 
            !bottomControlsContainer.contains(event.target) &&
            !notificationBar.contains(event.target) 
        ) {
             menuContent.style.display = 'none';
             sheetMultiSelectDropdown.style.display = 'none';
             deleteViewConfigDropdown.style.display = 'none';
			 dependencyTypeMenu.style.display = 'none'; 
             filterPanel.classList.remove('open');
             if (event.target !== loadSharePointButton) { 
                converterPanel.classList.remove('open');
             }
             tutorialPanel.classList.remove('open'); 
             simulationPanel.classList.remove('open');
        }
    });
    diagramContainer.addEventListener('wheel', (e) => { e.preventDefault(); zoom(e.deltaY > 0 ? 0.9 : 1.1, e); });

    processTypeViewSelector.addEventListener('change', handleProcessTypeViewChange);

    const throttledSaveScrollState = throttle(() => {
        if (Object.keys(processesData).length > 0 && getCurrentlyVisibleProcesses().length > 0) saveStateToLocalStorage();
    }, 250);
    const handleScrollAndResize = throttle(() => {
        updateTopBarHeight(); 
        if (typeof updateStickyAxesContainerPositions === 'function' && typeof updateStickyAxesLabels === 'function' && stickyAxisInitialized && Object.keys(processesData).length > 0 && getCurrentlyVisibleProcesses().length > 0) {
            requestAnimationFrame(() => {
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
                updateMiniMapViewPort();
                positionActionIcons(); 
            });
        }
        throttledSaveScrollState();
    }, 16);

    diagramContainer.addEventListener('scroll', handleScrollAndResize);
    window.addEventListener('scroll', handleScrollAndResize);
    window.addEventListener('resize', () => {
        handleScrollAndResize();
        drawMiniMap();
        if(dependencyPanelContainer.classList.contains('visible')) {
             dependencyPanelContainer.style.right = '0';
        } else {
             dependencyPanelContainer.style.right = `-${dependencyPanelContainer.offsetWidth}px`;
        }
        if(simulationPanel.classList.contains('open')) { 
             simulationPanel.style.right = '0';
        } else {
             simulationPanel.style.right = `-${simulationPanel.offsetWidth}px`;
        }
        if(tutorialPanel.classList.contains('open')) { 
             tutorialPanel.style.right = '0';
        } else {
             tutorialPanel.style.right = `-${tutorialPanel.offsetWidth}px`;
        }
    });

    searchInput.addEventListener('input', (e) => {
        if (isSimulationModeActive) return; 
        applySearchHighlight(e.target.value);
    });

    togglePresentationModeButton.addEventListener('click', () => {
        if (isSimulationModeActive) endSimulation();
        document.body.classList.toggle('presentation-mode');
        updateTopBarHeight();
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';

        if (document.body.classList.contains('presentation-mode')) { 
            hideActionIcons(); 
            toggleDependencyPanel(false); 
            toggleSimulationPanel(false); 
            tutorialPanel.classList.remove('open'); 
            notificationBar.style.display = 'none'; 
        } else { 
            if (!dependencyPanelContainer.classList.contains('visible') &&
                (dependencyPanelContainer.style.right === '0px' || dependencyPanelContainer.style.right === '-0px')) {
                toggleDependencyPanel(false); 
            }
            if (!simulationPanel.classList.contains('open') &&
                (simulationPanel.style.right === '0px' || simulationPanel.style.right === '-0px')) {
                toggleSimulationPanel(false); 
            }
             positionActionIcons(); 
        }
        updateAllDependencyAndSimShortcutButtonsState();

        requestAnimationFrame(() => {
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
        });
        saveStateToLocalStorage();
    });

    clearSavedStateButton.addEventListener('click', () => {
        if (isSimulationModeActive) endSimulation();
        if (confirm("Are you sure you want to clear the current diagram state (loaded data, zoom, filters, colors)? Saved View Configurations AND Simulation Scenarios will NOT be deleted. The page will reload with defaults.")) {
            localStorage.removeItem(LOCAL_STORAGE_KEY); 
            showNotification("Current diagram state cleared. Saved View Configs & Sim Scenarios remain. Reloading page.", 'info', 3000);
            menuContent.style.display = 'none';
            sheetMultiSelectDropdown.style.display = 'none';
            deleteViewConfigDropdown.style.display = 'none';
            setTimeout(() => window.location.reload(), 3000);
        }
    });


    menuDependencyPanelTrigger.addEventListener('click', (e) => {
        e.stopPropagation();
        if (isSimulationModeActive || menuDependencyPanelTrigger.disabled) return; 
        if (currentlySelectedProcessId) {
            generateAndShowDependencyTree(currentlySelectedProcessId);
            toggleDependencyPanel(true);
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            tutorialPanel.classList.remove('open'); 
            menuContent.style.display = 'none';
            sheetMultiSelectDropdown.style.display = 'none';
            deleteViewConfigDropdown.style.display = 'none';
            simulationPanel.classList.remove('open');
        } else {
            showNotification("Please select a process node first to see its dependencies.", "info");
        }
    });
    closeDependencyPanelBtn.addEventListener('click', () => toggleDependencyPanel(false));
    highlightTreeNodesButton.addEventListener('click', highlightTreeNodesOnDiagram);

    linkHandleTrigger.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        if (isSimulationModeActive || !dependencyEditingEnabled) return;
        if (!currentlySelectedProcessId || !nodeLayouts[currentlySelectedProcessId]) return;
        isLinking = true;
        linkStartProcessId = currentlySelectedProcessId;
        const startProcess = getCurrentlyVisibleProcesses(true).find(p => p.ID === linkStartProcessId);
        linkStartProcessSheet = startProcess ? (startProcess._sourceSheet || (selectedSheetViews.length === 1 ? selectedSheetViews[0] : null)) : (selectedSheetViews.length === 1 ? selectedSheetViews[0] : null);
        linkHandleTrigger.style.cursor = 'grabbing';
        const startNodeLayout = nodeLayouts[linkStartProcessId];
        if (!startNodeLayout) { isLinking = false; return; }
        const startX = startNodeLayout.finalX + startNodeLayout.width / 2;
        const startY = startNodeLayout.finalY + startNodeLayout.height / 2;
        tempLinkLine = document.createElementNS(SVG_NS, 'line');
        tempLinkLine.setAttribute('class', 'temp-link-line');
        tempLinkLine.setAttribute('x1', startX);
        tempLinkLine.setAttribute('y1', startY);
        tempLinkLine.setAttribute('x2', startX);
        tempLinkLine.setAttribute('y2', startY);
        svgLayer.appendChild(tempLinkLine);
        e.preventDefault();
    });

    diagramPane.addEventListener('click', function(e) {
        if (isSimulationModeActive || !dependencyEditingEnabled) return; 
        if (e.target && e.target.classList.contains('unlink-handle')) {
            e.stopPropagation();
            const sourceId = e.target.dataset.sourceId;
            const targetRawDep = e.target.dataset.targetRawDep;
            const sourceSheet = e.target.dataset.sourceSheet;

            if (sourceId && targetRawDep && sourceSheet) {
                const sourceProcessData = processesData[sourceSheet]?.find(p => p.ID === sourceId);
                if (sourceProcessData && sourceProcessData.Dependencies) {
                    let depsArray = String(sourceProcessData.Dependencies).split(';').map(d => d.trim()).filter(d => d);
                    const indexToRemove = depsArray.indexOf(targetRawDep);
                    if (indexToRemove > -1) {
                        depsArray.splice(indexToRemove, 1);
                        sourceProcessData.Dependencies = depsArray.join(';');
                        renderDiagramAndRestoreState();
                        if (dependencyPanelContainer.classList.contains('visible')) {
                            generateAndShowDependencyTree(sourceId);
                        }
                        saveStateToLocalStorage();
                    } else {
                         console.warn("Could not find raw dependency to unlink:", targetRawDep, "in", depsArray);
                    }
                }
            }
            positionActionIcons();
        }
    });


    diagramContainer.addEventListener('mousemove', (e) => {
        if (!isLinking || !tempLinkLine || isSimulationModeActive || !dependencyEditingEnabled) return;
        e.preventDefault();
        const dcRect = diagramContainer.getBoundingClientRect();
        const mouseSvgX = (e.clientX - dcRect.left + diagramContainer.scrollLeft) / currentZoom;
        const mouseSvgY = (e.clientY - dcRect.top + diagramContainer.scrollTop) / currentZoom;

        tempLinkLine.setAttribute('x2', mouseSvgX);
        tempLinkLine.setAttribute('y2', mouseSvgY);

        diagramPane.querySelectorAll('.process-node:not(.filtered-out-general):not(.filtered-out-axis):not(.search-dimmed):not(.tree-highlight-dimmed)').forEach(nodeEl => {
            const procId = nodeEl.dataset.id;
            if (procId === linkStartProcessId) return;
            const layout = nodeLayouts[procId];
            if (layout &&
                mouseSvgX >= layout.finalX && mouseSvgX <= layout.finalX + layout.width &&
                mouseSvgY >= layout.finalY && mouseSvgY <= layout.finalY + layout.height) {
                nodeEl.classList.add('link-target-hover');
            } else {
                nodeEl.classList.remove('link-target-hover');
            }
        });
    });

    document.addEventListener('mouseup', (e) => {
        if (isPanning && e.target !== linkHandleTrigger && !e.target.classList.contains('unlink-handle')) {
            isPanning = false;
            diagramContainer.style.cursor = 'grab';
        }

        if (!isLinking || isSimulationModeActive || !dependencyEditingEnabled) {
            if (isLinking) {
                isLinking = false;
                linkHandleTrigger.style.cursor = 'grab';
                if (tempLinkLine) { tempLinkLine.remove(); tempLinkLine = null; }
                diagramPane.querySelectorAll('.process-node.link-target-hover').forEach(el => el.classList.remove('link-target-hover'));
                linkStartProcessId = null; linkStartProcessSheet = null;
            }
            if (dependencyTypeMenu.style.display === 'block' && !dependencyTypeMenu.contains(e.target)) {
                dependencyTypeMenu.style.display = 'none';
            }
            return;
        }

        isLinking = false;
        linkHandleTrigger.style.cursor = 'grab';
        if (tempLinkLine) {
            tempLinkLine.remove();
            tempLinkLine = null;
        }
        diagramPane.querySelectorAll('.process-node.link-target-hover').forEach(el => el.classList.remove('link-target-hover'));
        
        lastMouseUpEvent = e; 

        let targetProcessNodeElement = null; 

        if (diagramContainer.contains(e.target) || e.target === diagramContainer || diagramPane.contains(e.target)) {
            const dcRect = diagramContainer.getBoundingClientRect();
            const mouseSvgX = (e.clientX - dcRect.left + diagramContainer.scrollLeft) / currentZoom;
            const mouseSvgY = (e.clientY - dcRect.top + diagramContainer.scrollTop) / currentZoom;

            const visibleProcesses = getCurrentlyVisibleProcesses(true);
            for (const procLayout of Object.values(nodeLayouts)) {
                const nodeEl = procLayout.node;
                if (nodeEl && procLayout.process.ID !== linkStartProcessId &&
                    !nodeEl.classList.contains('filtered-out-general') &&
                    !nodeEl.classList.contains('filtered-out-axis') &&
                    !nodeEl.classList.contains('search-dimmed') &&
                    !nodeEl.classList.contains('tree-highlight-dimmed') &&
                    mouseSvgX >= procLayout.finalX && mouseSvgX <= procLayout.finalX + procLayout.width &&
                    mouseSvgY >= procLayout.finalY && mouseSvgY <= procLayout.finalY + procLayout.height)
                {
                    pendingLinkTargetId = procLayout.process.ID;
                    pendingLinkTargetProcess = visibleProcesses.find(p => p.ID === pendingLinkTargetId);
                    targetProcessNodeElement = nodeEl; 
                    break;
                }
            }
        }


        if (pendingLinkTargetProcess && linkStartProcessId && linkStartProcessSheet) {
            pendingLinkSourceId = linkStartProcessId;
            pendingLinkSourceSheet = linkStartProcessSheet;
            
            const sourceProcDataForCheck = processesData[pendingLinkSourceSheet]?.find(p => p.ID === pendingLinkSourceId);
            if (sourceProcDataForCheck && sourceProcDataForCheck.Dependencies) {
                const depsArray = String(sourceProcDataForCheck.Dependencies).split(';').map(d => d.trim()).filter(d => d);
                const existingDepToBaseId = depsArray.some(depStr => parseDependencyEntry(depStr).id === pendingLinkTargetId);
                if (existingDepToBaseId) {
                    showNotification(`A dependency to process ${pendingLinkTargetProcess["Short name"]} (ID: ${pendingLinkTargetId}) already exists. You can edit its type in the modal or remove and re-add it.`, 'warning');
                    resetPendingLink();
                    return;
                }
            }
            
            showDependencyTypeMenu(e.clientX, e.clientY);
        } else {
            resetPendingLink();
        }
        
        linkStartProcessId = null; 
        linkStartProcessSheet = null;
    });

    toggleMiniMapButton.addEventListener('click', () => {
        const isCurrentlyHidden = miniMapWrapper.style.display === 'none' || miniMapWrapper.style.display === '';
        if (isCurrentlyHidden) {
            miniMapWrapper.style.display = 'block';
            drawMiniMap();
            updateMiniMapViewPort();
        } else {
            miniMapWrapper.style.display = 'none';
            miniMapSvg.innerHTML = '';
        }
        saveStateToLocalStorage();
    });

    closeSimulationPanelButton.addEventListener('click', () => {
        if (isSimulationModeActive) {
            if (confirm("This will end the current simulation. Are you sure?")) { 
                endSimulation();
            }
        } else {
            toggleSimulationPanel(false);
        }
    });

    if (simulationTypeSelectorGroup) {
        simulationTypeSelectorGroup.addEventListener('click', (e) => {
            const button = e.target.closest('.simulation-type-button');
            if (!button) return;

            currentSimulationType = button.dataset.simtype;
            activeSimulationTypeInput.value = currentSimulationType; 

            simulationTypeSelectorGroup.querySelectorAll('.simulation-type-button').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            const simAddInputs = document.getElementById('simulation-add-inputs');
            if (currentSimulationType === 'shift') {
                simulationShiftInputsDiv.style.display = 'block';
                simAddInputs.style.display = 'none';
                if (simulationTargetProcessId) { 
                    const allProcs = getAllProcessesFromData();
                    const targetProcData = allProcs.find(p => p.ID === simulationTargetProcessId && p._sourceSheet === simulationTargetProcessSheet);
                    if (targetProcData) {
                        simulationNewWdInput.value = targetProcData.WD !== undefined ? targetProcData.WD : '';
                        simulationNewDueTimeInput.value = targetProcData["Due time"] || '';
                    }
                }
                undoSimulationParamsButton.style.display = 'inline-block';
            } else if (currentSimulationType === 'add') {
                simulationShiftInputsDiv.style.display = 'none';
                simAddInputs.style.display = 'block';
                const addIdInput = document.getElementById('sim-add-id');
                const addNameInput = document.getElementById('sim-add-short-name');
                if(currentlySelectedProcessId && !isSimulationModeActive) { 
                    const baseProcess = getAllProcessesFromData().find(p => p.ID === currentlySelectedProcessId);
                    if (baseProcess) {
                        addIdInput.value = `SIM_${baseProcess.ID}_${Date.now().toString().slice(-5)}`;
                        addNameInput.value = `Sim: ${baseProcess["Short name"]}`;
                        document.getElementById('sim-add-wd').value = baseProcess.WD || '0';
                        document.getElementById('sim-add-due-time').value = baseProcess["Due time"] || '12:00:00';
                        document.getElementById('sim-add-dependencies').value = ''; 
                        document.getElementById('sim-add-process-type').value = baseProcess["Process Type"] || 'standard';
                    }
                } else { 
                    addIdInput.value = `SIM_NEW_${Date.now().toString().slice(-5)}`;
                    addNameInput.value = 'Simulated New Process';
                    document.getElementById('sim-add-wd').value = '0';
                    document.getElementById('sim-add-due-time').value = '12:00:00';
                    document.getElementById('sim-add-dependencies').value = '';
                    document.getElementById('sim-add-process-type').value = 'standard';
                }
                undoSimulationParamsButton.style.display = 'inline-block';
            } else {
                simulationShiftInputsDiv.style.display = 'none';
                simAddInputs.style.display = 'none';
                undoSimulationParamsButton.style.display = 'none';
            }
        });
    }

    runSimulationButton.addEventListener('click', runOrUpdateSimulation);
    endSimulationButton.addEventListener('click', endSimulation);
    exportSimulationReportButton.addEventListener('click', exportSimulationReport); 
    undoSimulationParamsButton.addEventListener('click', undoSimulationParameters); 
    saveSimulationScenarioButton.addEventListener('click', saveSimulationScenario); 
    loadSimulationScenarioButton.addEventListener('click', loadSelectedSimulationScenario); 

    [simulationNewWdInput, simulationNewDueTimeInput].forEach(input => {
        input.addEventListener('input', () => {
            if (isSimulationModeActive && activeSimulationTypeInput.value === 'shift' && simulationTargetProcessId) {
                const targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${simulationTargetProcessId}"]`);
                if (targetNodeEl && !targetNodeEl.classList.contains('simulation-removed')) {
                    const wdVal = parseInt(simulationNewWdInput.value, 10);
                    let timeValStr = simulationNewDueTimeInput.value.trim();
                    if (timeValStr && timeValStr.includes(':') && timeValStr.split(':').length === 2) timeValStr += ":00";
                    const timeValSec = parseTime(timeValStr);

                    if (!isNaN(wdVal) && (!timeValStr || !isNaN(timeValSec))) {
                        const nodeWidth = targetNodeEl.offsetWidth;
                        const nodeHeight = targetNodeEl.offsetHeight;
                        const wdIndex = gUniqueDataWds.indexOf(wdVal);
                        let idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex !== -1 ? wdIndex * gWdColumnWidth : 0) + (gWdColumnWidth / 2);
                        if (wdIndex === -1) { 
                           if (gUniqueDataWds.length > 0 && wdVal < gUniqueDataWds[0]) idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding - (gWdColumnWidth / 2);
                           else if (gUniqueDataWds.length > 0 && wdVal > gUniqueDataWds[gUniqueDataWds.length -1]) idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (gUniqueDataWds.length * gWdColumnWidth) + (gWdColumnWidth / 2);
                           else idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + ((diagramPane.clientWidth - gYAxisLabelWidthOriginal - PADDING * 2) / 2);
                        }
                        
                        let idealYCenter = PADDING + gPlotHeight / 2;
                        if (!isNaN(timeValSec) && gTimeBins.length > 0) {
                            const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeValSec / gTimeBinSizeSec)));
                            const targetBin = gTimeBins[binIndex];
                            if (targetBin) {
                                const timeWithinBin = timeValSec - targetBin.startSec;
                                const binDuration = targetBin.endSec - targetBin.startSec + 1;
                                idealYCenter = targetBin.yOffset + (binDuration > 0 ? timeWithinBin / binDuration : 0.5) * targetBin.height;
                            }
                        }
                        targetNodeEl.style.left = `${idealXCenter - nodeWidth / 2}px`;
                        targetNodeEl.style.top = `${idealYCenter - nodeHeight / 2}px`;
                    }
                }
            }
        });
    });

    if (shortcutShowDependenciesButton) {
        shortcutShowDependenciesButton.addEventListener('click', () => {
            if (shortcutShowDependenciesButton.disabled) return;
            if (currentlySelectedProcessId) {
                generateAndShowDependencyTree(currentlySelectedProcessId);
                toggleDependencyPanel(true);
                filterPanel.classList.remove('open');
                converterPanel.classList.remove('open');
                tutorialPanel.classList.remove('open');
                menuContent.style.display = 'none';
                sheetMultiSelectDropdown.style.display = 'none';
                deleteViewConfigDropdown.style.display = 'none';
                simulationPanel.classList.remove('open');
            } else {
                showNotification("Please select a process node first to see its dependencies.", "info");
            }
        });
    }

    if (shortcutSimulateImpactButton) {
        shortcutSimulateImpactButton.addEventListener('click', () => {
            if (shortcutSimulateImpactButton.disabled) return;
            openSimulationPanelForSelectedProcess();
        });
    }


    function showNotification(message, type = 'info', duration = 7000) {
        if (notificationTimeout) clearTimeout(notificationTimeout);
        
        const cleanMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        notificationMessageSpan.innerHTML = cleanMessage.replace(/\n/g, "<br>");


        switch (type) {
            case 'error':
                notificationBar.style.backgroundColor = 'var(--bridgestone-red, #DA291C)';
                notificationBar.style.color = 'white';
                break;
            case 'warning':
                notificationBar.style.backgroundColor = '#ffc107'; 
                notificationBar.style.color = '#000';
                break;
            case 'success':
                notificationBar.style.backgroundColor = '#28a745'; 
                notificationBar.style.color = 'white';
                break;
            default: 
                notificationBar.style.backgroundColor = '#333';
                notificationBar.style.color = 'white';
        }

        notificationBar.style.display = 'block';
        updateTopBarHeight(); 

        if (duration > 0) {
            notificationTimeout = setTimeout(() => {
                notificationBar.style.display = 'none';
            }, duration);
        }
    }


    function showDependencyTypeMenu(x, y) {
        dependencyTypeMenu.style.left = `${x}px`;
        dependencyTypeMenu.style.top = `${y}px`;
        dependencyTypeMenu.style.display = 'block';

        dependencyTypeMenu.querySelectorAll('.context-menu-item').forEach(item => {
            item.replaceWith(item.cloneNode(true)); 
        });
        
        dependencyTypeMenu.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', handleDependencyTypeSelection);
        });
    }

    function handleDependencyTypeSelection(event) {
        event.stopPropagation();
        const selectedType = event.target.dataset.type;
        dependencyTypeMenu.style.display = 'none';

        if (pendingLinkSourceId && pendingLinkTargetId && pendingLinkSourceSheet) {
            const sourceProcData = processesData[pendingLinkSourceSheet]?.find(p => p.ID === pendingLinkSourceId);
            if (sourceProcData) {
                let depsArray = sourceProcData.Dependencies ? String(sourceProcData.Dependencies).split(';').map(d => d.trim()).filter(d => d) : [];
                
                let newDependencyEntry = pendingLinkTargetId;
                if (selectedType === 'blocking') {
                    newDependencyEntry += '_B';
                } else if (selectedType === 'informational') {
                    newDependencyEntry += '_I';
                }

                if (!depsArray.includes(newDependencyEntry)) {
                    depsArray.push(newDependencyEntry);
                    sourceProcData.Dependencies = depsArray.join(';');
                    
                    renderDiagramAndRestoreState(); 
                    
                    if (dependencyPanelContainer.classList.contains('visible') && currentDependencyTreeRootProcess && currentDependencyTreeRootProcess.ID === pendingLinkSourceId) {
                        generateAndShowDependencyTree(pendingLinkSourceId);
                    }
                    saveStateToLocalStorage();
                } else {
                    showNotification(`Dependency to ${pendingLinkTargetProcess["Short name"]} with type '${selectedType}' already exists.`, 'warning');
                }
            } else {
                console.warn("Source process data not found for pending link:", pendingLinkSourceId, pendingLinkSourceSheet);
            }
        } else {
            console.warn("Missing data for creating dependency link.");
        }
        resetPendingLink();
    }

    function resetPendingLink() {
        pendingLinkSourceId = null;
        pendingLinkSourceSheet = null;
        pendingLinkTargetId = null;
        pendingLinkTargetProcess = null;
        lastMouseUpEvent = null;
    }

function updateTopBarHeight() {
    const topBarEl = document.querySelector('.top-bar');
    if (topBarEl) {
        topBarHeight = topBarEl.offsetHeight;
        const panelTopPosition = topBarHeight + 10; 
        const panelHeightCalc = `calc(100vh - ${topBarHeight + 20}px)`; 

        if (notificationBar.style.display === 'block') { 
             notificationBar.style.top = (document.body.classList.contains('presentation-mode') ? 0 : topBarHeight) + 'px';
        }


        if (miniMapWrapper.style.display === 'block') {
            miniMapWrapper.style.top = (topBarHeight + 10) + 'px';
        }
        if (document.body.classList.contains('presentation-mode')) {
            diagramContainer.style.paddingTop = topBarHeight + 'px';
        } else {
            diagramContainer.style.paddingTop = '0px';
        }
        
        dependencyPanelContainer.style.top = panelTopPosition + 'px';
        dependencyPanelContainer.style.height = panelHeightCalc;

        [filterPanel, converterPanel, simulationPanel, tutorialPanel].forEach(panelEl => {
            if (panelEl) {
                panelEl.style.top = panelTopPosition + 'px';
                panelEl.style.height = panelHeightCalc;
            }
        });
    } else { 
         if (notificationBar.style.display === 'block') {
             notificationBar.style.top = '0px';
         }
    }
}

    function createNodeElement(processData, layout) { 
        const node = document.createElement('div');
        node.className = 'process-node';
        node.textContent = processData["Short name"];
        node.title = `${processData["Short name"]} (WD: ${processData.WD}, Due: ${processData["Due time"]})`;
        node.dataset.id = processData.ID;
        node.dataset.sourceSheet = processData._sourceSheet || 'N/A';

        const processType = (processData["Process Type"] || "standard").toLowerCase();
        if (processType === "blocking" || processType === "informational") {
            const symbolSpan = document.createElement('span');
            symbolSpan.className = 'node-type-symbol';
            symbolSpan.textContent = processType === "blocking" ? 'B' : 'I';
            symbolSpan.style.color = configColors.nodeSymbolColor || '#333';
            node.appendChild(symbolSpan);
        }

        let baseColorForNode = configColors.node; 
        if (processType === "blocking") {
            baseColorForNode = configColors.blockingNode || '#ffcc80'; 
        } else if (processType === "informational") {
            baseColorForNode = configColors.informationalNode || '#b3e5fc'; 
        }
        node.style.backgroundColor = baseColorForNode;
        node.style.borderColor = shadeColor(baseColorForNode, -0.3);

        node.style.width = `${layout.width || NODE_BASE_WIDTH}px`; 
        node.style.height = `${layout.height || NODE_HEIGHT}px`; 
        
        return node;
    }


    function drawMiniMap() {
        if (miniMapWrapper.style.display === 'none') {
            miniMapSvg.innerHTML = '';
            return;
        }
        miniMapSvg.innerHTML = '';
        const currentProcesses = getCurrentlyVisibleProcesses(true); 
        const allProcsData = isSimulationModeActive ? getAllProcessesFromData() : currentProcesses; 
        
        if (allProcsData.length === 0 || overallDiagramBounds.maxX - overallDiagramBounds.minX <= 0) {
             if(welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }
        if(welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';


        const viewBoxWidth = Math.max(1, overallDiagramBounds.maxX - overallDiagramBounds.minX);
        const viewBoxHeight = Math.max(1, overallDiagramBounds.maxY - overallDiagramBounds.minY);
        miniMapSvg.setAttribute('viewBox', `${overallDiagramBounds.minX} ${overallDiagramBounds.minY} ${viewBoxWidth} ${viewBoxHeight}`);

        allProcsData.forEach(proc => {
            const layout = nodeLayouts[proc.ID]; 
            if (!layout && !(isSimulationModeActive && proc.ID === simulationTargetProcessId && currentSimulationType === 'add')) { 
                 return;
            }


            const nodeEl = diagramPane.querySelector(`.process-node[data-id="${proc.ID}"]`);

            if (!isSimulationModeActive) { 
                if (!nodeEl || nodeEl.classList.contains('filtered-out-general') || nodeEl.classList.contains('filtered-out-axis') || nodeEl.classList.contains('tree-highlight-dimmed') || nodeEl.classList.contains('search-dimmed')) {
                    return;
                }
            } else { 
                 if (nodeEl && nodeEl.classList.contains('simulation-dimmed-others') && proc.ID !== simulationTargetProcessId && !nodeEl.classList.contains('simulation-affected-dependent') && !nodeEl.classList.contains('simulation-input-conflict') && !nodeEl.classList.contains('simulation-output-at-risk') && !nodeEl.classList.contains('simulation-new-node')) {
                    return; 
                }
                if (!nodeEl && proc.ID !== simulationTargetProcessId && (!simulationImpactListContainer || !simulationImpactListContainer.textContent || !simulationImpactListContainer.textContent.includes(proc.ID)) && !(currentSimulationType === 'add' && proc._isSimulatedNew) ) return;
            }


            const rect = document.createElementNS(SVG_NS, 'rect');
            let rectX, rectY, rectWidth, rectHeight;

            if (isSimulationModeActive && proc._isSimulatedNew && currentSimulationType === 'add' && nodeEl) { 
                const nodeRect = nodeEl.getBoundingClientRect();
                const diagramRect = diagramContainer.getBoundingClientRect();
                rectX = (nodeRect.left - diagramRect.left + diagramContainer.scrollLeft) / currentZoom;
                rectY = (nodeRect.top - diagramRect.top + diagramContainer.scrollTop) / currentZoom;
                rectWidth = nodeEl.offsetWidth / currentZoom;
                rectHeight = nodeEl.offsetHeight / currentZoom;
            } else if (layout) {
                rectX = layout.finalX;
                rectY = layout.finalY;
                rectWidth = layout.width;
                rectHeight = layout.height;
                 if (isSimulationModeActive && proc.ID === simulationTargetProcessId && currentSimulationType === 'shift' && nodeEl) {
                    const shiftedNodeRect = nodeEl.getBoundingClientRect();
                    const diagramRect = diagramContainer.getBoundingClientRect();
                    rectX = (shiftedNodeRect.left - diagramRect.left + diagramContainer.scrollLeft) / currentZoom;
                    rectY = (shiftedNodeRect.top - diagramRect.top + diagramContainer.scrollTop) / currentZoom;
                }
            } else {
                return; 
            }


            rect.setAttribute('x', rectX);
            rect.setAttribute('y', rectY);
            rect.setAttribute('width', rectWidth);
            rect.setAttribute('height', rectHeight);
            rect.classList.add('mini-map-node');

            if (isSimulationModeActive) {
                if (proc.ID === simulationTargetProcessId) {
                    rect.style.fill = 'gold'; 
                    if (currentSimulationType === 'add') rect.style.fill = '#17a2b8'; 
                    rect.style.stroke = 'black';
                    rect.style.strokeWidth = "1.5px";
                } else if (nodeEl && (nodeEl.classList.contains('simulation-affected-dependent') || nodeEl.classList.contains('simulation-input-conflict') || nodeEl.classList.contains('simulation-output-at-risk'))) {
                    rect.style.fill = 'orange';
                } else {
                     rect.style.fill = (proc._sheetColorIndex !== undefined) ? sheetColors[proc._sheetColorIndex % sheetColors.length] : configColors.node;
                     rect.style.opacity = 0.5;
                }
            } else {
                if (proc && proc._sheetColorIndex !== undefined && allDataSourceSheetNames.length > 1) {
                    rect.style.fill = sheetColors[proc._sheetColorIndex % sheetColors.length];
                } else {
                    rect.style.fill = configColors.node;
                }
                if(proc.ID === currentlySelectedProcessId){
                    rect.style.stroke = configColors.lightning;
                    rect.style.strokeWidth = "3px";
                }
            }
            miniMapSvg.appendChild(rect);
        });

        if (miniMapViewportRect && miniMapViewportRect.parentNode) {
            miniMapViewportRect.parentNode.removeChild(miniMapViewportRect);
        }
        miniMapViewportRect = document.createElementNS(SVG_NS, 'rect');
        miniMapViewportRect.setAttribute('id', 'mini-map-viewport-rect');
        miniMapSvg.appendChild(miniMapViewportRect);
    }

    function updateMiniMapViewPort() {
        if (miniMapWrapper.style.display === 'none') {
            return;
        }
        if (!miniMapViewportRect || getCurrentlyVisibleProcesses().length === 0 && !isSimulationModeActive || overallDiagramBounds.maxX - overallDiagramBounds.minX <= 0) {
            if (miniMapViewportRect) {
                miniMapViewportRect.setAttribute('width', '0');
                miniMapViewportRect.setAttribute('height', '0');
            }
            return;
        }

        const diagramVisibleWidth = diagramContainer.clientWidth / currentZoom;
        const diagramVisibleHeight = diagramContainer.clientHeight / currentZoom;
        const diagramScrollLeft = diagramContainer.scrollLeft / currentZoom;
        const diagramScrollTop = diagramContainer.scrollTop / currentZoom;

        miniMapViewportRect.setAttribute('x', diagramScrollLeft);
        miniMapViewportRect.setAttribute('y', diagramScrollTop);
        miniMapViewportRect.setAttribute('width', Math.max(0, diagramVisibleWidth));
        miniMapViewportRect.setAttribute('height', Math.max(0, diagramVisibleHeight));
    }

function clearSelectionHighlightsAndDimming() {
    if (isSimulationModeActive) return;
    svgLayer.innerHTML = '';
    simulationGhostLayer.innerHTML = '';
    const currentProcsForClear = getAllProcessesFromData(); 

    diagramPane.querySelectorAll('.process-node').forEach(node => {
        const procId = node.dataset.id;
        const nodeSheet = node.dataset.sourceSheet; 
        const procData = currentProcsForClear.find(p => p.ID === procId && p._sourceSheet === nodeSheet);

        node.classList.remove('selected', 'dependent-input', 'dependent-output', 'dimmed-selection');

        if (isTreeHighlightActive && node.classList.contains('tree-highlight-dimmed') && procId !== currentlySelectedProcessId) {
            node.classList.remove('can-hover'); 
            return; 
        }

        if ((!node.classList.contains('filtered-out-general') &&
            !node.classList.contains('filtered-out-axis') &&
            !node.classList.contains('search-dimmed')) ||
            node.classList.contains('search-highlight'))
        {
            if (!node.classList.contains('search-highlight')) {
                let colorToRestore = configColors.node; 
                if (procData) { 
                    const processType = (procData["Process Type"] || "standard").toLowerCase();
                    if (processType === "blocking") {
                        colorToRestore = configColors.blockingNode;
                    } else if (processType === "informational") {
                        colorToRestore = configColors.informationalNode;
                    }
                }
                node.style.backgroundColor = colorToRestore;
                node.style.borderColor = shadeColor(colorToRestore, -0.3);
            } else {
                node.style.borderColor = '#ff8c00'; 
            }

            node.style.boxShadow = '1px 1px 3px rgba(0,0,0,0.1)';
            node.style.opacity = 1;
            node.classList.add('can-hover');
        } else {
            node.classList.remove('can-hover');
        }
    });
    hideActionIcons(); 
    updateAllDependencyAndSimShortcutButtonsState();
}


    function resetVisualStates() {
        if (isSimulationModeActive) return; 
        clearSelectionHighlightsAndDimming();
        currentlySelectedProcessId = null;
        displayProcessDetails(null); 
        hideActionIcons();
        updateAllDependencyAndSimShortcutButtonsState();
    }

function fullReset() {
    if (isSimulationModeActive) endSimulation();
    temporaryActiveFilters = {};
    currentAppliedFilters = {};
    currentAxisFilter = { type: null, value: null, valueEnd: null };
    isTreeHighlightActive = false;
    highlightedTreeNodesIds.clear();
    currentProcessTypeView = "All";
    processTypeViewSelector.value = "All";

    if (allDataSourceSheetNames.length > 0) {
        selectedSheetViews = [...allDataSourceSheetNames];
    } else {
        selectedSheetViews = [];
    }
    updateSheetMultiSelectDropdown();

    if (filterOptionsContainer) {
        filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(input => {
            if (input.tagName === 'SELECT' && input.multiple) {
                Array.from(input.options).forEach(option => option.selected = false);
            } else {
                input.value = "";
            }
        });
    }
    searchInput.value = '';

    resetVisualStates();
    updateAddProcessButtonState();

    renderDiagram(); 

    refreshDiagramStyles();

    requestAnimationFrame(() => {
        updateTopBarHeight();
        if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
        if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
        updateStickyAxesContainerPositions();
        updateStickyAxesLabels();
        drawMiniMap(); updateMiniMapViewPort();
        positionActionIcons();
    });
    updateAllDependencyAndSimShortcutButtonsState();
}


    function handleProcessNodeClick(processId) {
        if (isSimulationModeActive) {
             const clickedNodeEl = diagramPane.querySelector(`.process-node[data-id="${processId}"]`);
             if (clickedNodeEl && (clickedNodeEl.classList.contains('simulation-affected-dependent') || clickedNodeEl.classList.contains('simulation-input-conflict') || clickedNodeEl.classList.contains('simulation-output-at-risk'))) {
                 showNotification(`Clicked impacted node: ${processId}.`, 'info', 3000);
             }
            return;
        }

        if (isTreeHighlightActive) {
            if (highlightedTreeNodesIds.has(processId)) {
                if (currentlySelectedProcessId === processId) {
                    clearSelectionHighlightsAndDimming(); 
                    currentlySelectedProcessId = null;
                    displayProcessDetails(null);
                    hideActionIcons(); 
                    refreshDiagramStyles(); 
                } else {
                    selectProcess(processId, true); 
                }
            } else { 
                isTreeHighlightActive = false;
                highlightedTreeNodesIds.clear();
                selectProcess(processId, true); 
            }
        } else { 
            if (currentlySelectedProcessId === processId) { 
                clearSelectionHighlightsAndDimming();
                currentlySelectedProcessId = null;
                displayProcessDetails(null);
                hideActionIcons();
                toggleDependencyPanel(false); 
            } else { 
                selectProcess(processId, true); 
                if (dependencyPanelContainer.classList.contains('visible')) {
                    generateAndShowDependencyTree(processId);
                }
            }
        }
        updateAllDependencyAndSimShortcutButtonsState();
    }
    
    function updateAllDependencyAndSimShortcutButtonsState() {
        const isProcessSelected = !!currentlySelectedProcessId;
        const enableActionOnSelectedProcess = isProcessSelected && !isSimulationModeActive && !dependencyEditingEnabled;

        if (shortcutShowDependenciesButton) {
            shortcutShowDependenciesButton.disabled = !enableActionOnSelectedProcess;
        }
        if (shortcutSimulateImpactButton) {
            shortcutSimulateImpactButton.disabled = !enableActionOnSelectedProcess;
        }

        if (menuDependencyPanelTrigger) {
            menuDependencyPanelTrigger.disabled = !enableActionOnSelectedProcess;
            if (menuDependencyPanelTrigger.disabled) {
                menuDependencyPanelTrigger.classList.add('disabled');
            } else {
                menuDependencyPanelTrigger.classList.remove('disabled');
            }
        }
    }


    function positionActionIcons() {
        if (linkHandleTrigger) linkHandleTrigger.style.display = 'none';
        diagramPane.querySelectorAll('.unlink-handle').forEach(handle => handle.remove());

        if (document.body.classList.contains('presentation-mode') || isSimulationModeActive) return;
        if (!currentlySelectedProcessId) return; 

        const sourceLayout = nodeLayouts[currentlySelectedProcessId];
        if (!sourceLayout) return; 
        
        const sourceNodeEl = sourceLayout.node;
        if (!sourceNodeEl || sourceNodeEl.classList.contains('filtered-out-general') || sourceNodeEl.classList.contains('filtered-out-axis') || sourceNodeEl.classList.contains('search-dimmed') || (isTreeHighlightActive && sourceNodeEl.classList.contains('tree-highlight-dimmed'))) {
            return;
        }

        if (dependencyEditingEnabled) { 
            const iconSizeScale = 1 / currentZoom;
            const linkHandleSize = 14;

            if (linkHandleTrigger) {
                linkHandleTrigger.style.left = `${sourceLayout.finalX + sourceLayout.width - (linkHandleSize * iconSizeScale / 2)}px`;
                linkHandleTrigger.style.top = `${sourceLayout.finalY + sourceLayout.height / 2 - (linkHandleSize * iconSizeScale / 2)}px`;
                linkHandleTrigger.style.transform = `scale(${iconSizeScale})`;
                linkHandleTrigger.style.display = 'flex';
            }

            const selectedProcessData = getCurrentlyVisibleProcesses(true).find(p => p.ID === currentlySelectedProcessId);
            if (selectedProcessData && selectedProcessData.Dependencies && String(selectedProcessData.Dependencies).trim() !== '') {
                const dependentRawEntries = String(selectedProcessData.Dependencies).split(';').map(entry => entry.trim()).filter(entry => entry);
                dependentRawEntries.forEach(rawDepEntry => {
                    const { id: depId } = parseDependencyEntry(rawDepEntry);
                    if (depId === currentlySelectedProcessId) return;

                    const dependentLayout = nodeLayouts[depId];
                    const dependentNodeEl = dependentLayout ? dependentLayout.node : null;

                    if (dependentLayout && dependentNodeEl &&
                        !dependentNodeEl.classList.contains('filtered-out-general') &&
                        !dependentNodeEl.classList.contains('filtered-out-axis') &&
                        !dependentNodeEl.classList.contains('search-dimmed') &&
                        !(isTreeHighlightActive && !highlightedTreeNodesIds.has(depId)) ) {

                        const unlinkHandle = document.createElement('div');
                        unlinkHandle.className = 'unlink-handle';
                        unlinkHandle.textContent = '–';
                        unlinkHandle.title = `Remove dependency to ${dependentLayout.process["Short name"] || depId}`;
                        unlinkHandle.dataset.sourceId = currentlySelectedProcessId;
                        unlinkHandle.dataset.targetRawDep = rawDepEntry;
                        unlinkHandle.dataset.sourceSheet = selectedProcessData._sourceSheet || (selectedSheetViews.length === 1 ? selectedSheetViews[0] : null);

                        unlinkHandle.style.left = `${dependentLayout.finalX + dependentLayout.width - (linkHandleSize * iconSizeScale / 2) - 2}px`;
                        unlinkHandle.style.top = `${dependentLayout.finalY - (linkHandleSize * iconSizeScale / 2) + 2}px`;
                        unlinkHandle.style.transform = `scale(${iconSizeScale})`;
                        unlinkHandle.style.display = 'flex';
                        diagramPane.appendChild(unlinkHandle);
                    }
                });
            }
        }
    }

    function hideActionIcons() {
        if(linkHandleTrigger) linkHandleTrigger.style.display = 'none';
        diagramPane.querySelectorAll('.unlink-handle').forEach(handle => handle.remove());
    }


    function toggleDependencyPanel(show) {
        if (show) {
            if (isSimulationModeActive) endSimulation();
            dependencyPanelContainer.style.display = 'flex'; 
            dependencyPanelContainer.classList.add('visible'); 
            requestAnimationFrame(() => {
                dependencyPanelContainer.style.right = '0';
            });
        } else {
            dependencyPanelContainer.classList.remove('visible');
            requestAnimationFrame(() => {
                const panelWidth = dependencyPanelContainer.offsetWidth || dependencyPanelContainer.clientWidth || 500;
                dependencyPanelContainer.style.right = `-${panelWidth}px`;
                setTimeout(() => {
                    if (!dependencyPanelContainer.classList.contains('visible')) {
                        dependencyPanelContainer.style.display = 'none';
                    }
                }, 350); 
            });
        }
    }

    function toggleSimulationPanel(show) {
        if (show) {
            if (isTreeHighlightActive) { 
                 isTreeHighlightActive = false;
                 highlightedTreeNodesIds.clear();
                 renderDiagramAndRestoreState(); 
            }
            simulationPanel.classList.add('open');
            simulationPanel.style.right = '0';
        } else {
            simulationPanel.classList.remove('open');
            simulationPanel.style.right = `-${simulationPanel.offsetWidth}px`;
        }
    }


    function highlightTreeNodesOnDiagram() {
        if (isSimulationModeActive) endSimulation();

        const treeNodesElements = dependencyTreeSvg.querySelectorAll('.dep-tree-node');
        if (treeNodesElements.length === 0) {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            renderDiagramAndRestoreState(); 
            toggleDependencyPanel(false);
            return;
        }

        const newHighlightedTreeIds = new Set();
        treeNodesElements.forEach(g => {
            if (g.dataset.id) {
                newHighlightedTreeIds.add(g.dataset.id);
            }
        });

        if (newHighlightedTreeIds.size === 0) {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            renderDiagramAndRestoreState();
            toggleDependencyPanel(false);
            return;
        }

        isTreeHighlightActive = true;
        highlightedTreeNodesIds = newHighlightedTreeIds;

        if (currentlySelectedProcessId && !highlightedTreeNodesIds.has(currentlySelectedProcessId)) {
            currentlySelectedProcessId = null; 
            displayProcessDetails(null);
        }

        currentAppliedFilters = {};
        temporaryActiveFilters = {};
        currentAxisFilter = { type: null, value: null, valueEnd: null };
        if (searchInput) searchInput.value = '';

        if (filterOptionsContainer) {
            filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(input => {
                if (input.tagName === 'SELECT' && input.multiple) {
                    Array.from(input.options).forEach(option => option.selected = false);
                } else {
                    input.value = "";
                }
            });
        }
        updateStickyAxesLabels();
        renderDiagramAndRestoreState(); 
        toggleDependencyPanel(false);
        saveStateToLocalStorage();
    }

    function drawAllTreeDependencies() {
        if (!isTreeHighlightActive || highlightedTreeNodesIds.size === 0) {
            return;
        }
        const currentVisibleProcesses = getCurrentlyVisibleProcesses(true); 
        let arrowsDrawnCount = 0;

        highlightedTreeNodesIds.forEach(sourceId => {
            const sourceProcess = currentVisibleProcesses.find(p => p.ID === sourceId);
            const sourceNodeEl = diagramPane.querySelector(`.process-node[data-id="${sourceId}"]:not(.tree-highlight-dimmed)`);

            if (!sourceProcess || !sourceNodeEl) return; 

            const outputRawEntries = (sourceProcess.Dependencies ? String(sourceProcess.Dependencies) : '').split(';').map(id => id.trim()).filter(id => id);

            outputRawEntries.forEach(rawDepEntry => {
                const { id: targetId, type: depLinkType } = parseDependencyEntry(rawDepEntry);

                if (highlightedTreeNodesIds.has(targetId) && targetId !== sourceId) {
                    const targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${targetId}"]:not(.tree-highlight-dimmed)`);
                    const targetProcess = currentVisibleProcesses.find(p => p.ID === targetId); 

                    if (!targetProcess || !targetNodeEl) return;

                    let arrowColor = configColors.outputArrow;
                    if (depLinkType === 'blocking') arrowColor = configColors.outputArrowBlocking;
                    else if (depLinkType === 'informational') arrowColor = configColors.outputArrowInformational;
                    
                    drawArrow(sourceNodeEl, targetNodeEl, arrowColor, 'output-arrow tree-arrow', depLinkType);
                    arrowsDrawnCount++;
                }
            });
        });
    }

    function highlightDependenciesWithinTree(selectedProcess, allowedNodeIds) {
        if (!isTreeHighlightActive) return;
    }

    function highlightTreePath(event, doHighlight) {
        dependencyTreeSvg.querySelectorAll('.dep-tree-node.path-highlight, .dep-tree-link.path-highlight')
            .forEach(el => el.classList.remove('path-highlight'));

        if (!doHighlight || !event || !event.currentTarget) return;

        const targetNodeElement = event.currentTarget;
        let targetNodeId = targetNodeElement.dataset.id;

        const pathNodeIds = new Set();
        let currentNodeId = targetNodeId;

        while (currentNodeId) {
            pathNodeIds.add(currentNodeId);
            const nodeInfo = dependencyTreeNodeMap.get(currentNodeId); 

            if (nodeInfo && nodeInfo.parentId) {
                const parentId = nodeInfo.parentId;
                const linkForward = dependencyTreeSvg.querySelector(`.link-from-${parentId}-to-${currentNodeId}`);
                const linkBackward = dependencyTreeSvg.querySelector(`.link-from-${currentNodeId}-to-${parentId}`); 
                if(linkForward) linkForward.classList.add('path-highlight');
                if(linkBackward) linkBackward.classList.add('path-highlight');
                currentNodeId = parentId;
            } else {
                currentNodeId = null;
            }
        }

        pathNodeIds.forEach(id => {
            const nodeEl = dependencyTreeSvg.querySelector(`.dep-tree-node[data-id="${id}"]`);
            if (nodeEl) nodeEl.classList.add('path-highlight');
        });
    }


    function drawDependencyTreeSVG(rootProcessData, inputsData, outputsData) {
        dependencyTreeSvg.innerHTML = '';
        dependencyTreeNodeMap.clear(); 

        const nodeWidth = 120; 
        const nodeHeight = 30;
        const horizontalGap = 70;
        const verticalGap = 20;
        const padding = 20;
        const toggleRadius = 5;

        let nodesToDraw = [];
        let linksToDraw = [];

        nodesToDraw.push({
            id: rootProcessData.ID,
            name: rootProcessData["Short name"],
            level: 0,
            isRoot: true,
            _sourceData: rootProcessData 
        });

        function layoutTree(dataArray, parentNodeData, isInputBranch) {
            if (!dataArray || dataArray.length === 0) return;

            dataArray.forEach(childData => {
                nodesToDraw.push({
                    id: childData.id,
                    name: childData.name,
                    level: childData.level,
                    notInView: childData.notInView,
                    isCollapsed: childData.isCollapsed,
                    hasChildren: childData.hasChildren,
                    parentId: parentNodeData.id, 
                    _sourceData: childData 
                });
                linksToDraw.push({
                    sourceId: isInputBranch ? childData.id : parentNodeData.id,
                    targetId: isInputBranch ? parentNodeData.id : childData.id,
                    sourceLevel: isInputBranch ? childData.level : parentNodeData.level,
                    targetLevel: isInputBranch ? parentNodeData.level : childData.level,
                });
                if (childData.children && childData.children.length > 0 && !childData.isCollapsed) {
                    layoutTree(childData.children, childData, isInputBranch); 
                }
            });
        }

        layoutTree(inputsData, rootProcessData, true);
        layoutTree(outputsData, rootProcessData, false);

        const rootNodeInDrawList = nodesToDraw.find(n => n.isRoot);
        if(rootNodeInDrawList) rootNodeInDrawList.parentId = null;


        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        const nodesByLevel = {};

        nodesToDraw.forEach(n => {
            if (!nodesByLevel[n.level]) nodesByLevel[n.level] = [];
            nodesByLevel[n.level].push(n);
            n.x = n.level * (nodeWidth + horizontalGap);
            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x + nodeWidth);
        });

        let totalCalculatedHeight = padding;
        const levelHeights = {};
        const sortedLevels = Object.keys(nodesByLevel).map(Number).sort((a, b) => a - b);

        sortedLevels.forEach(level => {
            levelHeights[level] = nodesByLevel[level].length * (nodeHeight + verticalGap) - verticalGap;
            totalCalculatedHeight += levelHeights[level] + (nodesByLevel[level].length > 0 ? verticalGap : 0) ;
        });
        totalCalculatedHeight = Math.max(totalCalculatedHeight - verticalGap, padding + nodeHeight + padding);


        let currentY = padding;
        sortedLevels.forEach(level => {
            const nodesOnLevel = nodesByLevel[level];
            if (nodesOnLevel.length === 0) return;

            const levelHeight = levelHeights[level];
            const startYForLevel = currentY;
            nodesOnLevel.forEach((node, index) => {
                node.y = startYForLevel + index * (nodeHeight + verticalGap);
            });
            currentY += levelHeight + verticalGap;
        });

        minX = Infinity; maxX = -Infinity;
        nodesToDraw.forEach(n => {
            const panelContentWidth = dependencyTreeContent.clientWidth > 0 ? dependencyTreeContent.clientWidth : 400;
            const rootBaseX = panelContentWidth / 2 - nodeWidth / 2;
            n.x = rootBaseX + n.level * (nodeWidth + horizontalGap);

            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x + nodeWidth);
            minY = Math.min(minY, n.y);
            maxY = Math.max(maxY, n.y + nodeHeight);
        });

        const graphWidth = maxX - minX;
        const panelWidth = dependencyTreeContent.clientWidth || 400;
        const finalSvgWidth = Math.max(panelWidth, graphWidth + 2 * padding);
        const finalSvgHeight = Math.max(dependencyTreeContent.clientHeight || 300, maxY + padding);


        const xOffset = (finalSvgWidth - graphWidth) / 2 - minX;

        nodesToDraw.forEach(node => {
            node.x += xOffset;
            dependencyTreeNodeMap.set(node.id, node);
        });


        dependencyTreeSvg.setAttribute('width', finalSvgWidth);
        dependencyTreeSvg.setAttribute('height', finalSvgHeight);


        let defs = dependencyTreeSvg.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS(SVG_NS, 'defs');
            dependencyTreeSvg.insertBefore(defs, dependencyTreeSvg.firstChild);
        }
        if (!defs.querySelector('#dep-arrowhead')) {
            const marker = document.createElementNS(SVG_NS, 'marker');
            marker.setAttribute('id', 'dep-arrowhead');
            marker.setAttribute('viewBox', '0 -5 10 10'); marker.setAttribute('refX', '8');
            marker.setAttribute('refY', '0'); marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6'); marker.setAttribute('orient', 'auto');
            const path = document.createElementNS(SVG_NS, 'path');
            path.setAttribute('d', 'M0,-5L10,0L0,5'); path.style.fill = '#888';
            marker.appendChild(path); defs.appendChild(marker);
        }

        linksToDraw.forEach(link => {
            const sourceNode = nodesToDraw.find(n => n.id === link.sourceId && n.level === link.sourceLevel);
            const targetNode = nodesToDraw.find(n => n.id === link.targetId && n.level === link.targetLevel);

            if (sourceNode && targetNode) {
                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', sourceNode.x + nodeWidth / 2);
                line.setAttribute('y1', sourceNode.y + nodeHeight / 2);
                line.setAttribute('x2', targetNode.x + nodeWidth / 2);
                line.setAttribute('y2', targetNode.y + nodeHeight / 2);
                line.classList.add('dep-tree-link');
                line.classList.add(`link-from-${sourceNode.id}-to-${targetNode.id}`);
                line.setAttribute('marker-end', 'url(#dep-arrowhead)');
                dependencyTreeSvg.appendChild(line);
            }
        });

        const currentDiagramProcesses = getCurrentlyVisibleProcesses(false);
        const diagramProcessIds = new Set(currentDiagramProcesses.map(p => p.ID));

        nodesToDraw.forEach(node => {
            const group = document.createElementNS(SVG_NS, 'g');
            group.setAttribute('class', 'dep-tree-node');
            group.dataset.id = node.id;
            group.setAttribute('transform', `translate(${node.x}, ${node.y})`);


            if (node.isRoot) group.classList.add('selected-root');
            if (node.notInView) group.classList.add('not-in-view');

            if (diagramProcessIds.has(node.id) && !node.notInView) {
                group.classList.add('clickable');
                group.addEventListener('click', () => {
                    if (isSimulationModeActive) return; 
                    selectProcess(node.id, true);
                    const mainNodeLayout = nodeLayouts[node.id];
                    if (mainNodeLayout) {
                        const targetX = (mainNodeLayout.finalX + mainNodeLayout.width / 2) * currentZoom - diagramContainer.clientWidth / 2;
                        const targetY = (mainNodeLayout.finalY + mainNodeLayout.height / 2) * currentZoom - diagramContainer.clientHeight / 2;
                        diagramContainer.scrollTo({left: Math.max(0, targetX), top: Math.max(0, targetY), behavior: 'smooth'});
                    }
                });
            }
            group.addEventListener('mouseover', (e) => highlightTreePath(e, true));
            group.addEventListener('mouseout', (e) => highlightTreePath(e, false));


            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', 0); rect.setAttribute('y', 0);
            rect.setAttribute('width', nodeWidth); rect.setAttribute('height', nodeHeight);

            const text = document.createElementNS(SVG_NS, 'text');
            text.setAttribute('x', nodeWidth / 2);
            text.setAttribute('y', nodeHeight / 2);

            let displayName = node.name || `ID: ${node.id}`;
            const depthIndicator = ` (L${Math.abs(node.level)})`;
            displayName += depthIndicator;

            const approxCharWidth = 5;
            const maxChars = Math.floor((nodeWidth - (node.hasChildren ? 25 : 10)) / approxCharWidth);
            if (displayName.length > maxChars) {
                 displayName = displayName.substring(0, maxChars - 3) + "..." + depthIndicator;
            }
            text.textContent = displayName;
            if(node.notInView) text.textContent += " (NV)";

            group.appendChild(rect);
            group.appendChild(text);

            if (node.hasChildren) {
                const toggleText = document.createElementNS(SVG_NS, 'text');
                toggleText.setAttribute('class', 'toggle-text');
                toggleText.textContent = node.isCollapsed ? '[+]' : '[-]';
                toggleText.setAttribute('x', 5);
                toggleText.setAttribute('y', nodeHeight / 2);
                toggleText.style.dominantBaseline = "middle";

                toggleText.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (node._sourceData) {
                        node._sourceData.isCollapsed = !node._sourceData.isCollapsed;
                        drawDependencyTreeSVG(currentDependencyTreeRootProcess, currentTreeInputsData, currentTreeOutputsData);
                    }
                });
                group.appendChild(toggleText);
            }
            dependencyTreeSvg.appendChild(group);
        });
    }


    updateTopBarHeight();

    const toggleDarkModeButton = document.getElementById('toggle-dark-mode-button');
    const DARK_MODE_STORAGE_KEY = 'diagramDarkMode_V23';

    function updateButtonStylesForDarkMode(isDarkModeActive) {
        const filtersButton = document.getElementById('toggle-filter-panel-button');
        const miniMapButton = document.getElementById('toggle-mini-map-button');
        const loadJsonLabel = document.getElementById('json-file-input-label');

        if (isDarkModeActive) {
            if (filtersButton) { 
                filtersButton.style.setProperty('background-color', '#333', 'important'); 
                filtersButton.style.setProperty('color', '#e0e0e0', 'important'); 
                filtersButton.style.setProperty('border', '1px solid #555', 'important'); 
            }
            if (miniMapButton) { 
                miniMapButton.style.setProperty('background-color', '#333', 'important'); 
                miniMapButton.style.setProperty('color', '#e0e0e0', 'important'); 
                miniMapButton.style.setProperty('border', '1px solid #555', 'important'); 
            }
            if (loadJsonLabel) { 
                loadJsonLabel.style.setProperty('background-color', '#555', 'important'); 
                loadJsonLabel.style.setProperty('color', '#e0e0e0', 'important'); 
                loadJsonLabel.style.setProperty('border', '1px solid #777', 'important'); 
            }
        } else {
            if (filtersButton) { filtersButton.style.backgroundColor = ''; filtersButton.style.color = ''; filtersButton.style.border = ''; }
            if (miniMapButton) { miniMapButton.style.backgroundColor = ''; miniMapButton.style.color = ''; miniMapButton.style.border = ''; }
            if (loadJsonLabel) { loadJsonLabel.style.backgroundColor = ''; loadJsonLabel.style.color = ''; loadJsonLabel.style.border = ''; }
        }
    }

    if (toggleDarkModeButton) {
        const currentDarkModeState = localStorage.getItem(DARK_MODE_STORAGE_KEY);
        const isInitiallyDarkMode = currentDarkModeState === 'enabled';

        if (isInitiallyDarkMode) {
            document.body.classList.add('dark-mode');
            toggleDarkModeButton.textContent = 'Light Theme';
        } else {
            document.body.classList.remove('dark-mode'); 
            toggleDarkModeButton.textContent = 'Dark Theme';
        }
        setTimeout(() => updateButtonStylesForDarkMode(isInitiallyDarkMode), 0);

        toggleDarkModeButton.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            const isNowDarkMode = document.body.classList.contains('dark-mode');
            if (isNowDarkMode) {
                toggleDarkModeButton.textContent = 'Light Theme';
                localStorage.setItem(DARK_MODE_STORAGE_KEY, 'enabled');
            } else {
                toggleDarkModeButton.textContent = 'Dark Theme';
                localStorage.setItem(DARK_MODE_STORAGE_KEY, 'disabled');
            }
            setTimeout(() => updateButtonStylesForDarkMode(isNowDarkMode), 0);
            
            refreshDiagramStyles(); 
            updateStickyAxesContainerPositions(); 
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
        });
    }
    
    const stateLoaded = loadStateFromLocalStorage();
    if (!stateLoaded) {
        updateSheetMultiSelectDropdown();
        processTypeViewSelector.value = "All";
        if (Object.keys(processesData).length === 0) {
            displayProcessDetails(null); 
            if(filterOptionsContainer) filterOptionsContainer.innerHTML = '<p>Load data to see filter options.</p>';
            if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
            if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
            miniMapSvg.innerHTML = '';
            miniMapWrapper.style.display = 'none';
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        }
        if (visualControlsContainer) {
            visualControlsContainer.style.display = 'none';
            toggleColorsButton.textContent = 'Colours 🎨 (Show)';
        }
        dependencyEditingEnabled = false; 
        updateDependencyEditButtonText();
    } else {
         if (Object.keys(processesData).length === 0 || getCurrentlyVisibleProcesses().length === 0) {
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        } else {
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
        }
    }
    initializeColorPickers();
    populateViewConfigSelector();
    initSimulationPanelUI();
    displayProcessDetails(null); 
    updateAllDependencyAndSimShortcutButtonsState();

    function updateDependencyEditButtonText() {
        if (dependencyEditingEnabled) {
            toggleDependencyEditButton.textContent = 'Disable Dependency Editing';
            toggleDependencyEditButton.title = 'Currently Enabled: Click to disable manual dependency editing.';
        } else {
            toggleDependencyEditButton.textContent = 'Enable Dependency Editing';
            toggleDependencyEditButton.title = 'Currently Disabled: Click to enable manual dependency editing.';
        }
    }

    function saveStateToLocalStorage() {
        if (typeof Storage !== "undefined") {
            try {
                const state = {
                    processesData: processesData,
                    selectedSheetViews: selectedSheetViews,
                    allDataSourceSheetNames: allDataSourceSheetNames,
                    currentProcessTypeView: currentProcessTypeView,
                    currentZoom: currentZoom,
                    scrollTop: diagramContainer.scrollTop,
                    scrollLeft: diagramContainer.scrollLeft,
                    currentAppliedFilters: currentAppliedFilters,
                    currentAxisFilter: currentAxisFilter,
                    configColors: configColors,
                    jsonFileName: jsonFileNameSpan.textContent,
                    isMiniMapVisible: miniMapWrapper.style.display === 'block',
                    isTreeHighlightActive: isTreeHighlightActive,
                    highlightedTreeNodesIds: Array.from(highlightedTreeNodesIds),
                    isColorsPanelVisible: visualControlsContainer ? visualControlsContainer.style.display === 'flex' : false,
                    dependencyEditingEnabled: dependencyEditingEnabled 
                };
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                console.error("Error saving state to LocalStorage:", e);
                showNotification("Error saving state to LocalStorage. Some settings might not persist.", 'error');
            }
        }
    }

    function loadStateFromLocalStorage() {
        if (typeof Storage !== "undefined") {
            const savedStateJSON = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedStateJSON) {
                try {
                    const savedState = JSON.parse(savedStateJSON);
                    processesData = savedState.processesData || {};
                    selectedSheetViews = Array.isArray(savedState.selectedSheetViews) ? savedState.selectedSheetViews : [];
                    allDataSourceSheetNames = Array.isArray(savedState.allDataSourceSheetNames) ? savedState.allDataSourceSheetNames : [];
                    currentProcessTypeView = savedState.currentProcessTypeView || "All";

                    currentZoom = savedState.currentZoom || 1;
                    currentAppliedFilters = savedState.currentAppliedFilters || {};
                    temporaryActiveFilters = { ...currentAppliedFilters };
                    currentAxisFilter = savedState.currentAxisFilter || { type: null, value: null, valueEnd: null };

    const initialDefaultColors = {
        node: '#aedff7', 
        blockingNode: '#ffcc80', 
        informationalNode: '#b3e5fc', 
        lightning: '#00ff00',
        inputProcess: '#90ee90',
        outputProcess: '#ffb6c1',
        inputArrow: '#50c878',
        outputArrow: '#ff7f7f',
        inputArrowBlocking: '#FF0000',
        outputArrowBlocking: '#FF0000',
        inputArrowInformational: '#0000FF',
        outputArrowInformational: '#0000FF',
        nodeSymbolColor: '#333333'
    };
configColors = { ...initialDefaultColors, ...(savedState.configColors || {}) };


                    jsonFileNameSpan.textContent = savedState.jsonFileName || '';
                    isTreeHighlightActive = savedState.isTreeHighlightActive || false;
                    highlightedTreeNodesIds = new Set(savedState.highlightedTreeNodesIds || []);
                    dependencyEditingEnabled = savedState.dependencyEditingEnabled === true; 
                    updateDependencyEditButtonText();


                    if (visualControlsContainer) {
                        if (savedState.isColorsPanelVisible) {
                            visualControlsContainer.style.display = 'flex';
                            toggleColorsButton.textContent = 'Colours 🎨 (Hide)';
                        } else {
                            visualControlsContainer.style.display = 'none';
                            toggleColorsButton.textContent = 'Colours 🎨 (Show)';
                        }
                    }


                    Object.keys(configColors).forEach(key => {
                        const pickerId = key.replace(/([A-Z])/g, '-$1').toLowerCase() + '-color';
                        const picker = document.getElementById(pickerId);
                        if (picker) picker.value = configColors[key];
                    });

                    updateSheetMultiSelectDropdown();
                    processTypeViewSelector.value = currentProcessTypeView;

                    updateAddProcessButtonState();

                    if (selectedSheetViews.length > 0 && getCurrentlyVisibleProcesses().length > 0) {
                        updateGlobalUniqueDueTimeHours();
                        populateFilterPanel();

                        filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(inputEl => {
                            const filterKey = inputEl.dataset.filterKey;
                            if (currentAppliedFilters[filterKey]) {
                                 if (inputEl.tagName === 'SELECT' && inputEl.multiple) {
                                    const values = Array.isArray(currentAppliedFilters[filterKey]) ? currentAppliedFilters[filterKey] : [currentAppliedFilters[filterKey]];
                                    Array.from(inputEl.options).forEach(option => {
                                        option.selected = values.includes(option.value);
                                    });
                                } else if (filterKey === "Due time" && typeof currentAppliedFilters[filterKey] === 'object') {
                                     if (inputEl.id.endsWith('-from')) inputEl.value = currentAppliedFilters[filterKey].from || '';
                                     if (inputEl.id.endsWith('-to')) inputEl.value = currentAppliedFilters[filterKey].to || '';
                                }
                                else {
                                    inputEl.value = currentAppliedFilters[filterKey];
                                }
                            }
                        });

                        renderDiagram();
                        if(isTreeHighlightActive) drawAllTreeDependencies();

                        diagramPane.style.transform = `scale(${currentZoom})`;

                         if (savedState.isMiniMapVisible) {
                           miniMapWrapper.style.display = 'block';
                        } else {
                           miniMapWrapper.style.display = 'none';
                        }

                        requestAnimationFrame(() => {
                           diagramContainer.scrollTop = savedState.scrollTop || 0;
                           diagramContainer.scrollLeft = savedState.scrollLeft || 0;
                           updateTopBarHeight();
                           updateStickyAxesContainerPositions();
                           updateStickyAxesLabels();
                           drawMiniMap();
                           updateMiniMapViewPort();
                           positionActionIcons();
                        });
                         if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
                    } else {
                        renderDiagram(); 
                        if(isTreeHighlightActive) drawAllTreeDependencies(); 
                         if (savedState.isMiniMapVisible && Object.keys(processesData).length > 0) { 
                            miniMapWrapper.style.display = 'block';
                        } else {
                            miniMapWrapper.style.display = 'none';
                        }
                        updateTopBarHeight();
                        drawMiniMap();
                        updateMiniMapViewPort();
                        positionActionIcons(); 
                        if (welcomeMessageOverlay && (Object.keys(processesData).length === 0 || getCurrentlyVisibleProcesses().length === 0)) {
                           welcomeMessageOverlay.style.display = 'flex';
                        } else if (welcomeMessageOverlay) {
                           welcomeMessageOverlay.style.display = 'none';
                        }
                    }
                    return true;
                } catch (e) {
                    console.error("Error parsing state from LocalStorage:", e);
                    showNotification("Error loading saved state. Resetting to defaults.", 'error');
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    isTreeHighlightActive = false;
                    highlightedTreeNodesIds.clear();
                    if (visualControlsContainer) {
                        visualControlsContainer.style.display = 'none';
                        toggleColorsButton.textContent = 'Colours 🎨 (Show)';
                    }
                    dependencyEditingEnabled = false; 
                    updateDependencyEditButtonText();
                    if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
                    return false;
                }
            }
        }
        if (visualControlsContainer) {
            visualControlsContainer.style.display = 'none';
            toggleColorsButton.textContent = 'Colours 🎨 (Show)';
        }
        dependencyEditingEnabled = false; 
        updateDependencyEditButtonText();
        if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        return false;
    }

    function initializeColorPickers() {
        const colorPickerMapping = [
            { id: 'node-color', key: 'node' },
            { id: 'blocking-node-color', key: 'blockingNode' },             
            { id: 'informational-node-color', key: 'informationalNode' },   
            { id: 'lightning-color', key: 'lightning' },
            { id: 'input-process-color', key: 'inputProcess' },
            { id: 'output-process-color', key: 'outputProcess' },
            { id: 'input-arrow-color', key: 'inputArrow' },
            { id: 'output-arrow-color', key: 'outputArrow' },
            { id: 'input-arrow-blocking-color', key: 'inputArrowBlocking' },
            { id: 'output-arrow-blocking-color', key: 'outputArrowBlocking' },
            { id: 'input-arrow-informational-color', key: 'inputArrowInformational' },
            { id: 'output-arrow-informational-color', key: 'outputArrowInformational' }
        ];

        colorPickerMapping.forEach(item => {
            const picker = document.getElementById(item.id);
            if (picker) {
                picker.value = configColors[item.key] || picker.value; 
                 if (!configColors[item.key]) { 
                    configColors[item.key] = picker.value; 
                 } else {
                    picker.value = configColors[item.key]; 
                 }


                picker.addEventListener('input', (event) => {
                    configColors[item.key] = event.target.value;
                    refreshDiagramStyles();
                    saveStateToLocalStorage();
                });
            }
        });
    }
    
    function getAllProcessesFromData() {
        let allProcs = [];
        Object.keys(processesData).forEach(sheetName => { 
            if(Array.isArray(processesData[sheetName])) {
                const sheetData = processesData[sheetName].map(p => ({...p, "_sourceSheet": sheetName}));
                allProcs.push(...sheetData);
            }
        });
        return allProcs;
    }


    function getCurrentlyVisibleProcesses(includeSourceSheetTag = false) {
        if (!selectedSheetViews || selectedSheetViews.length === 0 || Object.keys(processesData).length === 0) {
            return [];
        }

        let collectedProcesses = [];
        selectedSheetViews.forEach(sheetName => {
            if (processesData[sheetName] && Array.isArray(processesData[sheetName])) {
                processesData[sheetName].forEach(p => {
                    const processWithSheetInfo = { ...p };
                    if (includeSourceSheetTag) {
                        processWithSheetInfo._sourceSheet = sheetName;
                        if (allDataSourceSheetNames.length > 1) {
                            const colorIdx = allDataSourceSheetNames.indexOf(sheetName);
                            if (colorIdx !== -1) {
                                processWithSheetInfo._sheetColorIndex = colorIdx % sheetColors.length;
                            }
                        }
                    }
                    collectedProcesses.push(processWithSheetInfo);
                });
            }
        });

        if (currentProcessTypeView === "Standard") {
            collectedProcesses = collectedProcesses.filter(p => (p["Process Type"] || "standard").toLowerCase() === "standard");
        }
        return collectedProcesses;
    }


function refreshDiagramStyles() {
    if (isSimulationModeActive) {
        applySimulationVisuals(simulatedNewProcessData); 
        return;
    }

    const allProcsDataWithSheetInfo = getAllProcessesFromData();
    const diagramNodes = diagramPane.querySelectorAll('.process-node');

    svgLayer.innerHTML = ''; 
    simulationGhostLayer.innerHTML = '';

    diagramNodes.forEach(nodeEl => {
        const procId = nodeEl.dataset.id;
        const nodeSheet = nodeEl.dataset.sourceSheet; 
        const procData = allProcsDataWithSheetInfo.find(p => p.ID === procId && p._sourceSheet === nodeSheet);

        nodeEl.classList.remove(
            'selected', 'dependent-input', 'dependent-output',
            'dimmed-selection',
            'tree-highlight-dimmed'
        );
        nodeEl.style.opacity = 1; 
        nodeEl.style.boxShadow = '1px 1px 3px rgba(0,0,0,0.1)'; 
        nodeEl.classList.add('can-hover'); 

        const processType = (procData ? (procData["Process Type"] || "standard").toLowerCase() : "standard");
        let baseNodeColorToApply = configColors.node; 

        if (procData) { 
            if (processType === "blocking") {
                baseNodeColorToApply = configColors.blockingNode;
            } else if (processType === "informational") {
                baseNodeColorToApply = configColors.informationalNode;
            }
        }
        nodeEl.style.backgroundColor = baseNodeColorToApply;
        nodeEl.style.borderColor = shadeColor(baseNodeColorToApply, -0.3);


        if (nodeEl.classList.contains('filtered-out-general') || nodeEl.classList.contains('filtered-out-axis')) {
            nodeEl.classList.remove('can-hover');
        }

        if (isTreeHighlightActive) { 
            nodeEl.classList.remove('can-hover'); 
            if (highlightedTreeNodesIds.has(procId)) {
                nodeEl.classList.add('can-hover');
                if (procId !== currentlySelectedProcessId) {
                     nodeEl.style.borderColor = configColors.lightning;
                     nodeEl.style.boxShadow = `0 0 5px ${configColors.lightning}`;
                }
            } else {
                nodeEl.classList.add('tree-highlight-dimmed'); 
            }
        }

        if (nodeEl.classList.contains('search-highlight')) {
            nodeEl.style.backgroundColor = '#ffe0b3'; 
            nodeEl.style.borderColor = '#ff8c00';   

            nodeEl.classList.add('can-hover');
            nodeEl.style.opacity = 1; 
        } else if (nodeEl.classList.contains('search-dimmed')) {
            nodeEl.classList.remove('can-hover');
        }

        if (!isTreeHighlightActive && currentlySelectedProcessId) {
            if (procId === currentlySelectedProcessId) {
                nodeEl.classList.add('selected');
                nodeEl.style.borderColor = configColors.lightning;
                nodeEl.style.boxShadow = `0 0 10px ${configColors.lightning}`;
                nodeEl.style.opacity = 1; 
                nodeEl.classList.add('can-hover');
            } else {
                let isDirectDependency = false;
                const selectedProcDataForDeps = allProcsDataWithSheetInfo.find(p => p.ID === currentlySelectedProcessId);

                if (selectedProcDataForDeps && selectedProcDataForDeps.Dependencies) {
                    const depsOfSelected = String(selectedProcDataForDeps.Dependencies).split(';').map(d => parseDependencyEntry(d).id);
                    if (depsOfSelected.includes(procId)) {
                        nodeEl.classList.add('dependent-input');
                        if (!nodeEl.classList.contains('search-highlight')) {
                            nodeEl.style.backgroundColor = configColors.inputProcess;
                            nodeEl.style.borderColor = shadeColor(configColors.inputProcess, -0.3);
                        }
                        isDirectDependency = true;
                    }
                }
                if (!isDirectDependency && procData && procData.Dependencies) {
                    const depsOfCurrentNode = String(procData.Dependencies).split(';').map(d => parseDependencyEntry(d).id);
                    if (depsOfCurrentNode.includes(currentlySelectedProcessId)) {
                        nodeEl.classList.add('dependent-output');
                        if (!nodeEl.classList.contains('search-highlight')) {
                            nodeEl.style.backgroundColor = configColors.outputProcess;
                            nodeEl.style.borderColor = shadeColor(configColors.outputProcess, -0.3);
                        }
                        isDirectDependency = true;
                    }
                }

                if (isDirectDependency) {
                    nodeEl.style.opacity = 1; 
                    nodeEl.classList.add('can-hover');
                } else if (!nodeEl.classList.contains('search-highlight') && !nodeEl.classList.contains('search-dimmed') &&
                           !nodeEl.classList.contains('filtered-out-general') && !nodeEl.classList.contains('filtered-out-axis') &&
                           !nodeEl.classList.contains('tree-highlight-dimmed') ) { 
                    nodeEl.classList.add('dimmed-selection'); 
                    nodeEl.classList.remove('can-hover');
                }
            }
        }

        const symbolSpan = nodeEl.querySelector('.node-type-symbol');
        if (symbolSpan) {
            symbolSpan.style.color = configColors.nodeSymbolColor || '#333';
        }
    });

    if (isTreeHighlightActive) {
        if (highlightedTreeNodesIds.size > 0) {
            drawAllTreeDependencies(); 
        }
    } else if (currentlySelectedProcessId) {
        const selectedProcessForArrows = allProcsDataWithSheetInfo.find(p => p.ID === currentlySelectedProcessId);
        if (selectedProcessForArrows) {
            drawSelectionDependenciesArrows(selectedProcessForArrows);
        }
    }

    positionActionIcons(); 
    drawMiniMap();         
    updateMiniMapViewPort();
}

function drawSelectionDependenciesArrows(selectedProcess) {
    if (!selectedProcess || !nodeLayouts[selectedProcess.ID]) return;

    const selectedId = selectedProcess.ID;
    const selectedNodeEl = diagramPane.querySelector(`.process-node[data-id="${selectedId}"]`);
    if (!selectedNodeEl || selectedNodeEl.classList.contains('filtered-out-general') || selectedNodeEl.classList.contains('filtered-out-axis')) return;

    const allProcsDataWithSheet = getAllProcessesFromData(); 

    const inputRawEntries = (selectedProcess.Dependencies ? String(selectedProcess.Dependencies) : '').split(';').map(entry => entry.trim()).filter(entry => entry);
    inputRawEntries.forEach(rawDepEntry => {
        const { id: inputSourceId, type: depLinkType } = parseDependencyEntry(rawDepEntry);
        if (inputSourceId === selectedId) return; 

        const inputSourceNodeEl = diagramPane.querySelector(`.process-node[data-id="${inputSourceId}"]`);
        if (inputSourceNodeEl && 
            !inputSourceNodeEl.classList.contains('filtered-out-general') &&
            !inputSourceNodeEl.classList.contains('filtered-out-axis') &&
            !inputSourceNodeEl.classList.contains('search-dimmed') && 
            !inputSourceNodeEl.classList.contains('dimmed-selection') && 
            !(isTreeHighlightActive && !highlightedTreeNodesIds.has(inputSourceId)))
        {
            let arrowColor = configColors.inputArrow;
            if (depLinkType === 'blocking') arrowColor = configColors.inputArrowBlocking;
            else if (depLinkType === 'informational') arrowColor = configColors.inputArrowInformational;
            drawArrow(inputSourceNodeEl, selectedNodeEl, arrowColor, 'input-arrow selection-arrow', depLinkType);
        }
    });

    allProcsDataWithSheet.forEach(proc => { 
        if (!proc.Dependencies || !nodeLayouts[proc.ID] || proc.ID === selectedId) return;

        const procDepRawEntries = String(proc.Dependencies).split(';').map(entry => entry.trim()).filter(entry => entry);
        procDepRawEntries.forEach(rawDepEntry => {
            const { id: depTargetIdInOther, type: depLinkType } = parseDependencyEntry(rawDepEntry);

            if (depTargetIdInOther === selectedId) { 
                const outputTargetNodeEl = diagramPane.querySelector(`.process-node[data-id="${proc.ID}"]`);
                if (outputTargetNodeEl && 
                    !outputTargetNodeEl.classList.contains('filtered-out-general') &&
                    !outputTargetNodeEl.classList.contains('filtered-out-axis') &&
                    !outputTargetNodeEl.classList.contains('search-dimmed') &&
                    !outputTargetNodeEl.classList.contains('dimmed-selection') && 
                    !(isTreeHighlightActive && !highlightedTreeNodesIds.has(proc.ID)))
                {
                    let arrowColor = configColors.outputArrow;
                    if (depLinkType === 'blocking') arrowColor = configColors.outputArrowBlocking;
                    else if (depLinkType === 'informational') arrowColor = configColors.outputArrowInformational;
                    drawArrow(selectedNodeEl, outputTargetNodeEl, arrowColor, 'output-arrow selection-arrow', depLinkType);
                }
            }
        });
    });
}


    function renderDiagramAndRestoreState() {
    if (isSimulationModeActive) {
        applySimulationVisuals(simulatedNewProcessData); 
        return; 
    }
    
    const previouslySelectedId = currentlySelectedProcessId; 
    const wasTreeHighlightActive = isTreeHighlightActive;
    const previousHighlightedTreeIds = new Set(highlightedTreeNodesIds); 

    renderDiagram(); 

    isTreeHighlightActive = wasTreeHighlightActive; 
    if (isTreeHighlightActive) {
        highlightedTreeNodesIds = previousHighlightedTreeIds; 
        if (previouslySelectedId && highlightedTreeNodesIds.has(previouslySelectedId)) {
            currentlySelectedProcessId = previouslySelectedId;
        } else if (previouslySelectedId && !highlightedTreeNodesIds.has(previouslySelectedId)) {
            currentlySelectedProcessId = null;
        }
    } else {
        if (previouslySelectedId) {
            const nodeToReselect = diagramPane.querySelector(`.process-node[data-id="${previouslySelectedId}"]`);
            if (nodeToReselect &&
                !nodeToReselect.classList.contains('filtered-out-general') &&
                !nodeToReselect.classList.contains('filtered-out-axis') &&
                !nodeToReselect.classList.contains('search-dimmed')
            ) {
                currentlySelectedProcessId = previouslySelectedId; 
            } else {
                currentlySelectedProcessId = null; 
            }
        } else {
            currentlySelectedProcessId = null;
        }
    }

    if (currentlySelectedProcessId) {
        const procData = getCurrentlyVisibleProcesses(true).find(p => p.ID === currentlySelectedProcessId);
        displayProcessDetails(procData);
    } else {
        displayProcessDetails(null);
    }
    
    refreshDiagramStyles(); 
    updateAllDependencyAndSimShortcutButtonsState();
}


    function parseTime(timeStr) {
        if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) return NaN;
        const parts = timeStr.split(':');
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        const s = parseInt(parts[2], 10) || 0;
        if (isNaN(h) || h < 0 || h > 23 || isNaN(m) || m < 0 || m > 59 || isNaN(s) || s < 0 || s > 59) {
            return NaN;
        }
        return h * 3600 + m * 60 + s;
    }

    function formatTimeForAxis(seconds) {
        if (isNaN(seconds)) return "??:??";
        const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
        const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
        return `${h}:${m}`;
    }

    function getHourFromTimeSec(seconds) {
        if (isNaN(seconds)) return null;
        return Math.floor(seconds / 3600);
    }

    function updateGlobalUniqueDueTimeHours() {
        const currentProcesses = getCurrentlyVisibleProcesses();
        const dueTimeHours = new Set();
        currentProcesses.forEach(p => {
            const timeSec = parseTime(p["Due time"]);
            const hour = getHourFromTimeSec(timeSec);
            if (hour !== null) {
                dueTimeHours.add(hour);
            }
        });
        gUniqueDueTimeHours = Array.from(dueTimeHours).sort((a, b) => a - b);

        if (gUniqueDueTimeHours.length === 0 && currentProcesses.length > 0) {
            const hasAnyTime = currentProcesses.some(p => !isNaN(parseTime(p["Due time"])));
            if (hasAnyTime) gUniqueDueTimeHours.push(0); 
        }
    }

    function handleJsonFileSelect(event) {
        if (isSimulationModeActive) endSimulation();
        const inputElement = event.target;
        if (inputElement.files && inputElement.files.length > 0) {
            const file = inputElement.files[0];
            loadJsonFromFile(file);
        } else {
            jsonFileNameSpan.textContent = '';
            if (inputElement) inputElement.value = null;
            saveStateToLocalStorage();
        }
    }

    function loadJsonFromFile(fileObject) {
        menuContent.style.display = 'none';
        if (!fileObject) {
            jsonFileNameSpan.textContent = '';
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const fileContent = e.target.result;
                let loadedData = JSON.parse(fileContent);
                processAndLoadJsonData(loadedData, fileObject.name); 
            } catch (error) {
                showNotification('Error parsing JSON file: ' + error.message, 'error', 0); 
                processesData = {};
                selectedSheetViews = [];
                allDataSourceSheetNames = [];
                currentProcessTypeView = "All";
                isTreeHighlightActive = false; highlightedTreeNodesIds.clear();
                jsonFileNameSpan.textContent = '';
                updateSheetMultiSelectDropdown();
                saveStateToLocalStorage(); renderDiagram();
            } finally {
                if (fileInput.files && fileInput.files[0] === fileObject) {
                    fileInput.value = null;
                }
            }
        };
        reader.onerror = (e) => {
            showNotification('Error reading file: ' + e, 'error', 0); 
             processesData = {};
             selectedSheetViews = [];
             allDataSourceSheetNames = [];
             currentProcessTypeView = "All";
             isTreeHighlightActive = false; highlightedTreeNodesIds.clear();
             jsonFileNameSpan.textContent = '';
             updateSheetMultiSelectDropdown(); saveStateToLocalStorage();
             if (fileInput.files && fileInput.files[0] === fileObject) {
                fileInput.value = null;
             }
        };
        reader.readAsText(fileObject);
    }

    function validateProcessObject(process, sheetName, index) {
        const errors = [];
        const warnings = [];
        let validatedProcess = {...process}; 

        for (const key of JSON_VALIDATION_REQUIRED_KEYS) {
            if (validatedProcess[key] === undefined || validatedProcess[key] === null || String(validatedProcess[key]).trim() === "") {
                 if (key === "WD" && (validatedProcess[key] === 0 || String(validatedProcess[key]) === "0")) {
                    validatedProcess[key] = 0;
                } else if (key === "Due time" && String(validatedProcess[key]).trim() === "") {
                    validatedProcess[key] = "";
                } else {
                    errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Missing required field "${key}".`);
                }
            }
        }

        if (validatedProcess.ID !== undefined && validatedProcess.ID !== null) {
            const idStr = String(validatedProcess.ID).trim();
            if (idStr === "") {
                errors.push(`Sheet "${sheetName}", process index ${index}: Field "ID" cannot be empty.`);
            } else if (!/^[a-zA-Z0-9._-]+$/.test(idStr)) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${idStr}): Field "ID" contains invalid characters. Use letters, numbers, '.', '_', '-'.`);
            }
            validatedProcess.ID = idStr; 
        } else if (!errors.some(err => err.includes('Missing required field "ID"'))) { 
             errors.push(`Sheet "${sheetName}", process index ${index}: Field "ID" is missing or null.`);
        }


        if (validatedProcess.WD !== undefined && validatedProcess.WD !== null && String(validatedProcess.WD).trim() !== "") {
            const wdNum = parseInt(validatedProcess.WD, 10);
            if (isNaN(wdNum)) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Field "WD" ("${validatedProcess.WD}") is not a valid integer. Using 0.`);
                validatedProcess.WD = 0; 
            } else {
                validatedProcess.WD = wdNum; 
            }
        } else {
            validatedProcess.WD = 0; 
        }

        if (validatedProcess["Due time"] !== undefined && validatedProcess["Due time"] !== null && String(validatedProcess["Due time"]).trim() !== "") {
            const timeStr = String(validatedProcess["Due time"]).trim();
            if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(timeStr)) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Field "Due time" ("${timeStr}") format must be HH:MM or HH:MM:SS. Using empty.`);
                validatedProcess["Due time"] = "";
            } else {
                const tempTime = timeStr.includes(':') && timeStr.split(':').length === 2 ? timeStr + ":00" : timeStr;
                if (isNaN(parseTime(tempTime))) {
                    errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Field "Due time" ("${timeStr}") is not a valid time (00:00:00 - 23:59:59). Using empty.`);
                    validatedProcess["Due time"] = "";
                } else {
                     validatedProcess["Due time"] = tempTime; 
                }
            }
        } else {
             validatedProcess["Due time"] = ""; 
        }
        
        const processType = (validatedProcess["Process Type"] || "standard").toLowerCase().trim();
        if (!["standard", "blocking", "informational"].includes(processType)) {
            warnings.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Invalid "Process Type" ("${validatedProcess["Process Type"] || ''}"). Defaulted to "standard".`);
            validatedProcess["Process Type"] = "standard";
        } else {
            validatedProcess["Process Type"] = processType; 
        }
        
        if (validatedProcess.Dependencies === undefined || validatedProcess.Dependencies === null) {
            validatedProcess.Dependencies = "";
        } else {
            validatedProcess.Dependencies = String(validatedProcess.Dependencies);
        }

        return { errors, warnings, validatedProcess };
    }


    async function processAndLoadJsonData(loadedData, sourceFileName) {
        if (isSimulationModeActive) endSimulation();
        if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';

        const newProcessesData = {};
        const newAllDataSourceSheetNames = [];
        let overallValidationErrors = [];
        let overallValidationWarnings = [];
        let uniqueIdCheck = {}; 

        if (Array.isArray(loadedData)) {
            const sheetName = "Default"; 
             newAllDataSourceSheetNames.push(sheetName);
            uniqueIdCheck[sheetName] = new Set();
            newProcessesData[sheetName] = [];

            loadedData.forEach((p, index) => {
                const { errors, warnings, validatedProcess } = validateProcessObject(p, sheetName, index);
                overallValidationErrors.push(...errors);
                overallValidationWarnings.push(...warnings);

                if (errors.length === 0) {
                    if (validatedProcess.ID && uniqueIdCheck[sheetName].has(validatedProcess.ID)) {
                        overallValidationErrors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID}): Duplicate ID found in this sheet.`);
                    } else {
                        if(validatedProcess.ID) uniqueIdCheck[sheetName].add(validatedProcess.ID);
                        newProcessesData[sheetName].push({
                            ...validatedProcess,
                            Description: String(validatedProcess.Description || '').replace(/\\n/g, '\n')
                        });
                    }
                }
            });
        } else if (typeof loadedData === 'object' && loadedData !== null) {
            Object.keys(loadedData).forEach(sheetName => {
                if (Array.isArray(loadedData[sheetName])) {
                    newAllDataSourceSheetNames.push(sheetName);
                    uniqueIdCheck[sheetName] = new Set();
                    newProcessesData[sheetName] = [];

                    loadedData[sheetName].forEach((p, index) => {
                        const { errors, warnings, validatedProcess } = validateProcessObject(p, sheetName, index);
                        overallValidationErrors.push(...errors);
                        overallValidationWarnings.push(...warnings);

                        if (errors.length === 0) {
                            if (validatedProcess.ID && uniqueIdCheck[sheetName].has(validatedProcess.ID)) {
                                overallValidationErrors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID}): Duplicate ID found in this sheet.`);
                            } else {
                                if(validatedProcess.ID) uniqueIdCheck[sheetName].add(validatedProcess.ID);
                                newProcessesData[sheetName].push({
                                    ...validatedProcess,
                                    Description: String(validatedProcess.Description || '').replace(/\\n/g, '\n')
                                });
                            }
                        }
                    });
                } else {
                    overallValidationWarnings.push(`Sheet "${sheetName}" data is not an array and was skipped.`);
                }
            });
        } else {
            showNotification("JSON data must be an array of processes or an object of sheet-keyed arrays.", 'error', 0);
            jsonFileNameSpan.textContent = '';
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }
        
        if (overallValidationWarnings.length > 0) {
            showNotification("<strong>JSON Load Warnings:</strong><br>" + overallValidationWarnings.map(w => `- ${w}`).join("<br>"), 'warning', 10000);
        }
        if (overallValidationErrors.length > 0) {
            showNotification("<strong>JSON Load Errors (some data might be ignored):</strong><br>" + overallValidationErrors.map(e => `- ${e}`).join("<br>"), 'error', 15000);
            const totalValidProcesses = Object.values(newProcessesData).reduce((sum, sheet) => sum + (sheet ? sheet.length : 0), 0);
            if (totalValidProcesses === 0) {
                 showNotification("<strong>Critical JSON Load Error:</strong> No valid process data could be loaded due to errors. Please check the JSON structure and required fields (ID, WD, Due time).", 'error', 0);
                 processesData = {}; allDataSourceSheetNames = []; selectedSheetViews = [];
                 updateSheetMultiSelectDropdown(); renderDiagram(); saveStateToLocalStorage();
                 if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
                 return;
            }
        }

        if (Object.keys(newProcessesData).length === 0 && newAllDataSourceSheetNames.length === 0 && overallValidationErrors.length > 0) {
            showNotification("No valid process data found in the JSON after validation.", 'error', 0);
            jsonFileNameSpan.textContent = '';
            processesData = {}; allDataSourceSheetNames = []; selectedSheetViews = [];
            updateSheetMultiSelectDropdown(); renderDiagram(); saveStateToLocalStorage();
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }

        processesData = newProcessesData;
        allDataSourceSheetNames = newAllDataSourceSheetNames.sort(); 

        if (allDataSourceSheetNames.length > 0) {
            selectedSheetViews = [...allDataSourceSheetNames]; 
        } else {
            selectedSheetViews = [];
        }
        currentProcessTypeView = "All";
        processTypeViewSelector.value = "All";

        jsonFileNameSpan.textContent = sourceFileName || 'Loaded Data';
        updateSheetMultiSelectDropdown();
        updateAddProcessButtonState();

        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        currentZoom = 1; 
        diagramPane.style.transform = `scale(${currentZoom})`;
        diagramContainer.scrollTop = 0; 
        diagramContainer.scrollLeft = 0;
        temporaryActiveFilters = {}; currentAppliedFilters = {}; 
        currentAxisFilter = { type: null, value: null, valueEnd: null };
        currentlySelectedProcessId = null; nodeLayouts = {}; 

        updateGlobalUniqueDueTimeHours();
        populateFilterPanel(); 
        renderDiagram(); 
        resetVisualStates(); 

        requestAnimationFrame(() => {
            updateTopBarHeight();
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
            positionActionIcons(); 
        });
        saveStateToLocalStorage(); 
        if (overallValidationErrors.length === 0 && overallValidationWarnings.length === 0) {
            showNotification(`Successfully loaded data from ${sourceFileName || 'JSON'}.`, 'success');
        }
        if (Object.keys(newProcessesData).length > 0 && getCurrentlyVisibleProcesses().length > 0) {
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
        } else {
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        }
    }

    function updateSheetMultiSelectDropdown() {
        sheetMultiSelectOptions.innerHTML = ''; 

        if (allDataSourceSheetNames.length === 0) {
            sheetMultiSelectOptions.innerHTML = '<p style="font-size:0.9em; color:#777;">Load data to see sheets.</p>';
            sheetSelectAllCheckbox.disabled = true;
            sheetSelectAllCheckbox.checked = false;
            selectedSheetViews = []; 
        } else {
            allDataSourceSheetNames.forEach(sheetName => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = sheetName;
                checkbox.checked = selectedSheetViews.includes(sheetName);
                checkbox.addEventListener('change', handleSheetSelectionChange);

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(" " + sheetName));
                sheetMultiSelectOptions.appendChild(label);
            });
            sheetSelectAllCheckbox.disabled = false;
            checkSelectAllState(); 
        }
        updateAddProcessButtonState(); 
    }

    function checkSelectAllState() {
        const checkboxes = sheetMultiSelectOptions.querySelectorAll('input[type="checkbox"]');
        if (checkboxes.length === 0) {
            sheetSelectAllCheckbox.checked = false;
            sheetSelectAllCheckbox.indeterminate = false;
            return;
        }
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        const someChecked = Array.from(checkboxes).some(cb => cb.checked);

        sheetSelectAllCheckbox.checked = allChecked;
        sheetSelectAllCheckbox.indeterminate = !allChecked && someChecked;
    }

    function handleSheetSelectionChange() {
        if (isSimulationModeActive) endSimulation();
        selectedSheetViews = Array.from(sheetMultiSelectOptions.querySelectorAll('input[type="checkbox"]:checked'))
                                .map(cb => cb.value);
        checkSelectAllState();
        updateAddProcessButtonState();

        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        temporaryActiveFilters = {}; currentAppliedFilters = {};
        currentAxisFilter = { type: null, value: null, valueEnd: null };
        currentlySelectedProcessId = null;
        searchInput.value = ''; 

        updateGlobalUniqueDueTimeHours(); 
        populateFilterPanel(); 
        renderDiagram(); 
        resetVisualStates(); 
        saveStateToLocalStorage();
    }

    function updateAddProcessButtonState() {
        document.getElementById('add-process-button').disabled = selectedSheetViews.length !== 1;
    }

    function handleProcessTypeViewChange(event) {
        if (isSimulationModeActive) endSimulation();
        currentProcessTypeView = event.target.value;

        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        temporaryActiveFilters = {}; currentAppliedFilters = {}; 
        currentAxisFilter = { type: null, value: null, valueEnd: null }; 
        currentlySelectedProcessId = null; 
        searchInput.value = ''; 

        updateGlobalUniqueDueTimeHours(); 
        populateFilterPanel(); 
        renderDiagram(); 
        resetVisualStates(); 
        saveStateToLocalStorage();
    }



    function parseDependencyEntry(depEntry) {
        const entry = String(depEntry).trim();
        if (entry.endsWith('_B')) {
            return { id: entry.slice(0, -2), type: 'blocking' };
        } else if (entry.endsWith('_I')) {
            return { id: entry.slice(0, -2), type: 'informational' };
        }
        return { id: entry, type: 'standard' };
    }

function renderDiagram() {
        if (isSimulationModeActive) {
             applySimulationVisuals(simulatedNewProcessData); return;
        }
        diagramPane.innerHTML = '';
        svgLayer.innerHTML = ''; 
        simulationGhostLayer.innerHTML = '';
        diagramPane.appendChild(svgLayer);
        diagramPane.appendChild(simulationGhostLayer);
        diagramPane.appendChild(linkHandleTrigger);
        if (welcomeMessageOverlay) diagramPane.appendChild(welcomeMessageOverlay);

        hideActionIcons();
        nodeLayouts = {};
        overallDiagramBounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

        const currentProcesses = getCurrentlyVisibleProcesses(true);
        const allProcessesForLayout = getAllProcessesFromData();

        if (allProcessesForLayout.length === 0 && currentProcesses.length === 0) {
            diagramPane.style.width = '100%';
            diagramPane.style.height = '100%';
            displayProcessDetails(null);
            if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
            if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
            gUniqueDueTimeHours = [];
            if (filterOptionsContainer) filterOptionsContainer.innerHTML = `<p>No data loaded.</p>`;
            drawMiniMap();
            updateMiniMapViewPort();
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }
        if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
        
        if (currentProcesses.length === 0 && allProcessesForLayout.length > 0) {
             diagramPane.style.width = '100%';
             diagramPane.style.height = '100%';
             displayProcessDetails(null);
             if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
             if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
             if (filterOptionsContainer) {
                const currentViewDesc = selectedSheetViews.length > 0 ? selectedSheetViews.join(', ') : 'None';
                filterOptionsContainer.innerHTML = `<p>No processes in view: ${currentViewDesc} (${currentProcessTypeView} types).</p>`;
             }
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        } else if (welcomeMessageOverlay) {
             welcomeMessageOverlay.style.display = 'none';
        }


        const wdsInDataDisplay = allProcessesForLayout.map(p => p.WD).filter(wd => typeof wd === 'number' && !isNaN(wd));
        let uniqueDataWdsDisplay = [...new Set(wdsInDataDisplay)].sort((a, b) => a - b);
        if (uniqueDataWdsDisplay.length === 0 && allProcessesForLayout.length > 0) {
            const firstWD = allProcessesForLayout[0]?.WD; 
            uniqueDataWdsDisplay.push( (typeof firstWD === 'number' && !isNaN(firstWD)) ? firstWD : 0 );
        } else if (uniqueDataWdsDisplay.length === 0) { 
            uniqueDataWdsDisplay.push(0); 
        }
        gUniqueDataWds = uniqueDataWdsDisplay;
        const numberOfWdColumnsDisplay = gUniqueDataWds.length;

        const minTimeSecDisplay = 0; 
        const maxTimeSecDisplay = 24 * 3600; 
        const numTimeBinsDisplay = Math.ceil(maxTimeSecDisplay / gTimeBinSizeSec);
        gTimeBins = [];
        let totalTimeWeightDisplay = 0;

        for (let i = 0; i < numTimeBinsDisplay; i++) {
            gTimeBins.push({
                startSec: i * gTimeBinSizeSec,
                endSec: (i + 1) * gTimeBinSizeSec - 1,
                count: 0, weight: 1, height: 0, yOffset: 0 
            });
        }

        allProcessesForLayout.forEach(p => {
            const timeValue = parseTime(p["Due time"]);
            if (!isNaN(timeValue)) {
                const binIndex = Math.min(numTimeBinsDisplay - 1, Math.max(0, Math.floor(timeValue / gTimeBinSizeSec))); // Uzupełnienie
                if(gTimeBins[binIndex]) gTimeBins[binIndex].count++;
            }
        });

        gTimeBins.forEach(bin => {
            bin.weight = 1 + bin.count; 
            totalTimeWeightDisplay += bin.weight;
        });

        const baseHeightPerBinDisplay = (NODE_HEIGHT + VERTICAL_NODE_PADDING); 
        let estimatedContentHeightDisplay = 0;
        gTimeBins.forEach(bin => { estimatedContentHeightDisplay += bin.weight * baseHeightPerBinDisplay * 0.2; }); 
        estimatedContentHeightDisplay = Math.max(estimatedContentHeightDisplay, 500); 

        const estimatedMinWdContentWidthDisplay = numberOfWdColumnsDisplay * (NODE_BASE_WIDTH + 30); 

        let diagramClientWidth = diagramContainer.clientWidth;
        let diagramClientHeight = diagramContainer.clientHeight;
        if (document.body.classList.contains('presentation-mode')) { 
            diagramClientWidth = window.innerWidth;
            diagramClientHeight = window.innerHeight - topBarHeight;
        }

        const estimatedDiagramWidthDisplay = Math.max( diagramClientWidth / currentZoom, PADDING * 2 + Y_AXIS_LABEL_WIDTH_ORIGINAL + estimatedMinWdContentWidthDisplay );
        const estimatedDiagramHeightDisplay = Math.max( diagramClientHeight / currentZoom, PADDING * 2 + PADDING + estimatedContentHeightDisplay ); 
        diagramPane.style.width = `${estimatedDiagramWidthDisplay}px`;
        diagramPane.style.height = `${estimatedDiagramHeightDisplay}px`;

        const plotWidthDisplay = Math.max(0, diagramPane.clientWidth - Y_AXIS_LABEL_WIDTH_ORIGINAL - PADDING * 2);
        const plotHeightDisplay = Math.max(0, diagramPane.clientHeight - PADDING * 2); 
        gPlotHeight = plotHeightDisplay;
        gWdColumnWidth = numberOfWdColumnsDisplay > 0 ? plotWidthDisplay / numberOfWdColumnsDisplay : plotWidthDisplay; 

        let currentYOffsetDisplay = PADDING; 
        gTimeBins.forEach(bin => {
            bin.height = totalTimeWeightDisplay > 0 ? (bin.weight / totalTimeWeightDisplay) * plotHeightDisplay : (numTimeBinsDisplay > 0 ? plotHeightDisplay / numTimeBinsDisplay : plotHeightDisplay);
            bin.yOffset = currentYOffsetDisplay;
            currentYOffsetDisplay += bin.height;
        });

        const tempNodeLayouts = {}; 

        allProcessesForLayout.forEach(process => { 
            const node = document.createElement('div'); 
            node.className = 'process-node'; 
            node.textContent = process["Short name"];
            
            let nodeWidth = NODE_BASE_WIDTH;
            let nodeHeight = NODE_HEIGHT;
            
            node.style.position = 'absolute'; 
            node.style.visibility = 'hidden'; 
            node.style.left = '-9999px'; 
            document.body.appendChild(node); 
            nodeWidth = node.offsetWidth || NODE_BASE_WIDTH; 
            document.body.removeChild(node);


            const wdValue = process.WD;
            const wdIndex = gUniqueDataWds.indexOf(wdValue);
            let idealXNodeCenter;
            if (wdIndex !== -1) { 
                idealXNodeCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex * gWdColumnWidth) + (gWdColumnWidth / 2);
            } else { 
                if (gUniqueDataWds.length > 0) idealXNodeCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (gWdColumnWidth / 2);
                else idealXNodeCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (plotWidthDisplay / 2); 
            }

            const timeValue = parseTime(process["Due time"]);
            let idealYNodeCenter = PADDING + gPlotHeight / 2; 

            if (!isNaN(timeValue) && gTimeBins.length > 0) {
                const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeValue / gTimeBinSizeSec)));
                const targetBin = gTimeBins[binIndex];
                if (targetBin) {
                    const timeWithinBin = timeValue - targetBin.startSec;
                    const binDuration = targetBin.endSec - targetBin.startSec + 1; 
                    const relativePosInBin = binDuration > 0 ? timeWithinBin / binDuration : 0.5; 
                    idealYNodeCenter = targetBin.yOffset + relativePosInBin * targetBin.height;
                }
            }

            tempNodeLayouts[process.ID] = {
                process, 
                node: null, 
                idealX: idealXNodeCenter - nodeWidth / 2, 
                idealY: idealYNodeCenter - nodeHeight / 2, 
                finalX: idealXNodeCenter - nodeWidth / 2, 
                finalY: idealYNodeCenter - nodeHeight / 2,
                width: nodeWidth, height: nodeHeight,
                wd: wdValue, time: timeValue 
            };
        });

        const layoutsByWd = Object.values(tempNodeLayouts).reduce((acc, layout) => {
            const wd = layout.wd; 
            if (!acc[wd]) acc[wd] = [];
            acc[wd].push(layout);
            return acc;
        }, {});

        Object.keys(layoutsByWd).forEach(wdKey => {
            const columnLayouts = layoutsByWd[wdKey].sort((a, b) => a.idealY - b.idealY); 
            let lastBottom = -Infinity; 

            columnLayouts.forEach(layout => {
                if (layout.idealY < lastBottom + VERTICAL_NODE_PADDING) {
                    layout.finalY = lastBottom + VERTICAL_NODE_PADDING; 
                } else {
                    layout.finalY = layout.idealY; 
                }
                lastBottom = layout.finalY + layout.height; 
            });
        });
        
        nodeLayouts = tempNodeLayouts; 

        currentProcesses.forEach(process => {
            const layout = nodeLayouts[process.ID];
            if (!layout) return; 

            const node = createNodeElement(process, layout); 
            layout.node = node; 

            node.style.position = 'absolute';
            node.style.visibility = 'visible'; 
            node.style.top = `${layout.finalY}px`;
            node.style.left = `${layout.finalX}px`;
            node.classList.add('can-hover'); 

            if (isTreeHighlightActive) { 
                if (!highlightedTreeNodesIds.has(layout.process.ID)) {
                    node.classList.add('tree-highlight-dimmed');
                    node.classList.remove('can-hover');
                }
            } else { 
                if (isProcessFilteredOutByGeneralFilters(layout.process)) {
                     node.classList.add('filtered-out-general'); node.classList.remove('can-hover');
                }
                if (isProcessFilteredOutByAxisFilter(layout.process)) {
                     node.classList.add('filtered-out-axis'); node.classList.remove('can-hover');
                }
            }

            node.addEventListener('click', (e) => {
                if (node.classList.contains('filtered-out-general') ||
                    node.classList.contains('filtered-out-axis') ||
                    node.classList.contains('search-dimmed') ||
                    (isTreeHighlightActive && node.classList.contains('tree-highlight-dimmed') && !highlightedTreeNodesIds.has(layout.process.ID))
                   ) {
                     return;
                   }
                e.stopPropagation(); 
                handleProcessNodeClick(layout.process.ID);
            });

            diagramPane.appendChild(node); 

            overallDiagramBounds.minX = Math.min(overallDiagramBounds.minX, layout.finalX);
            overallDiagramBounds.minY = Math.min(overallDiagramBounds.minY, layout.finalY);

            overallDiagramBounds.maxX = Math.max(overallDiagramBounds.maxX, layout.finalX + layout.width);
            overallDiagramBounds.maxY = Math.max(overallDiagramBounds.maxY, layout.finalY + layout.height);
        });

        if (currentProcesses.length === 0 && overallDiagramBounds.minX === Infinity) { 
             overallDiagramBounds = { minX: 0, minY: 0, maxX: PADDING * 2, maxY: PADDING * 2 };
        } else if (overallDiagramBounds.minX !== Infinity) { 
            overallDiagramBounds.minX -= PADDING;
            overallDiagramBounds.minY -= PADDING;
            overallDiagramBounds.maxX += PADDING;
            overallDiagramBounds.maxY += PADDING;
        }


        gDiagramPanePadding = PADDING; 
        gYAxisLabelWidthOriginal = Y_AXIS_LABEL_WIDTH_ORIGINAL; 

        initializeStickyAxesElements(); 
        requestAnimationFrame(() => { 
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
        });
        applySearchHighlight(searchInput.value); 
        updateMiniMapViewPort(); 
    }

    function initializeStickyAxesElements() {
        if (stickyAxisInitialized) return; 
        if (!stickyYAxisContainer) {
            stickyYAxisContainer = document.createElement('div');
            stickyYAxisContainer.id = 'sticky-y-axis';
            document.body.appendChild(stickyYAxisContainer); 
        }
        if (!stickyXAxisContainer) {
            stickyXAxisContainer = document.createElement('div');
            stickyXAxisContainer.id = 'sticky-x-axis';
            document.body.appendChild(stickyXAxisContainer);
        }
        stickyAxisInitialized = true;
    }

    function updateStickyAxesContainerPositions() {
        if (!stickyAxisInitialized || !stickyYAxisContainer || !stickyXAxisContainer || !diagramContainer) return;
        let dcRect; if (document.body.classList.contains('presentation-mode')) { dcRect = { top: topBarHeight, left: 0, right: window.innerWidth, bottom: window.innerHeight, width: window.innerWidth, height: window.innerHeight - topBarHeight }; } else { dcRect = diagramContainer.getBoundingClientRect(); }
        const dcStyle = window.getComputedStyle(diagramContainer);
        const dcBorderTopWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderTopWidth) || 0);
        const dcBorderLeftWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderLeftWidth) || 0);
        const dcBorderRightWidth = document.body.classList.contains('presentation-mode') ? 0 :(parseFloat(dcStyle.borderRightWidth) || 0);
        const dcBorderBottomWidth = document.body.classList.contains('presentation-mode') ? 0 :(parseFloat(dcStyle.borderBottomWidth) || 0);
        const viewportTop = 0; const viewportLeft = 0; const viewportRight = window.innerWidth; const viewportBottom = window.innerHeight;
        const effectiveDiagramTop = Math.max(viewportTop, dcRect.top + dcBorderTopWidth);
        const effectiveDiagramLeft = Math.max(viewportLeft, dcRect.left + dcBorderLeftWidth);
        const effectiveDiagramRight = Math.min(viewportRight, dcRect.right - dcBorderRightWidth);
        const effectiveDiagramBottom = Math.min(viewportBottom, dcRect.bottom - dcBorderBottomWidth);
        const minVisibleHeightForY = STICKY_X_AXIS_HEIGHT + SCROLLBAR_HEIGHT_ESTIMATE + 20; 
        const minVisibleWidthForX = STICKY_Y_AXIS_WIDTH + 20; 
        const minSpaceForXAxisAndScrollbar = STICKY_X_AXIS_HEIGHT + SCROLLBAR_HEIGHT_ESTIMATE;
        stickyXAxisContainer.style.top = (effectiveDiagramBottom - minSpaceForXAxisAndScrollbar) + 'px';
        stickyXAxisContainer.style.left = (effectiveDiagramLeft + STICKY_Y_AXIS_WIDTH) + 'px';
        stickyXAxisContainer.style.height = STICKY_X_AXIS_HEIGHT + 'px';
        stickyXAxisContainer.style.width = Math.max(0, effectiveDiagramRight - (effectiveDiagramLeft + STICKY_Y_AXIS_WIDTH)) + 'px';
        if (parseFloat(stickyXAxisContainer.style.width) <= 0 || parseFloat(stickyXAxisContainer.style.top) < effectiveDiagramTop || dcRect.bottom < viewportTop + minSpaceForXAxisAndScrollbar || dcRect.top > viewportBottom - minSpaceForXAxisAndScrollbar || dcRect.right < viewportLeft + STICKY_Y_AXIS_WIDTH + 20 || dcRect.left > viewportRight - STICKY_Y_AXIS_WIDTH) { stickyXAxisContainer.style.display = 'none'; } else { stickyXAxisContainer.style.display = 'block'; }
        stickyYAxisContainer.style.top = effectiveDiagramTop + 'px';
        stickyYAxisContainer.style.left = effectiveDiagramLeft + 'px';
        stickyYAxisContainer.style.width = STICKY_Y_AXIS_WIDTH + 'px';
        let yAxisBottomEdge = effectiveDiagramBottom;
        if (stickyXAxisContainer.style.display !== 'none' && parseFloat(stickyXAxisContainer.style.top) > effectiveDiagramTop) { yAxisBottomEdge = Math.min(yAxisBottomEdge, parseFloat(stickyXAxisContainer.style.top)); } else { yAxisBottomEdge = Math.min(yAxisBottomEdge, effectiveDiagramBottom - SCROLLBAR_HEIGHT_ESTIMATE); }
        stickyYAxisContainer.style.height = Math.max(0, yAxisBottomEdge - effectiveDiagramTop) + 'px';
        if (parseFloat(stickyYAxisContainer.style.height) <= 0 || dcRect.bottom < viewportTop + minVisibleHeightForY || dcRect.top > viewportBottom - minVisibleHeightForY || dcRect.right < viewportLeft + minVisibleWidthForX || dcRect.left > viewportRight - minVisibleWidthForX) { stickyYAxisContainer.style.display = 'none'; } else { stickyYAxisContainer.style.display = 'block'; }
    }

    function updateStickyAxesLabels() {
        if (!stickyAxisInitialized || !stickyYAxisContainer || !stickyXAxisContainer || getCurrentlyVisibleProcesses().length === 0 || gUniqueDataWds.length === 0) {
            if(stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
            if(stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
            return;
        }
        stickyYAxisContainer.innerHTML = ''; stickyXAxisContainer.innerHTML = '';
        const scrollTop = diagramContainer.scrollTop; const scrollLeft = diagramContainer.scrollLeft;
        let dcRect; if (document.body.classList.contains('presentation-mode')) { dcRect = { top: topBarHeight, left: 0 }; } else { dcRect = diagramContainer.getBoundingClientRect(); }
        const dcStyle = window.getComputedStyle(diagramContainer);
        const dcBorderTopWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderTopWidth) || 0);
        const dcBorderLeftWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderLeftWidth) || 0);
        const stickyYContainerViewportTop = parseFloat(stickyYAxisContainer.style.top) || 0;
        const stickyXContainerViewportLeft = parseFloat(stickyXAxisContainer.style.left) || 0;
        const labelHeightEstimate = 18; const yAxisOffset = -7; 
        if (stickyYAxisContainer.style.display !== 'none' && gUniqueDueTimeHours && gUniqueDueTimeHours.length > 0 && gTimeBins.length > 0) {
            const hoursToDisplay = new Set(gUniqueDueTimeHours);
            if (!hoursToDisplay.has(0) && gUniqueDueTimeHours.length > 0 && Math.min(...gUniqueDueTimeHours) >= 0) hoursToDisplay.add(0);
             if (!hoursToDisplay.has(23) && gUniqueDueTimeHours.length > 0 ) { const maxHour = Math.max(...gUniqueDueTimeHours); if(maxHour < 23) hoursToDisplay.add(23); }
            Array.from(hoursToDisplay).sort((a,b) => a-b).forEach(hour => {
                const timeSec = hour * 3600; let originalLabelYUnzoomed = -1;
                const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeSec / gTimeBinSizeSec)));
                if (gTimeBins[binIndex]) { originalLabelYUnzoomed = gTimeBins[binIndex].yOffset; }
                if (originalLabelYUnzoomed !== -1) {
                    const labelAbsoluteYInViewport = (dcRect.top + dcBorderTopWidth) + ((originalLabelYUnzoomed + yAxisOffset) * currentZoom) - scrollTop;
                    const labelTopInStickyContainer = labelAbsoluteYInViewport - stickyYContainerViewportTop;
                    if (labelTopInStickyContainer + labelHeightEstimate > 0 && labelTopInStickyContainer < parseFloat(stickyYAxisContainer.style.height)) {
                        const label = document.createElement('div'); label.className = 'axis y-axis-label';
                        label.textContent = (hour === 23) ? formatTimeForAxis(24 * 3600) : formatTimeForAxis(timeSec); 
                        label.style.position = 'absolute'; label.style.top = labelTopInStickyContainer + 'px'; label.style.left = (STICKY_Y_AXIS_WIDTH - 45) + 'px'; 
                        label.dataset.timeValue = timeSec; 
                        if (currentAxisFilter.type === 'TIME' && currentAxisFilter.value === timeSec) { label.classList.add('active-axis-filter'); } else { label.classList.remove('active-axis-filter'); }
                        label.addEventListener('click', (e) => { e.stopPropagation(); handleAxisLabelClick('TIME', timeSec); });
                        stickyYAxisContainer.appendChild(label);
                    }
                }
            });
        }
        if (stickyXAxisContainer.style.display !== 'none') {
            const labelWidthEstimate = 50;
            gUniqueDataWds.forEach((wd, index) => {
                const originalLabelXCenterUnzoomed = gYAxisLabelWidthOriginal + gDiagramPanePadding + (index * gWdColumnWidth) + (gWdColumnWidth / 2);
                const labelAbsoluteXInDiagramPane = (originalLabelXCenterUnzoomed * currentZoom); 
                const labelVisibleLeftInDC = labelAbsoluteXInDiagramPane - scrollLeft; 
                 const dcScreenLeft = dcRect.left + dcBorderLeftWidth;
                const labelScreenLeft = dcScreenLeft + labelVisibleLeftInDC;
                const labelCenterInStickyContainer = labelScreenLeft - stickyXContainerViewportLeft;
                if (labelCenterInStickyContainer > -labelWidthEstimate / 2 && labelCenterInStickyContainer < parseFloat(stickyXAxisContainer.style.width) + labelWidthEstimate / 2) {
                    const label = document.createElement('div'); label.className = 'axis x-axis-label'; label.textContent = `WD ${wd}`;
                    label.style.position = 'absolute'; label.style.left = labelCenterInStickyContainer + 'px'; label.style.top = '50%'; label.style.transform = 'translate(-50%, -50%)';
                    label.dataset.wdValue = wd;
                    if (currentAxisFilter.type === 'WD' && currentAxisFilter.value === wd) { label.classList.add('active-axis-filter'); } else { label.classList.remove('active-axis-filter'); }
                    label.addEventListener('click', (e) => { e.stopPropagation(); handleAxisLabelClick('WD', wd); });
                    stickyXAxisContainer.appendChild(label);
                }
            });
        }
    }

    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    function shadeColor(color, percent) {
        if (!color || color.length < 4 || color[0] !== '#') return '#cccccc'; 
        let R = parseInt(color.substring(1,3),16);
        let G = parseInt(color.substring(3,5),16);
        let B = parseInt(color.substring(5,7),16);
        R = parseInt(String(R * (100 + percent) / 100));
        G = parseInt(String(G * (100 + percent) / 100));
        B = parseInt(String(B * (100 + percent) / 100));
        R = Math.max(0, Math.min(255, R)); G = Math.max(0, Math.min(255, G)); B = Math.max(0, Math.min(255, B));
        const RR = R.toString(16).padStart(2, '0');
        const GG = G.toString(16).padStart(2, '0');
        const BB = B.toString(16).padStart(2, '0');
        return "#"+RR+GG+BB;
    }

	function selectProcess(processId, updateDetails = true) {
    if (isSimulationModeActive) return;
    
    const previouslySelectedId = currentlySelectedProcessId;

    if (isTreeHighlightActive) {
        if (highlightedTreeNodesIds.has(processId)) {
            currentlySelectedProcessId = processId; 
        } else {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            currentlySelectedProcessId = processId;
        }
    } else {
        if (currentlySelectedProcessId === processId) {
            currentlySelectedProcessId = null; 
        } else {
            currentlySelectedProcessId = processId; 
        }
    }

    if (updateDetails && !document.body.classList.contains('presentation-mode')) {
        if (currentlySelectedProcessId) {
            const proc = getCurrentlyVisibleProcesses(true).find(p => p.ID === currentlySelectedProcessId);
            displayProcessDetails(proc);
        } else {
            displayProcessDetails(null); 
        }
    }
    
    refreshDiagramStyles();
    updateAllDependencyAndSimShortcutButtonsState();

    if (previouslySelectedId !== currentlySelectedProcessId && dependencyPanelContainer.classList.contains('visible')) {
        if (currentlySelectedProcessId) {
            generateAndShowDependencyTree(currentlySelectedProcessId);
        } else {
            toggleDependencyPanel(false);
        }
    }
    
    saveStateToLocalStorage(); 
	}


    function applySelectionDimming(selectedId) {
        if (isTreeHighlightActive || isSimulationModeActive) return; 

        diagramPane.querySelectorAll('.process-node').forEach(node => {
            const isSelected = node.dataset.id === selectedId;
            const isDependent = node.classList.contains('dependent-input') || node.classList.contains('dependent-output');
            const isFilteredGeneral = node.classList.contains('filtered-out-general');
            const isFilteredAxis = node.classList.contains('filtered-out-axis');
            const isSearchDimmed = node.classList.contains('search-dimmed'); 
            const isSearchHighlight = node.classList.contains('search-highlight'); 

            if (!isSelected && !isDependent && !isFilteredGeneral && !isFilteredAxis && !isSearchDimmed && !isSearchHighlight) {
                 node.classList.add('dimmed-selection');
            } else {
                node.classList.remove('dimmed-selection');
            }
        });
    }

    function displayProcessDetails(process) {
        if (document.body.classList.contains('presentation-mode')) {
            detailsPane.innerHTML = ''; 
            return;
        }

        if (!process) {
            const currentViewDesc = selectedSheetViews.length > 0 ? selectedSheetViews.join(', ') : 'None';
            detailsPane.innerHTML = `<h3>Process Details</h3><p>Process not found or no process selected in view: ${currentViewDesc} (${currentProcessTypeView} types).</p>`;
            updateAllDependencyAndSimShortcutButtonsState();
            return;
        }

        let html = `<h3>${process["Short name"]} (ID: ${process.ID})</h3>`;
        if (process._sourceSheet ) { 
             html += `<p><strong>Source Sheet:</strong> ${process._sourceSheet}</p>`;
        }
        
        const displayedKeys = new Set(["ID", "Short name", "_sourceSheet", "_sheetColorIndex"]); 

        allProcessFields.forEach(fieldInfo => {
            if (process.hasOwnProperty(fieldInfo.jsonKey) && !displayedKeys.has(fieldInfo.jsonKey)) {
                let value = process[fieldInfo.jsonKey];
                if (fieldInfo.jsonKey === "Description" && value) { 
                    value = String(value).replace(/\\n/g, '<br>');
                }
                html += `<p><strong>${fieldInfo.jsonKey}:</strong> ${value !== null && value !== undefined && String(value).toLowerCase() !== 'nan' ? value : 'N/A'}</p>`;
                displayedKeys.add(fieldInfo.jsonKey);
            }
        });

        for (const key in process) {
            if (!displayedKeys.has(key) && !key.startsWith('_')) { 
                let value = process[key];
                if (key === "Description" && value) { 
                    value = String(value).replace(/\\n/g, '<br>');
                }
                html += `<p><strong>${key}:</strong> ${value !== null && value !== undefined && String(value).toLowerCase() !== 'nan' ? value : 'N/A'}</p>`;
            }
        }
        
        html += `<button onclick="openEditModal('${process.ID}', '${process._sourceSheet || ''}')" style="margin-right: 10px;">Edit Process</button>`;
        html += `<button id="initiate-simulation-button" style="background-color: #ffc107; color: black;" title="Simulate the impact of removing or shifting this process">Simulate Impact</button>`;
        
        detailsPane.innerHTML = html; 
        updateAllDependencyAndSimShortcutButtonsState();

        const simButtonInstance = document.getElementById('initiate-simulation-button');
        if (simButtonInstance) {
            simButtonInstance.addEventListener('click', openSimulationPanelForSelectedProcess);
        }
    }

    function openSimulationPanelForSelectedProcess() { 
        if (!currentlySelectedProcessId) {
            showNotification("No process selected to simulate.", "warning");
            return;
        }
        
        const allProcs = getAllProcessesFromData(); 
        const targetProcess = allProcs.find(p => p.ID === currentlySelectedProcessId); 

        if (!targetProcess) {
            showNotification("Selected process data not found for simulation.", "error");
            return;
        }

        simulationTargetProcessId = targetProcess.ID;
        simulationTargetProcessSheet = targetProcess._sourceSheet; 

        simulationTargetNameSpan.textContent = targetProcess["Short name"];
        simulationTargetIdSpan.textContent = `ID: ${targetProcess.ID}`;
        
        activeSimulationTypeInput.value = "remove";
        currentSimulationType = "remove";
        simulationTypeSelectorGroup.querySelectorAll('.simulation-type-button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.simtype === "remove") btn.classList.add('active');
        });

        simulationShiftInputsDiv.style.display = 'none'; 
        simulationAddInputsDiv.style.display = 'none'; 
        undoSimulationParamsButton.style.display = 'none';

        simulationNewWdInput.value = targetProcess.WD !== undefined ? targetProcess.WD : '';
        simulationNewDueTimeInput.value = targetProcess["Due time"] || '';
        document.getElementById('error-simulation-new-wd').textContent = '';
        document.getElementById('error-simulation-new-due-time').textContent = '';
        storeCurrentSimulationParams();

        runSimulationButton.textContent = 'Run Simulation';
        runSimulationButton.disabled = false;
        endSimulationButton.style.display = 'none';
        exportSimulationReportButton.style.display = 'none'; 
        simulationImpactListContainer.innerHTML = ''; 

        populateScenarioSelector();

        toggleSimulationPanel(true);
        filterPanel.classList.remove('open');
        converterPanel.classList.remove('open');
        tutorialPanel.classList.remove('open');
        dependencyPanelContainer.classList.remove('visible');
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        if(isTreeHighlightActive) {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            renderDiagramAndRestoreState();
        }
    }


    function highlightDependencies(selectedProcess) {
        if (isSimulationModeActive) return; 
        if (!selectedProcess || !nodeLayouts[selectedProcess.ID]) return;
        
        const selectedId = selectedProcess.ID;
        const selectedNodeEl = diagramPane.querySelector(`.process-node[data-id="${selectedId}"]`);
        if (!selectedNodeEl) return;


        const currentVisibleProcesses = getCurrentlyVisibleProcesses(true);

        const inputRawEntries = (selectedProcess.Dependencies ? String(selectedProcess.Dependencies) : '').split(';').map(entry => entry.trim()).filter(entry => entry);
        inputRawEntries.forEach(rawDepEntry => {
            const { id: inputSourceId, type: depLinkType } = parseDependencyEntry(rawDepEntry);
            if (inputSourceId === selectedId) return; 

            const inputSourceNode = diagramPane.querySelector(`.process-node[data-id="${inputSourceId}"]`);
            if (inputSourceNode && 
                !inputSourceNode.classList.contains('filtered-out-general') &&
                !inputSourceNode.classList.contains('filtered-out-axis') &&
                !inputSourceNode.classList.contains('search-dimmed') &&
                !inputSourceNode.classList.contains('tree-highlight-dimmed'))
            {
                inputSourceNode.classList.remove('selected', 'dependent-output'); 
                inputSourceNode.classList.add('dependent-input');
                inputSourceNode.style.backgroundColor = configColors.inputProcess;
                inputSourceNode.style.borderColor = shadeColor(configColors.inputProcess, -0.3);
                inputSourceNode.style.boxShadow = '1px 1px 3px rgba(0,0,0,0.1)'; 

                let arrowColor = configColors.inputArrow;
                if (depLinkType === 'blocking') arrowColor = configColors.inputArrowBlocking;
                else if (depLinkType === 'informational') arrowColor = configColors.inputArrowInformational;

                drawArrow(inputSourceNode, selectedNodeEl, arrowColor, 'input-arrow', depLinkType);
            }
        });

        currentVisibleProcesses.forEach(proc => { 
            if (!proc.Dependencies || !nodeLayouts[proc.ID] || proc.ID === selectedId) return;

            const procDepRawEntries = String(proc.Dependencies).split(';').map(entry => entry.trim()).filter(entry => entry);
            procDepRawEntries.forEach(rawDepEntry => {
                const { id: depSourceIdInOther, type: depLinkType } = parseDependencyEntry(rawDepEntry);

                if (depSourceIdInOther === selectedId) { 
                    const outputTargetNode = diagramPane.querySelector(`.process-node[data-id="${proc.ID}"]`);
                    if (outputTargetNode && 
                        !outputTargetNode.classList.contains('filtered-out-general') &&
                        !outputTargetNode.classList.contains('filtered-out-axis') &&
                        !outputTargetNode.classList.contains('search-dimmed') &&
                        !outputTargetNode.classList.contains('tree-highlight-dimmed'))
                    {
                        outputTargetNode.classList.remove('selected', 'dependent-input'); 
                        outputTargetNode.classList.add('dependent-output');
                        outputTargetNode.style.backgroundColor = configColors.outputProcess;
                        outputTargetNode.style.borderColor = shadeColor(configColors.outputProcess, -0.3);
                        outputTargetNode.style.boxShadow = '1px 1px 3px rgba(0,0,0,0.1)';

                        let arrowColor = configColors.outputArrow;
                        if (depLinkType === 'blocking') arrowColor = configColors.outputArrowBlocking;
                        else if (depLinkType === 'informational') arrowColor = configColors.outputArrowInformational;

                        drawArrow(selectedNodeEl, outputTargetNode, arrowColor, 'output-arrow', depLinkType);
                    }
                }
            });
        });
    }


    function drawArrow(fromNode, toNode, color, arrowTypeClassesString, dependencyLinkType = 'standard', isImpactPath = false) { 
        if (!fromNode || !toNode ) return; 

        let fromLayout = nodeLayouts[fromNode.dataset.id];
        let toLayout = nodeLayouts[toNode.dataset.id];
        
        let x1, y1, x2, y2;

        if (fromNode.classList.contains('simulation-new-node') || (isSimulationModeActive && fromNode.dataset.id === simulationTargetProcessId && currentSimulationType === 'shift')) {
            const fromRect = fromNode.getBoundingClientRect(); 
            const diagramRect = diagramContainer.getBoundingClientRect();
            x1 = (fromRect.left - diagramRect.left + diagramContainer.scrollLeft + (fromRect.width / 2)) / currentZoom;
            y1 = (fromRect.top - diagramRect.top + diagramContainer.scrollTop + (fromRect.height / 2)) / currentZoom;
        } else if (fromLayout) {
            x1 = (fromLayout.finalX + fromLayout.width / 2);
            y1 = (fromLayout.finalY + fromLayout.height / 2);
        } else { 
            const fromRect = fromNode.getBoundingClientRect();
            const diagramRect = diagramContainer.getBoundingClientRect();
            x1 = (fromRect.left - diagramRect.left + diagramContainer.scrollLeft + (fromRect.width / 2)) / currentZoom;
            y1 = (fromRect.top - diagramRect.top + diagramContainer.scrollTop + (fromRect.height / 2)) / currentZoom;
        }
        
        if (toNode.classList.contains('simulation-new-node') || (isSimulationModeActive && toNode.dataset.id === simulationTargetProcessId && currentSimulationType === 'shift')) {
             const toRect = toNode.getBoundingClientRect();
             const diagramRect = diagramContainer.getBoundingClientRect();
             x2 = (toRect.left - diagramRect.left + diagramContainer.scrollLeft + (toRect.width / 2)) / currentZoom;
             y2 = (toRect.top - diagramRect.top + diagramContainer.scrollTop + (toRect.height / 2)) / currentZoom;
        } else if (toLayout) {
            x2 = (toLayout.finalX + toLayout.width / 2);
            y2 = (toLayout.finalY + toLayout.height / 2);
        } else { 
            const toRect = toNode.getBoundingClientRect();
            const diagramRect = diagramContainer.getBoundingClientRect();
            x2 = (toRect.left - diagramRect.left + diagramContainer.scrollLeft + (toRect.width / 2)) / currentZoom;
            y2 = (toRect.top - diagramRect.top + diagramContainer.scrollTop + (toRect.height / 2)) / currentZoom;
        }


        const line = document.createElementNS(SVG_NS, 'line');
        line.setAttribute('x1', x1); line.setAttribute('y1', y1);
        line.setAttribute('x2', x2); line.setAttribute('y2', y2);
        line.style.stroke = color;

        const classes = arrowTypeClassesString.split(' ').filter(c => c.trim() !== '');
        classes.forEach(cls => line.classList.add(cls));
        
        if (isImpactPath) {
            line.classList.add('simulation-impact-path-arrow');
        }


        if (dependencyLinkType === 'blocking' || dependencyLinkType === 'informational') {
            if (!classes.includes('simulation-arrow-broken')) { 
                 line.style.strokeDasharray = '5,5';
            }
        } else if (!classes.includes('simulation-arrow-broken')) {
            line.style.strokeDasharray = 'none';
        }


        let defs = svgLayer.querySelector('defs');
        if (!defs) { defs = document.createElementNS(SVG_NS, 'defs'); svgLayer.appendChild(defs); }

        const safeColorIdPart = color.replace(/[^a-zA-Z0-9]/g, '');
        const safeArrowTypeClassForId = classes.join('-') || 'default-arrow'; 
        const markerId = `arrowhead-${safeArrowTypeClassForId}-${dependencyLinkType}-${safeColorIdPart}${isImpactPath ? '-impact' : ''}`;


        let marker = defs.querySelector(`#${markerId}`);
        if (!marker) {
            marker = document.createElementNS(SVG_NS, 'marker');
            marker.setAttribute('id', markerId);
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '8'); 
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerUnits', 'strokeWidth'); 
            marker.setAttribute('markerWidth', isImpactPath ? '10' : '8');
            marker.setAttribute('markerHeight', isImpactPath ? '8' : '6');
            marker.setAttribute('orient', 'auto'); 
            const path = document.createElementNS(SVG_NS, 'path');
            path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); 
            path.style.fill = color;
            marker.appendChild(path);
                        defs.appendChild(marker);
        } else {
             marker.querySelector('path').style.fill = color; 
        }
        line.setAttribute('marker-end', `url(#${markerId})`);
        svgLayer.appendChild(line);

        if (!classes.includes('simulation-arrow-broken') && !isSimulationModeActive && !isImpactPath) { 
            const flowDot = document.createElementNS(SVG_NS, 'circle');
            flowDot.style.fill = color;
            flowDot.classList.add('flow-dot');
            const animateCx = document.createElementNS(SVG_NS, 'animate');
            animateCx.setAttribute('attributeName', 'cx');
            animateCx.setAttribute('values', `${x1};${x2}`); 
            animateCx.setAttribute('dur', '3.5s');
            animateCx.setAttribute('repeatCount', 'indefinite');
            const animateCy = document.createElementNS(SVG_NS, 'animate');
            animateCy.setAttribute('attributeName', 'cy');
            animateCy.setAttribute('values', `${y1};${y2}`); 
            animateCy.setAttribute('dur', '3.5s');
            animateCy.setAttribute('repeatCount', 'indefinite');
            const animateR = document.createElementNS(SVG_NS, 'animate');
            animateR.setAttribute('attributeName', 'r');
            animateR.setAttribute('values', '1.8;2.8;1.8'); 
            animateR.setAttribute('dur', '3.5s');
            animateR.setAttribute('repeatCount', 'indefinite');
            flowDot.appendChild(animateCx); flowDot.appendChild(animateCy); flowDot.appendChild(animateR);
            svgLayer.appendChild(flowDot);
        }
    }

    function populateFilterPanel() {
        filterOptionsContainer.innerHTML = '';
        const currentProcesses = getCurrentlyVisibleProcesses();
        if (currentProcesses.length === 0) {
            const currentViewDesc = selectedSheetViews.length > 0 ? selectedSheetViews.join(', ') : 'None';
            filterOptionsContainer.innerHTML = `<p>No data in view ${currentViewDesc} (${currentProcessTypeView} types) to filter.</p>`;
            return;
        }
        const filterableKeys = new Set();
        currentProcesses.forEach(process => { Object.keys(process).forEach(key => { if (!excludedFilterKeys.has(key) && key !== '_sourceSheet' && key !== '_sheetColorIndex') { filterableKeys.add(key); } }); });
        if (filterableKeys.size === 0) { filterOptionsContainer.innerHTML = '<p>No filterable fields found for current view.</p>'; return; }
        Array.from(filterableKeys).sort().forEach(key => {
            const group = document.createElement('div'); group.className = 'filter-item-group';
            const label = document.createElement('label'); label.htmlFor = `filter-${key}`; label.textContent = key + ':'; group.appendChild(label);
            if (key === "Due time") {
                const fromLabel = document.createElement('label'); fromLabel.textContent = "From:"; fromLabel.style.fontWeight = 'normal'; fromLabel.style.fontSize = '0.9em';
                const timeInputFrom = document.createElement('input'); timeInputFrom.type = "time"; timeInputFrom.id = `filter-${key}-from`; timeInputFrom.dataset.filterKey = key; timeInputFrom.step = 1; timeInputFrom.addEventListener('change', handleTemporaryFilterChange); group.appendChild(fromLabel); group.appendChild(timeInputFrom);
                const toLabel = document.createElement('label'); toLabel.textContent = "To:"; toLabel.style.fontWeight = 'normal'; toLabel.style.fontSize = '0.9em';
                const timeInputTo = document.createElement('input'); timeInputTo.type = "time"; timeInputTo.id = `filter-${key}-to`; timeInputTo.dataset.filterKey = key; timeInputTo.step = 1; timeInputTo.addEventListener('change', handleTemporaryFilterChange); group.appendChild(toLabel); group.appendChild(timeInputTo);
            } else {
                const uniqueValues = [...new Set( currentProcesses.flatMap(p => { const val = p[key]; if (multiSelectFilterKeys.has(key) && typeof val === 'string' && val.includes(';')) { return val.split(';').map(s => String(s).trim()).filter(s => s); } return val; }).filter(val => val !== null && val !== undefined && String(val).trim() !== '' && String(val).toLowerCase() !== 'nan') )].sort((a,b) => { if (key === "WD") return Number(a) - Number(b); return String(a).localeCompare(String(b)); });
                if (uniqueValues.length > 0) {
                    const select = document.createElement('select'); select.id = `filter-${key}`; select.dataset.filterKey = key;
                    if (multiSelectFilterKeys.has(key) || key === "Process Type") { select.multiple = true; }
                    const defaultOption = document.createElement('option'); defaultOption.value = ""; defaultOption.textContent = `All ${key}s`;
                    if (!select.multiple) select.appendChild(defaultOption);
                    uniqueValues.forEach(value => { const option = document.createElement('option'); option.value = value; option.textContent = value; select.appendChild(option); });
                    select.addEventListener('change', handleTemporaryFilterChange); group.appendChild(select);
                } else { group.appendChild(document.createTextNode('No unique values for this filter.')); }
            }
            filterOptionsContainer.appendChild(group);
        });
    }

    function handleTemporaryFilterChange(event) {
        const key = event.target.dataset.filterKey;
        if (key === "Due time") {
            const fromVal = document.getElementById(`filter-${key}-from`).value; const toVal = document.getElementById(`filter-${key}-to`).value;
            if (fromVal || toVal) { temporaryActiveFilters[key] = { from: fromVal || null, to: toVal || null }; } else { delete temporaryActiveFilters[key]; }
        } else if (event.target.multiple) {
            const selectedValues = Array.from(event.target.selectedOptions).map(opt => opt.value).filter(val => val !== "");
            if (selectedValues.length > 0) { temporaryActiveFilters[key] = selectedValues; } else { delete temporaryActiveFilters[key]; }
        } else {
            const value = event.target.value;
            if (value === "") { delete temporaryActiveFilters[key]; } else { temporaryActiveFilters[key] = value; }
        }
    }

    function applyGeneralFilters() {
        if (isSimulationModeActive) endSimulation();
        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        svgLayer.innerHTML = '';
        simulationGhostLayer.innerHTML = '';

        currentAppliedFilters = { ...temporaryActiveFilters };
        currentAxisFilter = { type: null, value: null, valueEnd: null }; 
        currentlySelectedProcessId = null; 

        resetVisualStates(); 
        renderDiagram(); 
        filterPanel.classList.remove('open');
        saveStateToLocalStorage();
    }

    function isProcessFilteredOutByGeneralFilters(process) {
        for (const key in currentAppliedFilters) {
            let processValue = process[key]; 
            let filterValue = currentAppliedFilters[key]; 

            if (processValue === null || processValue === undefined || String(processValue).toLowerCase() === 'nan') {
                processValue = ''; 
            }

            if (key === "Due time" && typeof filterValue === 'object' && filterValue !== null) {
                const processTimeSec = parseTime(String(processValue));
                if (isNaN(processTimeSec) && (filterValue.from || filterValue.to)) {
                    return true;
                }
                if (!filterValue.from && !filterValue.to) {
                    continue;
                }

                const filterFromSec = filterValue.from ? parseTime(filterValue.from) : -Infinity;
                const filterToSec = filterValue.to ? parseTime(filterValue.to) : Infinity;

                if (!(processTimeSec >= filterFromSec && processTimeSec <= filterToSec)) {
                    return true;
                }
            }
            else if (Array.isArray(filterValue)) {
                let actualProcessValuesForComparison;
                if (typeof processValue === 'string' && processValue.includes(';')) {
                    actualProcessValuesForComparison = processValue.split(';').map(s => String(s).trim()).filter(s => s); 
                } else {
                    actualProcessValuesForComparison = [String(processValue).trim()];
                }

                if (actualProcessValuesForComparison.length === 1 && actualProcessValuesForComparison[0] === '' && filterValue.length > 0 && !filterValue.includes('')) {
                    return true;
                }

                const matchFound = filterValue.some(fv_from_filter_array =>
                    actualProcessValuesForComparison.includes(String(fv_from_filter_array).trim())
                );

                if (!matchFound) {
                    return true;
                }
            }
            else {
                const normalizedProcessValue = String(processValue).trim();
                const normalizedFilterValue = String(filterValue).trim();

                if (normalizedProcessValue !== normalizedFilterValue) {
                    return true;
                }
            }
        }
        return false; 
    }

    function isProcessFilteredOutByAxisFilter(process) {
        if (!currentAxisFilter.type) return false;
        if (currentAxisFilter.type === 'WD') { return process.WD !== currentAxisFilter.value; }
        if (currentAxisFilter.type === 'TIME') {
            const processTimeSec = parseTime(process["Due time"]); if (isNaN(processTimeSec)) return true; 
            return !(processTimeSec >= currentAxisFilter.value && processTimeSec <= currentAxisFilter.valueEnd);
        }
        return false;
    }

    function handleAxisLabelClick(type, value) {
        if (isSimulationModeActive) endSimulation();
        isTreeHighlightActive = false; 
        highlightedTreeNodesIds.clear();
        svgLayer.innerHTML = ''; 
        simulationGhostLayer.innerHTML = '';

        if (currentlySelectedProcessId) { 
            clearSelectionHighlightsAndDimming();
            currentlySelectedProcessId = null;
            displayProcessDetails(null);
            hideActionIcons();
        }

        let previousAxisFilterType = currentAxisFilter.type; let previousAxisFilterValue = currentAxisFilter.value;
        if (currentAxisFilter.type === type && currentAxisFilter.value === value) {
            currentAxisFilter = { type: null, value: null, valueEnd: null }; 
        } else {
            if (type === 'TIME') {
                const hourStartSec = value; const hourEndSec = hourStartSec + (gTimeBinSizeSec > 0 ? gTimeBinSizeSec -1 : 3599) ; 
                currentAxisFilter = { type, value: hourStartSec, valueEnd: hourEndSec };
            } else { 
                currentAxisFilter = { type, value, valueEnd: null };
            }
        }
        if (currentAxisFilter.type !== previousAxisFilterType || currentAxisFilter.value !== previousAxisFilterValue) {
            temporaryActiveFilters = {}; currentAppliedFilters = {};
            if (filterOptionsContainer) { filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(input => { if (input.tagName === 'SELECT' && input.multiple) { Array.from(input.options).forEach(option => option.selected = false); } else { input.value = ""; } }); }
        }
        renderDiagram(); 
        saveStateToLocalStorage();
    }

    function openAddModal() {
        if (isSimulationModeActive) endSimulation();
        if (selectedSheetViews.length !== 1) {
            showNotification("Please select exactly one sheet from the 'Sheets' dropdown to add a process.", "warning");
            return;
        }
        const targetSheet = selectedSheetViews[0];
        modalTitle.textContent = `Add New Process to Sheet: ${targetSheet}`;
        document.getElementById('process-edit-id').value = ''; 
        // MODIFICATION: Store original sheet in a data attribute for internal logic
        document.getElementById('process-edit-id').dataset.originalSheet = targetSheet; 

        // MODIFICATION START: Populate and set sheet selector
        const targetSheetSelector = document.getElementById('process-target-sheet-modal');
        targetSheetSelector.innerHTML = ''; // Clear previous options
        allDataSourceSheetNames.forEach(sheetName => {
            const option = document.createElement('option');
            option.value = sheetName;
            option.textContent = sheetName;
            targetSheetSelector.appendChild(option);
        });
        targetSheetSelector.value = targetSheet; // Pre-select current sheet
        document.getElementById('error-process-target-sheet-modal').textContent = '';
        // MODIFICATION END

        dynamicFieldsContainer.innerHTML = ''; clearModalValidationErrors();
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`);
            if (el) {
                el.value = ''; el.readOnly = false; 
                if (f.jsonKey === "ID") { el.value = `PROC_${Date.now()}`; } 
                if (f.jsonKey === "WD" && f.type === "number") el.value = '0'; 
                if (f.jsonKey === "Due time" && f.type === "custom-time") el.value = '00:00:00'; 
                if (f.jsonKey === "Process Type" && el.tagName === 'SELECT') el.value = f.default || 'standard';
            }
        });
        deleteProcessButton.style.display = 'none'; modal.style.display = 'block';
    }

    function openEditModal(processId, sourceSheetHint) {
        if (isSimulationModeActive) endSimulation();
        let process; let actualSourceSheet = sourceSheetHint;

        if (!actualSourceSheet || actualSourceSheet === 'Multiple' || !processesData[actualSourceSheet]) {
            for (const sheetName of allDataSourceSheetNames) { 
                if (processesData[sheetName]) {
                    const found = processesData[sheetName].find(p => p.ID === processId);
                    if (found) { process = found; actualSourceSheet = sheetName; break; }
                }
            }
        } else if (processesData[actualSourceSheet]) { 
            process = processesData[actualSourceSheet].find(p => p.ID === processId);
        }

        if (!process || !actualSourceSheet) { showNotification(`Process ID ${processId} not found for editing.`, 'error'); return; }

        modalTitle.textContent = `Edit Process (Original Sheet: ${actualSourceSheet})`;
        document.getElementById('process-edit-id').value = process.ID;
        // MODIFICATION: Store original sheet in a data attribute
        document.getElementById('process-edit-id').dataset.originalSheet = actualSourceSheet; 
        
        // MODIFICATION START: Populate and set sheet selector
        const targetSheetSelector = document.getElementById('process-target-sheet-modal');
        targetSheetSelector.innerHTML = ''; // Clear previous options
        allDataSourceSheetNames.forEach(sheetName => {
            const option = document.createElement('option');
            option.value = sheetName;
            option.textContent = sheetName;
            targetSheetSelector.appendChild(option);
        });
        targetSheetSelector.value = actualSourceSheet; // Pre-select current sheet
        document.getElementById('error-process-target-sheet-modal').textContent = '';
        // MODIFICATION END

        dynamicFieldsContainer.innerHTML = ''; clearModalValidationErrors();
        const handledKeys = new Set();
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`);
            if (el) { const key = f.jsonKey; let value = process[key];
                if (key === "Description") { el.value = value ? String(value).replace(/\\n/g, '\n') : ''; }
                else if (key === "Process Type" && el.tagName === 'SELECT') { el.value = value || f.default || 'standard'; }
                else { el.value = value === 'nan' ? '' : (value === null || value === undefined ? '' : value); }
                // ID is now editable in edit mode as well, if they change sheet, ID might need to change too.
                // el.readOnly = !!f.readOnlyEdit; // Keep ID editable
                handledKeys.add(key);
            }
        });
        Object.keys(process).forEach(key => {
            if (!handledKeys.has(key) && key !== '_sourceSheet' && key !== '_sheetColorIndex') {
                const value = process[key]; const fieldContainer = document.createElement('div'); const label = document.createElement('label'); label.textContent = `${key}:`; label.htmlFor = `dynamic-field-${key}`;
                let inputElement;
                if (key === "Description" || (typeof value === 'string' && value.length > 60)) { inputElement = document.createElement('textarea'); inputElement.value = value ? String(value).replace(/\\n/g, '\n') : ''; inputElement.rows = 3; }
                else { inputElement = document.createElement('input'); inputElement.type = 'text'; inputElement.value = value === 'nan' ? '' : (value === null || value === undefined ? '' : value); }
                inputElement.id = `dynamic-field-${key}`; inputElement.dataset.dynamicKey = key;
                const errorSpan = document.createElement('span'); errorSpan.className = 'error-message'; errorSpan.id = `error-dynamic-field-${key}`;
                fieldContainer.appendChild(label); fieldContainer.appendChild(inputElement); fieldContainer.appendChild(errorSpan); dynamicFieldsContainer.appendChild(fieldContainer);
            }
        });
        deleteProcessButton.style.display = 'inline-block'; modal.style.display = 'block';
    }

    function closeModal() {
        modal.style.display = 'none'; clearModalValidationErrors();
    }

    function clearModalValidationErrors() {
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`); const errorEl = document.getElementById(`error-process-${f.idSuffix}`);
           if (el) el.classList.remove('invalid'); if (errorEl) errorEl.textContent = '';
        });
        // MODIFICATION: Clear error for target sheet selector
        const targetSheetErrorEl = document.getElementById('error-process-target-sheet-modal');
        if (targetSheetErrorEl) targetSheetErrorEl.textContent = '';
        const targetSheetSelectEl = document.getElementById('process-target-sheet-modal');
        if (targetSheetSelectEl) targetSheetSelectEl.classList.remove('invalid');

        dynamicFieldsContainer.querySelectorAll('input, textarea, select').forEach(el => { 
            el.classList.remove('invalid'); 
            const errorEl = document.getElementById(`error-${el.id}`); 
            if(errorEl) errorEl.textContent = ''; 
        });
    }

    function validateProcessForm(isEditMode) {
        clearModalValidationErrors(); let isValid = true;
        
        // MODIFICATION: Get selected target sheet for validation
        const targetSheetSelector = document.getElementById('process-target-sheet-modal');
        const targetSheetForValidation = targetSheetSelector.value;
        const targetSheetErrorEl = document.getElementById('error-process-target-sheet-modal');

        const originalSheetForEdit = isEditMode ? document.getElementById('process-edit-id').dataset.originalSheet : null;
        const currentIdBeingEdited = isEditMode ? document.getElementById('process-id-modal').value.trim() : null; // Get the ID from the form for edits

        if (!targetSheetForValidation) { 
            targetSheetErrorEl.textContent = "Target sheet is required.";
            targetSheetSelector.classList.add('invalid');
            isValid = false;
        }


        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`); const errorEl = document.getElementById(`error-process-${f.idSuffix}`); if (!el || !errorEl) return;
            let value = el.value; 
            if (el.type !== "select-one" && f.type !== "textarea") value = value.trim(); 
            
            if (f.required && (value === null || value === undefined || String(value).trim() === '') && !(f.jsonKey === "WD" && value === "0") ) { 
                errorEl.textContent = `${f.jsonKey} is required.`; el.classList.add('invalid'); isValid = false; return; 
            }

            if (f.jsonKey === "ID") {
                const idValue = value.trim();
                if (!/^[a-zA-Z0-9._-]+$/.test(idValue)) { errorEl.textContent = "ID can only contain letters, numbers, '.', '_', '-'."; el.classList.add('invalid'); isValid = false; }
                else if (processesData[targetSheetForValidation]) { 
                    // Check for ID uniqueness in the *target* sheet.
                    // If editing and the sheet hasn't changed, allow the same ID.
                    // If editing and the sheet *has* changed, the ID must be unique in the new sheet.
                    // If adding, ID must be unique in the target sheet.
                    let idIsDuplicate = false;
                    if (isEditMode) {
                        // If sheet changed OR ID changed, check for duplication in new target sheet
                        if (targetSheetForValidation !== originalSheetForEdit || idValue !== document.getElementById('process-edit-id').value.trim()) {
                             idIsDuplicate = processesData[targetSheetForValidation].some(p => p.ID === idValue);
                        }
                    } else { // Add mode
                        idIsDuplicate = processesData[targetSheetForValidation].some(p => p.ID === idValue);
                    }

                    if (idIsDuplicate) { 
                        errorEl.textContent = `ID "${idValue}" already exists in sheet '${targetSheetForValidation}'. Choose a unique ID for this sheet.`; 
                        el.classList.add('invalid'); isValid = false; 
                    }
                }
            }
            if (f.jsonKey === "WD" && value !== '' && isNaN(parseInt(value, 10))) { errorEl.textContent = "WD must be a valid number."; el.classList.add('invalid'); isValid = false; }
            if (f.jsonKey === "Due time") {
                if (value && !/^\d{1,2}:\d{2}(:\d{2})?$/.test(value)) { errorEl.textContent = "Due time format must be HH:MM or HH:MM:SS."; el.classList.add('invalid'); isValid = false; }
                else if (value) { const tempTime = value.includes(':') && value.split(':').length === 2 ? value + ":00" : value; const parsed = parseTime(tempTime); if (isNaN(parsed)) { errorEl.textContent = "Due time is not a valid time (00:00:00 - 23:59:59)."; el.classList.add('invalid'); isValid = false; } }
            }
            if (f.jsonKey === "Dependencies" && value) {
                const depEntries = value.split(';').map(entry => entry.trim()).filter(entry => entry);
                if (depEntries.some(entry => {
                    const parsed = parseDependencyEntry(entry); 
                    return !/^[a-zA-Z0-9._-]+$/.test(parsed.id); 
                })) {
                    errorEl.textContent = "Dependency IDs (before _B or _I) can only contain letters, numbers, '.', '_', '-'. Separate with semicolons."; el.classList.add('invalid'); isValid = false;
                }
            }
            if (f.jsonKey === "Process Type" && el.tagName === 'SELECT' && !f.options.includes(value)) { 
                 errorEl.textContent = "Invalid Process Type selected."; el.classList.add('invalid'); isValid = false;
            }
        });
        return isValid;
    }


    function saveProcess() {
        const originalProcessIdForEdit = document.getElementById('process-edit-id').value; // This is the ID *before* potential form changes
        const originalSourceSheet = document.getElementById('process-edit-id').dataset.originalSheet;
        const isEditMode = !!originalProcessIdForEdit;

        // MODIFICATION: Get the target sheet from the selector
        const newTargetSheet = document.getElementById('process-target-sheet-modal').value;
        const newProcessIdFromForm = document.getElementById('process-id-modal').value.trim();


        if (!newTargetSheet) { showNotification("Cannot save process: Target sheet is not selected.", 'error'); return; }
        if (!validateProcessForm(isEditMode)) return; 

        const newProcessData = {}; const processedKeys = new Set();
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`);
            if (el) { const key = f.jsonKey; let val = el.value;
                if (f.type !== "textarea" && f.type !== "custom-time" && el.type !== "select-one") val = val.trim(); 

                if (f.type === "number" && key === "WD") { val = val === '' ? 0 : parseInt(val, 10); } 
                else if (f.type === "custom-time" && key === "Due time") { if (val && val.includes(':') && val.split(':').length === 2) val += ":00"; } 
                else if (key === "Description") { val = String(val).replace(/\r\n|\r|\n/g, '\\n'); } 
                else if (key === "Process Type" && el.tagName === 'SELECT') { /* val is already correct from el.value */ }
                else { val = val === '' ? '' : val; } 
                newProcessData[key] = val; processedKeys.add(key);
            }
        });
        if (typeof newProcessData.WD !== 'number' || isNaN(newProcessData.WD)) newProcessData.WD = 0;
        if (!newProcessData["Process Type"]) newProcessData["Process Type"] = "standard"; 
        newProcessData.ID = newProcessIdFromForm; // Ensure ID is from the (potentially edited) form field

        dynamicFieldsContainer.querySelectorAll('[data-dynamic-key]').forEach(el => {
             const key = el.dataset.dynamicKey; let value = el.value;
              if (el.tagName === 'TEXTAREA' && key === 'Description') { value = String(value).replace(/\r\n|\r|\n/g, '\\n'); }
              else { value = value.trim(); } 
             newProcessData[key] = value === '' ? '' : value; processedKeys.add(key);
        });
        
        let processSuccessfullyMovedOrAdded = false;

        if (isEditMode) { 
            if (originalSourceSheet && processesData[originalSourceSheet]) {
                const originalIndex = processesData[originalSourceSheet].findIndex(p => p.ID === originalProcessIdForEdit);
                if (originalIndex > -1) {
                    const originalProcessObject = processesData[originalSourceSheet][originalIndex];
                     Object.keys(originalProcessObject).forEach(key => { if (!processedKeys.has(key)) newProcessData[key] = originalProcessObject[key]; }); 
                    
                    if (originalSourceSheet !== newTargetSheet) {
                        // Remove from original sheet
                        processesData[originalSourceSheet].splice(originalIndex, 1);
                        // Add to new sheet
                        if (!processesData[newTargetSheet]) processesData[newTargetSheet] = [];
                        processesData[newTargetSheet].push(newProcessData);
                        processSuccessfullyMovedOrAdded = true;
                         showNotification(`Process "${newProcessData["Short name"] || newProcessData.ID}" moved from sheet "${originalSourceSheet}" to "${newTargetSheet}" and updated.`, 'success');
                    } else {
                        // Update in the same sheet
                        processesData[originalSourceSheet][originalIndex] = newProcessData;
                        processSuccessfullyMovedOrAdded = true;
                        showNotification(`Process "${newProcessData["Short name"] || newProcessData.ID}" updated in sheet "${newTargetSheet}".`, 'success');
                    }
                } else { showNotification("Error: Process to edit not found in original sheet.", 'error'); return; }
            } else { showNotification("Error: Original sheet not found for editing.", 'error'); return; }
        } else { // Add mode
            if (!processesData[newTargetSheet]) processesData[newTargetSheet] = []; 
            processesData[newTargetSheet].push(newProcessData);
            processSuccessfullyMovedOrAdded = true;
            showNotification(`Process "${newProcessData["Short name"] || newProcessData.ID}" added to sheet "${newTargetSheet}" successfully.`, 'success');
        }
        
        if (processSuccessfullyMovedOrAdded) {
            // Ensure currentlySelectedProcessId is updated if the ID changed or if it was an add operation
            if (!isEditMode || (isEditMode && originalProcessIdForEdit !== newProcessData.ID) || (isEditMode && originalSourceSheet !== newTargetSheet)) {
                 currentlySelectedProcessId = newProcessData.ID; // Select the newly added/moved/ID-changed process
            }

            updateGlobalUniqueDueTimeHours(); 
            populateFilterPanel(); 
            renderDiagramAndRestoreState(); // This will re-render with new data
            closeModal(); 
            saveStateToLocalStorage();
        }
    }

    function deleteCurrentProcess() {
        const editId = document.getElementById('process-edit-id').value;
        // MODIFICATION: Use originalSheet from data attribute for deletion
        const sourceSheet = document.getElementById('process-edit-id').dataset.originalSheet; 
        if (editId && sourceSheet && confirm(`Delete process with ID: ${editId} from sheet ${sourceSheet}?`)) {
            if (processesData[sourceSheet]) { processesData[sourceSheet] = processesData[sourceSheet].filter(p => p.ID !== editId); }
            updateGlobalUniqueDueTimeHours(); populateFilterPanel(); fullReset(); closeModal(); saveStateToLocalStorage();
            showNotification(`Process "${editId}" deleted.`, 'info');
        }
    }

    function sanitizeSheetNameForExcel(name) {
        if (!name) return "Sheet"; let sanitized = String(name).replace(/[:\\/?*[\]]/g, '_'); if (sanitized.length > 31) { sanitized = sanitized.substring(0, 31); } return sanitized;
    }

    function exportToXlsx() {
        menuContent.style.display = 'none';
        if (Object.keys(processesData).length === 0) { showNotification("No data loaded to export.", 'warning'); return; }
        const workbook = XLSX.utils.book_new(); let sheetsExported = 0;
        for (const sheetName in processesData) {
            if (processesData.hasOwnProperty(sheetName) && Array.isArray(processesData[sheetName])) {
                const sheetData = processesData[sheetName]; if (sheetData.length === 0) { continue; }
                const dataForSheetExport = sheetData.map(p => { const { _sourceSheet, _sheetColorIndex, ...exportedProcess } = p; if (exportedProcess.Description && typeof exportedProcess.Description === 'string') { exportedProcess.Description = exportedProcess.Description.replace(/\\n/g, '\n'); } if (typeof exportedProcess.WD !== 'number') { const wdNum = parseInt(exportedProcess.WD, 10); exportedProcess.WD = isNaN(wdNum) ? 0 : wdNum; } return exportedProcess; });
                const explicitHeaderOrder = allProcessFields.map(field => field.jsonKey); const allUniqueKeysInSheetData = Array.from(new Set(dataForSheetExport.flatMap(obj => Object.keys(obj)))); const existingExplicitHeaders = explicitHeaderOrder.filter(h => allUniqueKeysInSheetData.includes(h)); const finalHeaders = [ ...existingExplicitHeaders, ...allUniqueKeysInSheetData.filter(k => !existingExplicitHeaders.includes(k)).sort() ];
                let worksheet; if (dataForSheetExport.length > 0 && finalHeaders.length > 0) { worksheet = XLSX.utils.json_to_sheet(dataForSheetExport, { header: finalHeaders }); } else { worksheet = XLSX.utils.json_to_sheet(dataForSheetExport); } 
                XLSX.utils.book_append_sheet(workbook, worksheet, sanitizeSheetNameForExcel(sheetName)); sheetsExported++;
            }
        }
        if (sheetsExported === 0) { showNotification("No valid sheets with data found to export.", 'warning'); return; }
        let baseFilename = "processes_export_multisheet"; if (jsonFileNameSpan.textContent) { baseFilename = jsonFileNameSpan.textContent.replace(/\.json$/i, '').replace(/\.xlsx$/i, '') + "_export"; }
        XLSX.writeFile(workbook, `${sanitizeSheetNameForExcel(baseFilename)}.xlsx`);
        showNotification("XLSX file exported.", 'success');
    }

    let isPanning = false; let panStartX=0, panStartY=0; let initialScrollLeft=0, initialScrollTop=0;
    diagramContainer.addEventListener('mousedown', (e) => {
        if (e.target === diagramContainer || e.target === diagramPane || e.target === svgLayer) {
            if (e.target.closest('#mini-map-viewport-rect') || e.target.closest('.mini-map-node') ||
                e.target === menuDependencyPanelTrigger || menuDependencyPanelTrigger.contains(e.target) ||
                e.target === linkHandleTrigger || e.target.classList.contains('unlink-handle') ||
                e.target.closest('.process-node') || e.target.closest('.axis')) { 
                return; 
            }
            isPanning = true; diagramContainer.style.cursor = 'grabbing'; 
            panStartX = e.pageX - diagramContainer.offsetLeft; 
            panStartY = e.pageY - diagramContainer.offsetTop; 
            initialScrollLeft = diagramContainer.scrollLeft; 
            initialScrollTop = diagramContainer.scrollTop; 
            e.preventDefault();
        }
    });
    diagramContainer.addEventListener('mousemove', (e) => {
        if (!isPanning || isLinking) return; e.preventDefault(); const x = e.pageX - diagramContainer.offsetLeft; const y = e.pageY - diagramContainer.offsetTop; const dx = x - panStartX; const dy = y - panStartY; diagramContainer.scrollLeft = initialScrollLeft - dx; diagramContainer.scrollTop = initialScrollTop - dy;
    });

    function zoom(factor, event = null) {
        const prevZoom = currentZoom;
        currentZoom = Math.max(0.1, Math.min(5, currentZoom * factor));

        let rect;
        if (document.body.classList.contains('presentation-mode')) {
            rect = { top: topBarHeight, left: 0, width: window.innerWidth, height: window.innerHeight - topBarHeight };
        } else {
            rect = diagramContainer.getBoundingClientRect();
        }

        let mouseX = rect.width / 2;
        let mouseY = rect.height / 2;
        if (event && (event.target === diagramContainer || diagramContainer.contains(event.target))) {
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;
        }

        const scrollX = diagramContainer.scrollLeft;
        const scrollY = diagramContainer.scrollTop;

        const targetScrollLeft = (scrollX + mouseX) * (currentZoom / prevZoom) - mouseX;
        const targetScrollTop = (scrollY + mouseY) * (currentZoom / prevZoom) - mouseY;

        diagramPane.style.transform = `scale(${currentZoom})`;
        diagramContainer.scrollLeft = targetScrollLeft;
        diagramContainer.scrollTop = targetScrollTop;

        requestAnimationFrame(() => {
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap(); 
            updateMiniMapViewPort(); 
            positionActionIcons(); 
        });

        saveStateToLocalStorage();
    }

async function convertXlsxFileToStructuredJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = new Uint8Array(event.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                
                const validationResult = validateXlsxWorkbook(workbook, expectedDiagramKeys, XLSX_REQUIRED_KEYS);
                if (!validationResult.isValid) {
                    const errorMsg = "XLSX Validation Failed:\n" + validationResult.errors.join("\n");
                    reject({ message: errorMsg, warnings: validationResult.warnings, isValidationError: true });
                    return;
                }
                if (validationResult.warnings.length > 0) {
                    console.warn("XLSX Validation Warnings:", validationResult.warnings);
                }

                const multiSheetJsonData = {};
                let firstSheetDataForPreview = null;

                workbook.SheetNames.forEach((sheetName, index) => {
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonDataFromSheet = XLSX.utils.sheet_to_json(worksheet, { defval: null });

                    if (jsonDataFromSheet.length === 0) {
                        multiSheetJsonData[sheetName] = [];
                        return;
                    }

                    const processedSheetJson = jsonDataFromSheet.map(rowFromSheet => {
                        const newRowObject = {};
                        const excelHeadersInRow = Object.keys(rowFromSheet);

                        expectedDiagramKeys.forEach(expectedKey => {
                            let actualExcelHeader = expectedKey;
                            if (!rowFromSheet.hasOwnProperty(actualExcelHeader)) {
                                const foundHeader = excelHeadersInRow.find(h => h.trim().toLowerCase() === expectedKey.toLowerCase());
                                if (foundHeader) actualExcelHeader = foundHeader;
                            }
                            if (expectedKey === "Due time" && !rowFromSheet.hasOwnProperty(actualExcelHeader)) {
                                 const dueTimeHeaders = ["Due time", "Due Time", "due time"];
                                 for (const dth of dueTimeHeaders) {
                                    if (rowFromSheet.hasOwnProperty(dth)) { actualExcelHeader = dth; break; }
                                    const foundDth = excelHeadersInRow.find(h => h.trim().toLowerCase() === dth.toLowerCase());
                                    if (foundDth) { actualExcelHeader = foundDth; break;}
                                 }
                            }

                            let originalValue = rowFromSheet[actualExcelHeader];
                            let processedValue;

                            if (originalValue === null || originalValue === undefined || String(originalValue).trim() === "") {
                                processedValue = (expectedKey === "WD") ? 0 : "";
                                if (expectedKey === "Due time") processedValue = "";
                                if (expectedKey === "Process Type") processedValue = "standard";
                            } else if (expectedKey === "Due time") {
                                let timeStr = String(originalValue).trim();
                                if (typeof originalValue === 'number' && originalValue >= 0 && originalValue < 1) {
                                    const excelEpoch = new Date(Date.UTC(1899, 11, 30)); 
                                    const dateFromExcel = new Date(excelEpoch.getTime() + originalValue * 24 * 60 * 60 * 1000);
                                    const hours = dateFromExcel.getUTCHours();
                                    const minutes = dateFromExcel.getUTCMinutes();
                                    const seconds = dateFromExcel.getUTCSeconds();
                                    processedValue = String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
                                } else if (/^(\d{1,2}):(\d{2})(:(\d{2}))?$/.test(timeStr)) {
                                    const parts = timeStr.match(/^(\d{1,2}):(\d{2})(:(\d{2}))?$/);
                                                                        const h = String(parts[1]).padStart(2, '0');
                                    const m = String(parts[2]).padStart(2, '0');
                                    const s = parts[4] ? String(parts[4]).padStart(2, '0') : '00';
                                    processedValue = `${h}:${m}:${s}`;
                                } else {
                                    processedValue = "";
                                }
                            } else if (expectedKey === "Description") {
                                processedValue = String(originalValue).replace(/\r\n|\r|\n/g, '\\n');
                            } else if (expectedKey === "WD") {
                                const numWD = parseInt(String(originalValue), 10);
                                processedValue = isNaN(numWD) ? 0 : numWD;
                            } else if (expectedKey === "Process Type") {
                                let ptValue = String(originalValue).trim().toLowerCase();
                                if (["standard", "blocking", "informational"].includes(ptValue)) {
                                    processedValue = ptValue;
                                } else {
                                    processedValue = "standard";
                                }
                            }
                             else {
                                processedValue = String(originalValue).trim();
                            }
                            newRowObject[expectedKey] = processedValue;
                        });

                        if (!newRowObject.hasOwnProperty("Process Type")) {
                            newRowObject["Process Type"] = "standard";
                        }

                        excelHeadersInRow.forEach(excelHeader => {
                            if (excelHeader.startsWith("__EMPTY")) return;
                            const trimmedExcelHeader = excelHeader.trim();
                            let isExpectedAlready = expectedDiagramKeys.some(ek => ek.toLowerCase() === trimmedExcelHeader.toLowerCase());
                            
                            if (!isExpectedAlready && !newRowObject.hasOwnProperty(trimmedExcelHeader)) {
                                const originalValue = rowFromSheet[excelHeader];
                                let processedValue;
                                if (originalValue === null || originalValue === undefined || String(originalValue).trim() === "") {
                                    processedValue = "";
                                } else {
                                    processedValue = String(originalValue).trim();
                                }
                                newRowObject[trimmedExcelHeader] = processedValue;
                            }
                        });
                        return newRowObject;
                    });
                    multiSheetJsonData[sheetName] = processedSheetJson;
                    if (index === 0) {
                        firstSheetDataForPreview = processedSheetJson;
                    }
                });
                resolve({ multiSheetJsonData, firstSheetDataForPreview, warnings: validationResult.warnings });
            } catch (error) {
                reject(error); 
            }
        };
        reader.onerror = (error) => reject(error);
        reader.readAsArrayBuffer(file);
    });
}

function validateXlsxWorkbook(workbook, allExpectedKeys, requiredKeysSet) {
    let errors = [];
    let warnings = [];
    let isValid = true;

    workbook.SheetNames.forEach(sheetName => {
        const worksheet = workbook.Sheets[sheetName];
        const jsonDataFromSheet = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null }); 

        if (!jsonDataFromSheet || jsonDataFromSheet.length === 0) {
            warnings.push(`Sheet "${sheetName}" is empty or unreadable.`);
            return; 
        }

        const headerRow = jsonDataFromSheet[0].map(h => String(h || "").trim());
        const headerRowLower = headerRow.map(h => h.toLowerCase());
        const dataRows = jsonDataFromSheet.slice(1);

        requiredKeysSet.forEach(reqKey => {
            if (!headerRowLower.includes(reqKey.toLowerCase())) {
                errors.push(`Sheet "${sheetName}": Missing required column: "${reqKey}".`);
                isValid = false;
            }
        });

        allExpectedKeys.forEach(expKey => {
            if (!requiredKeysSet.has(expKey) && !headerRowLower.includes(expKey.toLowerCase())) {
                warnings.push(`Sheet "${sheetName}": Missing optional column: "${expKey}".`);
            }
        });

        if (dataRows.length > 0) {
            const sampleSize = Math.min(dataRows.length, XLSX_KEY_VALIDATION_SAMPLES);
            for (let i = 0; i < sampleSize; i++) {
                const rowArray = dataRows[i];
                const rowObject = {};
                headerRow.forEach((header, idx) => {
                    rowObject[header] = rowArray[idx];
                });

                const idHeader = headerRow.find(h => h.toLowerCase() === "id");
                if (idHeader && (rowObject[idHeader] === null || String(rowObject[idHeader]).trim() === "")) {
                    errors.push(`Sheet "${sheetName}", Row ${i + 2}: Column "ID" cannot be empty.`);
                    isValid = false;
                }

                const wdHeader = headerRow.find(h => h.toLowerCase() === "wd");
                if (wdHeader && rowObject[wdHeader] !== null && isNaN(parseInt(rowObject[wdHeader], 10))) {
                    errors.push(`Sheet "${sheetName}", Row ${i + 2}: Column "WD" ("${rowObject[wdHeader]}") is not a valid number.`);
                    isValid = false;
                }
                
                const dueTimeHeader = headerRow.find(h => h.toLowerCase() === "due time");
                if (dueTimeHeader && rowObject[dueTimeHeader] !== null && String(rowObject[dueTimeHeader]).trim() !== "") {
                    let timeStr = String(rowObject[dueTimeHeader]).trim();
                    let validTimeFormat = false;
                    if (typeof rowObject[dueTimeHeader] === 'number' && rowObject[dueTimeHeader] >= 0 && rowObject[dueTimeHeader] < 1) {
                       validTimeFormat = true; 
                    } else if (/^(\d{1,2}):(\d{2})(:(\d{2}))?$/.test(timeStr)) {
                       validTimeFormat = true; 
                    }
                    if (!validTimeFormat) {
                         errors.push(`Sheet "${sheetName}", Row ${i + 2}: Column "Due time" ("${timeStr}") has an unrecognized format. Expected HH:MM:SS or Excel time number.`);
                         isValid = false;
                    }
                }
            }
        }
    });
    return { isValid, errors, warnings };
}

async function handleConvertXlsxToJson() {
    menuContent.style.display = 'none';
    if (!xlsxFileInputConverter.files || xlsxFileInputConverter.files.length === 0) {
        converterStatusDiv.textContent = 'Please select an XLSX file.';
        converterStatusDiv.style.color = 'red';
        showNotification("Please select an XLSX file for conversion.", "warning");
        return;
    }
    const file = xlsxFileInputConverter.files[0];
    converterStatusDiv.innerHTML = 'Processing file for download...'; 
    converterStatusDiv.style.color = 'orange';
    convertButtonConverter.disabled = true;
    convertAndLoadButtonConverter.disabled = true;
    converterJsonPreview.textContent = '';

    try {
        const { multiSheetJsonData, firstSheetDataForPreview, warnings } = await convertXlsxFileToStructuredJson(file);

        let statusMessage = "";
        if (warnings && warnings.length > 0) {
            statusMessage += "<strong>Validation Warnings:</strong><br><pre>" + warnings.join("\n") + "</pre><br>";
        }

        if (Object.keys(multiSheetJsonData).length === 0) {
            statusMessage += 'No data found in any sheets.';
            converterStatusDiv.innerHTML = statusMessage;
            converterStatusDiv.style.color = 'red';
            showNotification("XLSX Conversion: No data found in any sheets.", "error");
            return;
        }

        const jsonString = JSON.stringify(multiSheetJsonData, null, 2);
        downloadJson(jsonString, 'processes_multisheet_converted.json');
        statusMessage += 'Conversion complete! Multi-sheet JSON downloaded.';
        converterStatusDiv.innerHTML = statusMessage;
        converterStatusDiv.style.color = 'green';
        showNotification("XLSX converted and JSON downloaded.", "success");
        if (firstSheetDataForPreview) {
             converterJsonPreview.textContent = JSON.stringify(firstSheetDataForPreview.slice(0, 3), null, 2);
        }
    } catch (error) {
        let errorMessageToShow = error.message || "An unknown error occurred during conversion.";
        if (error.isValidationError && error.warnings && error.warnings.length > 0) {
             errorMessageToShow += "\n\nAdditionally, there were warnings:\n" + error.warnings.join("\n");
        }
        converterStatusDiv.innerHTML = `<strong>Error:</strong><br><pre>${errorMessageToShow}</pre>`;
        converterStatusDiv.style.color = 'red';
        showNotification("Error during XLSX conversion. See converter panel for details.", "error", 0);
    } finally {
        convertButtonConverter.disabled = false;
        convertAndLoadButtonConverter.disabled = false;
        if (xlsxFileInputConverter) { xlsxFileInputConverter.value = null; }
    }
}

async function handleConvertAndLoadXlsxToDiagram() {
    if (isSimulationModeActive) endSimulation();
    menuContent.style.display = 'none';
    if (!xlsxFileInputConverter.files || xlsxFileInputConverter.files.length === 0) {
        converterStatusDiv.textContent = 'Please select an XLSX file to load.';
        converterStatusDiv.style.color = 'red';
        showNotification("Please select an XLSX file to convert and load.", "warning");
        return;
    }
    const file = xlsxFileInputConverter.files[0];
    converterStatusDiv.innerHTML = 'Processing and loading file to diagram...';
    converterStatusDiv.style.color = 'orange';
    convertButtonConverter.disabled = true;
    convertAndLoadButtonConverter.disabled = true;
    converterJsonPreview.textContent = '';

    try {
        const { multiSheetJsonData, firstSheetDataForPreview, warnings } = await convertXlsxFileToStructuredJson(file);

        let statusMessage = "";
        if (warnings && warnings.length > 0) {
            statusMessage += "<strong>Validation Warnings (data still loaded):</strong><br><pre>" + warnings.join("\n") + "</pre><br>";
        }

        if (Object.keys(multiSheetJsonData).length === 0) {
            statusMessage += 'No data found in any sheets to load.';
            converterStatusDiv.innerHTML = statusMessage;
            converterStatusDiv.style.color = 'red';
            showNotification("XLSX Conversion: No data found in any sheets to load.", "error");
            return;
        }

        processAndLoadJsonData(multiSheetJsonData, file.name);
        statusMessage += 'Conversion and loading complete!';
        converterStatusDiv.innerHTML = statusMessage;
        converterStatusDiv.style.color = 'green';
         if (firstSheetDataForPreview) {
             converterJsonPreview.textContent = JSON.stringify(firstSheetDataForPreview.slice(0, 3), null, 2);
        }
        converterPanel.classList.remove('open');
    } catch (error) {
        let errorMessageToShow = error.message || "An unknown error occurred during conversion and loading.";
         if (error.isValidationError && error.warnings && error.warnings.length > 0) {
             errorMessageToShow += "\n\nAdditionally, there were warnings (data NOT loaded):\n" + error.warnings.join("\n");
        }
        converterStatusDiv.innerHTML = `<strong>Error (Data NOT Loaded):</strong><br><pre>${errorMessageToShow}</pre>`;
        converterStatusDiv.style.color = 'red';
        showNotification("Error converting/loading XLSX. Data NOT loaded. See converter panel.", "error", 0);
        processAndLoadJsonData({}, ""); 
    } finally {
        convertButtonConverter.disabled = false;
        convertAndLoadButtonConverter.disabled = false;
        if (xlsxFileInputConverter) { xlsxFileInputConverter.value = null; }
    }
}

    function handleLoadFromSharePoint() {
        menuContent.style.display = 'none';
        if (!SHAREPOINT_DOWNLOAD_LINK || SHAREPOINT_DOWNLOAD_LINK === "YOUR_SHAREPOINT_DIRECT_DOWNLOAD_LINK_HERE.xlsx") {
            showNotification("SharePoint download link is not configured. Please contact the administrator.", "error");
            converterStatusDiv.textContent = 'SharePoint link not configured.';
            converterStatusDiv.style.color = 'red';
            return;
        }

        converterStatusDiv.textContent = 'Initiating download from SharePoint... Please wait for the download to complete, then select the file below.';
        converterStatusDiv.style.color = 'orange';
        showNotification("Initiating SharePoint download. Please select the downloaded file in the converter.", "info");
        const a = document.createElement('a');
        a.href = SHAREPOINT_DOWNLOAD_LINK;
        a.download = ''; 
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        converterPanel.classList.add('open');
        filterPanel.classList.remove('open');
        tutorialPanel.classList.remove('open'); 
        dependencyPanelContainer.classList.remove('visible');
        simulationPanel.classList.remove('open');
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';

        if (xlsxFileInputConverter) {
            xlsxFileInputConverter.value = null;
        }
        converterJsonPreview.textContent = ''; 
    }


    function downloadJson(jsonString, filename) {
        const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    function applySearchHighlight(searchTerm) {
        if (isSimulationModeActive) return;
        const term = searchTerm.toLowerCase().trim();
        let foundAny = false;

        diagramPane.querySelectorAll('.process-node').forEach(node => {
            const procId = node.dataset.id; 

            node.classList.remove('search-highlight', 'search-dimmed');
            node.classList.remove('can-hover'); 

            if (node.classList.contains('filtered-out-general') ||
                node.classList.contains('filtered-out-axis') ||
                (isTreeHighlightActive && node.classList.contains('tree-highlight-dimmed') && !highlightedTreeNodesIds.has(procId))) {
                return; 
            }

            if (!term) {
                if (!node.classList.contains('dimmed-selection') &&
                    !(isTreeHighlightActive && !highlightedTreeNodesIds.has(procId))) {
                    node.classList.add('can-hover');
                }
                return;
            }

            const processData = getAllProcessesFromData().find(p => p.ID === procId && p._sourceSheet === node.dataset.sourceSheet);
            let matchesSearch = false;
            if (processData) {
                const shortName = (processData["Short name"] || "").toLowerCase();
                const idMatch = (processData.ID || "").toLowerCase();
                const description = (processData.Description || "").toLowerCase().replace(/\\n/g, ' ');
                if (idMatch.includes(term) || shortName.includes(term) || description.includes(term)) {
                    matchesSearch = true;
                }
            }

            if (matchesSearch) {
                if (!isTreeHighlightActive || (isTreeHighlightActive && highlightedTreeNodesIds.has(procId))) {
                    node.classList.add('search-highlight');
                    node.classList.add('can-hover'); 
                    foundAny = true;
                } else {
                    node.classList.add('search-dimmed');
                }
            }
        });

        if (term) {
            diagramPane.querySelectorAll('.process-node').forEach(node => {
                if (node.classList.contains('filtered-out-general') ||
                    node.classList.contains('filtered-out-axis') ||
                    node.classList.contains('tree-highlight-dimmed')) {
                    return;
                }

                if (!node.classList.contains('search-highlight')) { 
                    node.classList.add('search-dimmed');
                    node.classList.remove('can-hover');
                }
            });
        }

        if (!isTreeHighlightActive && currentlySelectedProcessId) {
            applySelectionDimming(currentlySelectedProcessId);
        }
        positionActionIcons(); 
    }


     function getRecursiveDependenciesGraph(targetId, type, allProcesses, maxDepth, currentDepth = 0, visited = new Set(), parentNodeId = null) {
        if (currentDepth > maxDepth) return [];
        const visitKey = `${targetId}-${type}-${currentDepth}`; if (visited.has(visitKey)) return []; visited.add(visitKey);

        let directDepsData = [];
        if (type === 'inputs') {
            allProcesses.forEach(p => {
                if (p.Dependencies) {
                    const pDepRawEntries = String(p.Dependencies).split(';').map(entry => entry.trim()).filter(entry => entry);
                    pDepRawEntries.forEach(rawEntry => {
                        const { id: depTargetIdInP, type: depLinkType } = parseDependencyEntry(rawEntry);
                        if (depTargetIdInP === targetId) {
                            const children = getRecursiveDependenciesGraph(p.ID, 'inputs', allProcesses, maxDepth, currentDepth + 1, new Set(visited), p.ID);
                            directDepsData.push({
                                id: p.ID,
                                name: p["Short name"],
                                level: -(currentDepth + 1),
                                depLinkType: depLinkType,
                                children: children,
                                parentId: targetId,
                                isCollapsed: false,
                                hasChildren: children.length > 0
                            });
                        }
                    });
                }
            });
        } else { 
            const targetProcess = allProcesses.find(p => p.ID === targetId);
            if (targetProcess && targetProcess.Dependencies) {
                const outputRawEntries = String(targetProcess.Dependencies).split(';').map(entry => entry.trim()).filter(entry => entry);
                outputRawEntries.forEach(rawEntry => {
                    const { id: outId, type: depLinkType } = parseDependencyEntry(rawEntry);
                    if (outId === targetId) return; 

                    const outProc = allProcesses.find(p => p.ID === outId);
                    if (outProc) {
                        const children = getRecursiveDependenciesGraph(outProc.ID, 'outputs', allProcesses, maxDepth, currentDepth + 1, new Set(visited), outProc.ID);
                        directDepsData.push({
                            id: outProc.ID,
                            name: outProc["Short name"],
                            level: currentDepth + 1,
                            depLinkType: depLinkType,
                            children: children,
                            parentId: targetId,
                            isCollapsed: false,
                            hasChildren: children.length > 0
                        });
                    } else {
                         const nameFromAnySheet = ( () => { for (const sheet of Object.values(processesData)) { const found = sheet.find(p => p.ID === outId); if (found) return found["Short name"]; } return null; })();
                        directDepsData.push({
                            id: outId,
                            name: nameFromAnySheet || `${outId.substring(0,15)}... (NV)`,
                            level: currentDepth + 1,
                            depLinkType: depLinkType,
                            children: [],
                            notInView: true,
                            parentId: targetId,
                            isCollapsed: false,
                            hasChildren: false
                        });
                    }
                });
            }
        }
        return directDepsData;
    }

    function generateAndShowDependencyTree(processId) {
        const currentProcessesForRoot = getCurrentlyVisibleProcesses(true);
        const rootProcess = currentProcessesForRoot.find(p => p.ID === processId);
        if (!rootProcess) {
            dependencyTreeSvg.innerHTML = '<text x="10" y="20" fill="red">Cannot find selected process.</text>';
            return;
        }

        currentDependencyTreeRootProcess = rootProcess;
        dependencyPanelTitle.textContent = `Dependencies for: ${rootProcess["Short name"]} (${rootProcess.ID})`;

        const allProcessesCombined = getAllProcessesFromData();

        currentTreeInputsData = getRecursiveDependenciesGraph(processId, 'inputs', allProcessesCombined, DEP_TREE_MAX_DEPTH, 0, new Set(), null);
        currentTreeOutputsData = getRecursiveDependenciesGraph(processId, 'outputs', allProcessesCombined, DEP_TREE_MAX_DEPTH, 0, new Set(), null);

        function initializeTreeStates(nodes) {
            if (!nodes) return;
            nodes.forEach(node => {
                if (node.isCollapsed === undefined) node.isCollapsed = false;
                node.hasChildren = node.children && node.children.length > 0;
                if (node.children) initializeTreeStates(node.children);
            });
        }
        initializeTreeStates(currentTreeInputsData);
        initializeTreeStates(currentTreeOutputsData);

        drawDependencyTreeSVG(rootProcess, currentTreeInputsData, currentTreeOutputsData);
    }

    function initSimulationPanelUI() {
        populateScenarioSelector();
        const defaultSimType = "remove";
        activeSimulationTypeInput.value = defaultSimType;
        simulationTypeSelectorGroup.querySelectorAll('.simulation-type-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.simtype === defaultSimType);
        });
        simulationShiftInputsDiv.style.display = 'none';
        simulationAddInputsDiv.style.display = 'none';
        undoSimulationParamsButton.style.display = 'none';
    }


    function validateSimulationShiftInputs() {
        let isValid = true;
        const wdErrorEl = document.getElementById('error-simulation-new-wd');
        const timeErrorEl = document.getElementById('error-simulation-new-due-time');
        wdErrorEl.textContent = '';
        timeErrorEl.textContent = '';

        const wdVal = simulationNewWdInput.value;
        if (wdVal === '' || isNaN(parseInt(wdVal, 10))) {
            wdErrorEl.textContent = "WD must be a valid number.";
            isValid = false;
        }

        const timeVal = simulationNewDueTimeInput.value;
        if (!timeVal) {
        } else if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(timeVal)) {
            timeErrorEl.textContent = "Format HH:MM or HH:MM:SS.";
            isValid = false;
        } else {
            const tempTime = timeVal.includes(':') && timeVal.split(':').length === 2 ? timeVal + ":00" : timeVal;
            if (isNaN(parseTime(tempTime))) {
                timeErrorEl.textContent = "Not a valid time (00:00:00-23:59:59).";
                isValid = false;
            }
        }
        return isValid;
    }
    
    function validateSimulationAddInputs() {
        let isValid = true;
        const fields = [
            {id: 'sim-add-id', name: 'ID', required: true, pattern: /^[a-zA-Z0-9._-]+$/},
            {id: 'sim-add-short-name', name: 'Short Name', required: true},
            {id: 'sim-add-wd', name: 'WD', required: true, isNumber: true},
            {id: 'sim-add-due-time', name: 'Due Time', required: true, isTime: true},
            {id: 'sim-add-dependencies', name: 'Dependencies', required: false, isDeps: true},
            {id: 'sim-add-process-type', name: 'Process Type', required: true}
        ];

        fields.forEach(field => {
            const inputEl = document.getElementById(field.id);
            const errorEl = document.getElementById(`error-${field.id}`);
            errorEl.textContent = '';
            let value = inputEl.value.trim();

            if (field.required && !value && !(field.name === "WD" && value === "0")) {
                errorEl.textContent = `${field.name} is required.`;
                isValid = false;
                return;
            }
            if (field.pattern && value && !field.pattern.test(value)) {
                errorEl.textContent = `Invalid format for ${field.name}. Use letters, numbers, '.', '_', '-'.`;
                isValid = false;
            }
            if (field.isNumber && value && isNaN(parseInt(value, 10))) {
                errorEl.textContent = `${field.name} must be a number.`;
                isValid = false;
            }
            if (field.isTime && value) {
                if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(value)) {
                     errorEl.textContent = "Format HH:MM or HH:MM:SS."; isValid = false;
                } else {
                     const tempTime = value.includes(':') && value.split(':').length === 2 ? value + ":00" : value;
                     if (isNaN(parseTime(tempTime))) { errorEl.textContent = "Not a valid time (00:00-23:59)."; isValid = false; }
                }
            }
            if (field.isDeps && value) {
                const depEntries = value.split(';').map(entry => entry.trim()).filter(entry => entry);
                if (depEntries.some(entry => {
                    const parsed = parseDependencyEntry(entry);
                    return !/^[a-zA-Z0-9._-]+$/.test(parsed.id);
                })) {
                    errorEl.textContent = "Dependency IDs (before _B or _I) can only contain letters, numbers, '.', '_', '-'. Separate with semicolons.";
                    isValid = false;
                }
            }
            if (field.id === 'sim-add-id' && value) {
                 const existingProcess = getAllProcessesFromData().find(p => p.ID === value);
                 if (existingProcess) {
                    errorEl.textContent = `ID "${value}" already exists in the diagram. Choose a unique ID for simulation.`;
                    isValid = false;
                 }
            }

        });
        return isValid;
    }


    function runOrUpdateSimulation() {
        currentSimulationType = activeSimulationTypeInput.value;
        simulatedNewProcessData = null; 
        currentImpactPaths = [];

        if (currentSimulationType === 'add') {
            if (!validateSimulationAddInputs()) return;
            simulatedNewProcessData = {
                ID: document.getElementById('sim-add-id').value.trim(),
                "Short name": document.getElementById('sim-add-short-name').value.trim(),
                WD: parseInt(document.getElementById('sim-add-wd').value, 10),
                "Due time": document.getElementById('sim-add-due-time').value.trim(),
                Dependencies: document.getElementById('sim-add-dependencies').value.trim(),
                "Process Type": document.getElementById('sim-add-process-type').value,
                _isSimulatedNew: true, 
                _sourceSheet: "SIMULATED" 
            };
             if (simulatedNewProcessData["Due time"] && simulatedNewProcessData["Due time"].includes(':') && simulatedNewProcessData["Due time"].split(':').length === 2) {
                simulatedNewProcessData["Due time"] += ":00"; 
            }
            simulationTargetProcessId = simulatedNewProcessData.ID; 
            simulationTargetProcessSheet = simulatedNewProcessData._sourceSheet;
            simulationTargetNameSpan.textContent = simulatedNewProcessData["Short name"];
            simulationTargetIdSpan.textContent = `ID: ${simulatedNewProcessData.ID} (Simulated)`;
        } else { 
            if (!simulationTargetProcessId) { 
                 showNotification("No process selected to simulate removal or shift.", "warning");
                 return;
            }
            if (currentSimulationType === 'shift') {
                if (!validateSimulationShiftInputs()) return;
                simulatedShiftWd = parseInt(simulationNewWdInput.value, 10);
                let dueTimeVal = simulationNewDueTimeInput.value.trim();
                if (dueTimeVal && dueTimeVal.includes(':') && dueTimeVal.split(':').length === 2) {
                    dueTimeVal += ":00";
                }
                simulatedShiftDueTime = dueTimeVal || null;
            } else { 
                simulatedShiftWd = null;
                simulatedShiftDueTime = null;
            }
        }

        isSimulationModeActive = true;
        if (isTreeHighlightActive) {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
        }
        if (currentSimulationType !== 'add' && currentlySelectedProcessId && currentlySelectedProcessId !== simulationTargetProcessId) {
             clearSelectionHighlightsAndDimming();
        }
        if (currentSimulationType !== 'add') {
            currentlySelectedProcessId = simulationTargetProcessId;
        } else {
            currentlySelectedProcessId = null; 
        }
        updateAllDependencyAndSimShortcutButtonsState();

        storeCurrentSimulationParams();
        applySimulationVisuals(simulatedNewProcessData);

        runSimulationButton.textContent = 'Update Simulation';
        endSimulationButton.style.display = 'inline-block';
        exportSimulationReportButton.style.display = 'inline-block'; 
        undoSimulationParamsButton.style.display = (currentSimulationType === 'shift' || currentSimulationType === 'add') ? 'inline-block' : 'none';
        toggleSimulationPanel(true);
    }

    function applySimulationVisuals(newSimulatedNodeData = null) {
        if (!isSimulationModeActive) return;
        if (!simulationTargetProcessId && !newSimulatedNodeData) return;
    
        svgLayer.innerHTML = '';
        simulationGhostLayer.innerHTML = '';
        const allDiagramNodes = diagramPane.querySelectorAll('.process-node');
        let targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${simulationTargetProcessId}"]`); 
        currentImpactPaths = [];
    
        diagramPane.querySelectorAll('.simulation-new-node, .simulation-temporary-node').forEach(tempNode => {
            const isCurrentSimulatedNew = newSimulatedNodeData && tempNode.dataset.id === newSimulatedNodeData.ID;
            const isOriginalTarget = tempNode.dataset.id === simulationTargetProcessId && currentSimulationType !== 'add';
            
            if (!isCurrentSimulatedNew && !isOriginalTarget) {
                 tempNode.remove();
                 if(nodeLayouts[tempNode.dataset.id] && nodeLayouts[tempNode.dataset.id]._isTemporaryLayout) {
                     delete nodeLayouts[tempNode.dataset.id];
                 }
            }
        });

        if (originalSimulatedNodeStyles.ghostElement) {
            originalSimulatedNodeStyles.ghostElement.remove();
            originalSimulatedNodeStyles.ghostElement = null;
        }
        if (currentSimulationType === 'shift' && nodeLayouts[simulationTargetProcessId] && targetNodeEl) {
            const originalLayout = nodeLayouts[simulationTargetProcessId];
            const ghostNode = createNodeElement(originalLayout.process, originalLayout);
            ghostNode.classList.add('simulation-ghost-node');
            ghostNode.style.top = `${originalLayout.finalY}px`;
            ghostNode.style.left = `${originalLayout.finalX}px`;
            simulationGhostLayer.appendChild(ghostNode);
            originalSimulatedNodeStyles.ghostElement = ghostNode;
        }


        allDiagramNodes.forEach(node => {
            node.classList.remove(
                'simulation-target-node', 'simulation-removed', 'simulation-shifted', 'simulation-new-node',
                'simulation-affected-dependent', 'simulation-dimmed-others',
                'simulation-input-conflict', 'simulation-output-at-risk', 'simulation-temporary-node',
                'selected', 'dependent-input', 'dependent-output', 'dimmed-selection',
                'search-highlight', 'search-dimmed', 'tree-highlight-dimmed'
            );

            const procDataForStyle = getAllProcessesFromData().find(p => p.ID === node.dataset.id && p._sourceSheet === node.dataset.sourceSheet);
            const layoutForStyle = nodeLayouts[node.dataset.id];

            if (procDataForStyle && layoutForStyle && !(isSimulationModeActive && node.dataset.id === simulationTargetProcessId && currentSimulationType === 'shift')) {
                node.style.top = `${layoutForStyle.finalY}px`;
                node.style.left = `${layoutForStyle.finalX}px`;
            }
            if (procDataForStyle){
                 const processTypeSim = (procDataForStyle["Process Type"] || "standard").toLowerCase();
                let simRestoreColor = configColors.node; 
                if (processTypeSim === "blocking") simRestoreColor = configColors.blockingNode;
                else if (processTypeSim === "informational") simRestoreColor = configColors.informationalNode;
                node.style.backgroundColor = simRestoreColor;
                node.style.borderColor = shadeColor(simRestoreColor, -0.3);
            } else if (!node.classList.contains('simulation-temporary-node') && !node.classList.contains('simulation-new-node')) {
                 node.style.backgroundColor = configColors.node; 
                node.style.borderColor = shadeColor(configColors.node, -0.3);
            }

            node.style.boxShadow = '1px 1px 3px rgba(0,0,0,0.1)';
            node.style.opacity = 1; 
    
            if (node.dataset.id === simulationTargetProcessId && currentSimulationType !== 'add' && originalSimulatedNodeStyles.top === null) {
                 originalSimulatedNodeStyles.top = node.style.top;
                 originalSimulatedNodeStyles.left = node.style.left;
                 originalSimulatedNodeStyles.zIndex = node.style.zIndex || '5';
            }
            node.classList.add('simulation-dimmed-others');
        });
    
        targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${simulationTargetProcessId}"]`);
        if (!targetNodeEl && currentSimulationType === 'add' && newSimulatedNodeData) {
             let layout = nodeLayouts[newSimulatedNodeData.ID];
             if (!layout) { 
                 let nodeWidth = NODE_BASE_WIDTH;
                 let tempDiv = document.createElement('div'); tempDiv.className = 'process-node'; tempDiv.textContent = newSimulatedNodeData["Short name"];
                 tempDiv.style.visibility = 'hidden'; document.body.appendChild(tempDiv); nodeWidth = tempDiv.offsetWidth; document.body.removeChild(tempDiv);

                 const wdIndex = gUniqueDataWds.indexOf(newSimulatedNodeData.WD);
                 let idealX = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex !== -1 ? wdIndex * gWdColumnWidth : 0) + (gWdColumnWidth / 2) - nodeWidth / 2;
                 let idealY = PADDING + gPlotHeight / 2 - NODE_HEIGHT / 2;
                 const timeVal = parseTime(newSimulatedNodeData["Due time"]);
                 if (!isNaN(timeVal) && gTimeBins.length > 0) {
                    const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeVal / gTimeBinSizeSec)));
                    const targetBin = gTimeBins[binIndex];
                    if (targetBin) {
                       const timeWithinBin = timeVal - targetBin.startSec;
                       const binDuration = targetBin.endSec - targetBin.startSec + 1;
                       idealY = targetBin.yOffset + (binDuration > 0 ? timeWithinBin / binDuration : 0.5) * targetBin.height - NODE_HEIGHT / 2;
                    }
                 }
                 layout = { finalX: idealX, finalY: idealY, width: nodeWidth, height: NODE_HEIGHT, _isTemporaryLayout: true, process: newSimulatedNodeData };
                 nodeLayouts[newSimulatedNodeData.ID] = layout;
            }
            targetNodeEl = createNodeElement(newSimulatedNodeData, layout); 
            targetNodeEl.style.top = `${layout.finalY}px`;
            targetNodeEl.style.left = `${layout.finalX}px`;
            targetNodeEl.classList.add('simulation-new-node');
            diagramPane.appendChild(targetNodeEl);
        } else if (!targetNodeEl && currentSimulationType !== 'add') {
            simulationImpactListContainer.innerHTML = '<h4>Impacted Processes:</h4><ul id="simulation-impact-list"><li>Error: Target process cannot be displayed.</li></ul>';
            return;
        }
    
        targetNodeEl.classList.remove('simulation-dimmed-others');
        targetNodeEl.classList.add('simulation-target-node');
        targetNodeEl.style.opacity = 1;
    
        const allProcsDataWithSheet = getAllProcessesFromData();
        let targetProcessData;
        if (currentSimulationType === 'add' && newSimulatedNodeData) {
            targetProcessData = newSimulatedNodeData; 
        } else {
             targetProcessData = allProcsDataWithSheet.find(p => p.ID === simulationTargetProcessId && p._sourceSheet === simulationTargetProcessSheet);
        }

        if (!targetProcessData) {
            simulationImpactListContainer.innerHTML = '<h4>Impacted Processes:</h4><ul id="simulation-impact-list"><li>Error: Target process data not found.</li></ul>';
            return;
        }
            
        let simulatedTargetX = nodeLayouts[targetProcessData.ID]?.finalX;
        let simulatedTargetY = nodeLayouts[targetProcessData.ID]?.finalY;
        let targetNodeForArrowDrawing = targetNodeEl;

        if (currentSimulationType === 'remove') {
            targetNodeEl.classList.add('simulation-removed');
        } else if (currentSimulationType === 'shift') {
            targetNodeEl.classList.add('simulation-shifted');
            
            const tempShiftedProcess = { ...targetProcessData, WD: simulatedShiftWd, "Due time": simulatedShiftDueTime || targetProcessData["Due time"] };
            
            const wdIndex = gUniqueDataWds.indexOf(tempShiftedProcess.WD);
            let idealXCenter;
            if (wdIndex !== -1) {
                idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex * gWdColumnWidth) + (gWdColumnWidth / 2);
            } else {
                 if (gUniqueDataWds.length > 0 && tempShiftedProcess.WD < gUniqueDataWds[0]) {
                    idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding - (gWdColumnWidth / 2);
                 } else if (gUniqueDataWds.length > 0 && tempShiftedProcess.WD > gUniqueDataWds[gUniqueDataWds.length -1]) {
                    idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (gUniqueDataWds.length * gWdColumnWidth) + (gWdColumnWidth / 2);
                 } else if (gUniqueDataWds.length > 0) {
                    let closestSmallerWdIndex = -1;
                    for(let i=0; i<gUniqueDataWds.length; i++){
                        if(gUniqueDataWds[i] < tempShiftedProcess.WD) closestSmallerWdIndex = i; else break;
                    }
                    idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + ((closestSmallerWdIndex + 0.5) * gWdColumnWidth) + (gWdColumnWidth / 2);
                 } else {
                    idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + ( (diagramPane.clientWidth - gYAxisLabelWidthOriginal - PADDING * 2) / 2);
                 }
            }

            const timeValue = parseTime(tempShiftedProcess["Due time"]);
            let idealYCenter = (nodeLayouts[targetProcessData.ID]?.finalY || 0) + ((nodeLayouts[targetProcessData.ID]?.height || NODE_HEIGHT) / 2);

            if (!isNaN(timeValue) && gTimeBins.length > 0) {
                const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeValue / gTimeBinSizeSec)));
                const targetBin = gTimeBins[binIndex];
                if (targetBin) {
                    const timeWithinBin = timeValue - targetBin.startSec;
                    const binDuration = targetBin.endSec - targetBin.startSec + 1;
                    const relativePosInBin = binDuration > 0 ? timeWithinBin / binDuration : 0.5;
                    idealYCenter = targetBin.yOffset + relativePosInBin * targetBin.height;
                }
            }
            
            simulatedTargetX = idealXCenter - targetNodeEl.offsetWidth / 2;
            simulatedTargetY = idealYCenter - targetNodeEl.offsetHeight / 2;

            targetNodeEl.style.transition = 'top 0.3s ease-in-out, left 0.3s ease-in-out, opacity 0.3s, background-color 0.3s, border-color 0.3s';
            targetNodeEl.style.left = `${simulatedTargetX}px`;
            targetNodeEl.style.top = `${simulatedTargetY}px`;
            targetNodeEl.style.zIndex = '25';
        }
    
        simulationImpactListContainer.innerHTML = '';
        let impactedOutputsHTML = '<h4>Impacted Outputs:</h4><ul id="simulation-impact-outputs-list">';
        let inputConflictsHTML = '<h4>Input Conflicts:</h4><ul id="simulation-impact-inputs-list">';
        let newProcessNeedsHTML = '<h4>New Process Needs:</h4><ul id="simulation-impact-new-needs-list">';
        let hasImpactedOutputs = false;
        let hasInputConflicts = false;
        let hasNewProcessNeeds = false;
        currentImpactPaths = [];

        const simulatedWdNum = (currentSimulationType === 'shift' || currentSimulationType === 'add') ? (simulatedNewProcessData ? simulatedNewProcessData.WD : simulatedShiftWd) : targetProcessData.WD;
        const simulatedDueTimeStr = (currentSimulationType === 'shift' || currentSimulationType === 'add') ? (simulatedNewProcessData ? simulatedNewProcessData["Due time"] : simulatedShiftDueTime) : targetProcessData["Due time"];
        const simulatedTimeSec = parseTime(simulatedDueTimeStr);
    
        function traceImpactPath(startNodeId, endNodeId, pathType) {
            currentImpactPaths.push({
                sourceId: startNodeId,
                targetId: endNodeId,
                type: pathType
            });
        }

        allProcsDataWithSheet.forEach(potentialOutput => {
            if (potentialOutput.ID === targetProcessData.ID && currentSimulationType !== 'add') return;
            if (currentSimulationType === 'add' && potentialOutput.ID === targetProcessData.ID) return;

            if (potentialOutput.Dependencies) {
                const depEntries = String(potentialOutput.Dependencies).split(';').map(d => d.trim()).filter(d => d);
                depEntries.forEach(rawEntry => {
                    const { id: depSourceId, type: depLinkType } = parseDependencyEntry(rawEntry);
                    if (depSourceId === targetProcessData.ID) { 
                        let outputNodeEl = diagramPane.querySelector(`.process-node[data-id="${potentialOutput.ID}"][data-source-sheet="${potentialOutput._sourceSheet}"]`);
                        
                        if (!outputNodeEl) {
                            if (nodeLayouts[potentialOutput.ID]) {
                                const layout = nodeLayouts[potentialOutput.ID];
                                outputNodeEl = createNodeElement(potentialOutput, layout); 
                                outputNodeEl.style.top = `${layout.finalY}px`;
                                outputNodeEl.style.left = `${layout.finalX}px`;
                                outputNodeEl.classList.add('simulation-temporary-node');
                                diagramPane.appendChild(outputNodeEl);
                            } else { return; }
                        }
    
                        outputNodeEl.classList.remove('simulation-dimmed-others');
                        let impactMessage = "";
                        let arrowColor = configColors.outputArrow;
                        let arrowClass = 'simulation-arrow';
                        let isImpactPathArrow = false;

                        if (currentSimulationType === 'remove') {
                            outputNodeEl.classList.add('simulation-affected-dependent'); 
                            impactMessage = "Dependency Lost";
                            arrowColor = '#dc3545';
                            arrowClass = 'simulation-arrow-broken';
                            isImpactPathArrow = true;
                            traceImpactPath(targetProcessData.ID, potentialOutput.ID, 'dependency_lost');
                        } else if ((currentSimulationType === 'shift' || currentSimulationType === 'add') && !isNaN(simulatedTimeSec)) {
                            const outputTimeSec = parseTime(potentialOutput["Due time"]);
                            if (simulatedWdNum > potentialOutput.WD || (simulatedWdNum === potentialOutput.WD && !isNaN(outputTimeSec) && simulatedTimeSec > outputTimeSec)) {
                                 outputNodeEl.classList.add('simulation-output-at-risk');
                                 impactMessage = "Potentially Delayed";
                                 arrowColor = '#FF8C00';
                                 isImpactPathArrow = true;
                                 traceImpactPath(targetProcessData.ID, potentialOutput.ID, 'output_risk');
                            } else {
                                 outputNodeEl.classList.add('simulation-affected-dependent');
                                 impactMessage = (currentSimulationType === 'shift') ? "Dependency Shifted" : "New Input Provided";
                                 arrowColor = (currentSimulationType === 'shift') ? '#fd7e14' : '#28a745';
                            }
                        }
                        impactedOutputsHTML += `<li style="color: ${arrowColor};">${impactMessage}: ${potentialOutput["Short name"]} (ID: ${potentialOutput.ID}, Sheet: ${potentialOutput._sourceSheet})</li>`;
                        hasImpactedOutputs = true;
                        drawArrow(targetNodeForArrowDrawing, outputNodeEl, arrowColor, arrowClass, depLinkType, isImpactPathArrow);
                    }
                });
            }
        });
    
        if ((currentSimulationType === 'shift' || currentSimulationType === 'add') && targetProcessData.Dependencies && !isNaN(simulatedTimeSec)) {
            const inputRawEntries = String(targetProcessData.Dependencies).split(';').map(entry => entry.trim()).filter(entry => entry);
            inputRawEntries.forEach(rawEntry => {
                const { id: inputSourceId, type: depLinkType } = parseDependencyEntry(rawEntry);
                let inputProcessData = allProcsDataWithSheet.find(p => p.ID === inputSourceId && p._sourceSheet === targetProcessData._sourceSheet);
                 if (!inputProcessData) { 
                    inputProcessData = allProcsDataWithSheet.find(p => p.ID === inputSourceId);
                 }
                 if (!inputProcessData) {
                     if (currentSimulationType === 'add') {
                         newProcessNeedsHTML += `<li style="color: #FF0000;">Missing Input: ${inputSourceId} (Not Found)</li>`;
                         hasNewProcessNeeds = true;
                     } else {
                         inputConflictsHTML += `<li style="color: #FF0000;">Missing Input: ${inputSourceId} (Not Found)</li>`;
                         hasInputConflicts = true;
                     }
                     return;
                 }

                let inputNodeEl = diagramPane.querySelector(`.process-node[data-id="${inputSourceId}"][data-source-sheet="${inputProcessData._sourceSheet}"]`);
                
                if (!inputNodeEl) {
                    if (nodeLayouts[inputSourceId]) {
                        const layout = nodeLayouts[inputSourceId];
                        inputNodeEl = createNodeElement(inputProcessData, layout); 
                        inputNodeEl.style.top = `${layout.finalY}px`;
                        inputNodeEl.style.left = `${layout.finalX}px`;
                        inputNodeEl.classList.add('simulation-temporary-node');
                        diagramPane.appendChild(inputNodeEl);
                    } else { return; }
                }

                inputNodeEl.classList.remove('simulation-dimmed-others');
                const inputTimeSec = parseTime(inputProcessData["Due time"]);
                let arrowColor = configColors.inputArrow;
                let arrowClass = 'simulation-arrow';
                let impactTypeForList = "";
                let isImpactPathArrow = false;

                if (simulatedWdNum < inputProcessData.WD || (simulatedWdNum === inputProcessData.WD && !isNaN(inputTimeSec) && simulatedTimeSec < inputTimeSec )) {
                    inputNodeEl.classList.add('simulation-input-conflict');
                    impactTypeForList = "Timing Conflict";
                    arrowColor = '#FF4500';
                    isImpactPathArrow = true;
                    traceImpactPath(inputSourceId, targetProcessData.ID, 'input_conflict');
                } else {
                    inputNodeEl.classList.add('simulation-affected-dependent');
                    impactTypeForList = (currentSimulationType === 'add') ? "Input Source OK" : "Dependency Shifted";
                    arrowColor = (currentSimulationType === 'add') ? '#28a745' : '#fd7e14';
                }

                if (currentSimulationType === 'add') {
                    newProcessNeedsHTML += `<li style="color: ${arrowColor};">${impactTypeForList}: ${inputProcessData["Short name"]} (ID: ${inputProcessData.ID}, Sheet: ${inputProcessData._sourceSheet})</li>`;
                    hasNewProcessNeeds = true;
                } else { 
                    if (impactTypeForList === "Timing Conflict") {
                         inputConflictsHTML += `<li style="color: ${arrowColor};">${impactTypeForList}: ${inputProcessData["Short name"]} (ID: ${inputProcessData.ID}, Sheet: ${inputProcessData._sourceSheet})</li>`;
                         hasInputConflicts = true;
                    }
                }
                drawArrow(inputNodeEl, targetNodeForArrowDrawing, arrowColor, arrowClass, depLinkType, isImpactPathArrow);
            });
        }
    
        impactedOutputsHTML += '</ul>';
        inputConflictsHTML += '</ul>';
        newProcessNeedsHTML += '</ul>';
    
        if (hasImpactedOutputs) simulationImpactListContainer.innerHTML += impactedOutputsHTML;
        if (currentSimulationType === 'add' && hasNewProcessNeeds) {
             simulationImpactListContainer.innerHTML += newProcessNeedsHTML;
        } else if (currentSimulationType === 'shift' && hasInputConflicts) {
            simulationImpactListContainer.innerHTML += inputConflictsHTML;
        }
        
        if (!hasImpactedOutputs && ((currentSimulationType === 'add' && !hasNewProcessNeeds) || (currentSimulationType === 'shift' && !hasInputConflicts) || currentSimulationType === 'remove')) {
            simulationImpactListContainer.innerHTML = '<h4>Impacted Processes:</h4><ul id="simulation-impact-list"><li>No direct impacts identified based on current simulation.</li></ul>';
        }
    
        drawMiniMap();
        updateMiniMapViewPort();
    }
    

    function endSimulation() {
        if (!isSimulationModeActive) return;

        isSimulationModeActive = false;
        const tempNodeIdToRemove = (currentSimulationType === 'add' && simulatedNewProcessData) ? simulatedNewProcessData.ID : null;

        const targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${simulationTargetProcessId}"]`);
        if (targetNodeEl && originalSimulatedNodeStyles.top !== null && currentSimulationType !== 'add') {
            targetNodeEl.style.transition = 'transform 0.15s ease-out, box-shadow 0.15s ease-out, background-color 0.3s, border-color 0.3s, opacity 0.3s, top 0.2s ease-out, left 0.2s ease-out';
            targetNodeEl.style.top = originalSimulatedNodeStyles.top;
            targetNodeEl.style.left = originalSimulatedNodeStyles.left;
            targetNodeEl.style.zIndex = originalSimulatedNodeStyles.zIndex;
        }
        if(originalSimulatedNodeStyles.ghostElement) {
            originalSimulatedNodeStyles.ghostElement.remove();
        }
        originalSimulatedNodeStyles = { top: null, left: null, zIndex: null, ghostElement: null }; 

        diagramPane.querySelectorAll('.process-node').forEach(node => {
            node.classList.remove(
                'simulation-target-node', 'simulation-removed', 'simulation-shifted', 'simulation-new-node',
                'simulation-affected-dependent', 'simulation-dimmed-others', 'simulation-temporary-node',
                'simulation-input-conflict', 'simulation-output-at-risk'
            );
            node.style.transition = 'transform 0.15s ease-out, box-shadow 0.15s ease-out, background-color 0.3s, border-color 0.3s, opacity 0.3s, top 0.2s ease-out, left 0.2s ease-out';
        });
        diagramPane.querySelectorAll('.simulation-temporary-node, .simulation-new-node').forEach(node => {
             if (tempNodeIdToRemove && node.dataset.id === tempNodeIdToRemove) {
                node.remove(); 
                if(nodeLayouts[tempNodeIdToRemove] && nodeLayouts[tempNodeIdToRemove]._isTemporaryLayout) {
                     delete nodeLayouts[tempNodeIdToRemove]; 
                }
            } else if (!tempNodeIdToRemove || node.dataset.id !== tempNodeIdToRemove){ 
                node.remove();
                 if(nodeLayouts[node.dataset.id] && nodeLayouts[node.dataset.id]._isTemporaryLayout) {
                     delete nodeLayouts[node.dataset.id]; 
                 }
            }
        });


        svgLayer.innerHTML = ''; 
        simulationGhostLayer.innerHTML = '';

        simulationTargetProcessId = null;
        simulationTargetProcessSheet = null;
        simulatedNewProcessData = null; 
        currentSimulationType = 'remove';
        simulatedShiftWd = null;
        simulatedShiftDueTime = null;
        previousSimulationParams = {};
        currentImpactPaths = [];

        runSimulationButton.textContent = 'Run Simulation';
        runSimulationButton.disabled = false;
        endSimulationButton.style.display = 'none';
        exportSimulationReportButton.style.display = 'none'; 
        undoSimulationParamsButton.style.display = 'none';
        simulationImpactListContainer.innerHTML = '';
        simulationNewWdInput.value = '';
        simulationNewDueTimeInput.value = '';
        document.getElementById('error-simulation-new-wd').textContent = '';
        document.getElementById('error-simulation-new-due-time').textContent = '';
        
        document.getElementById('sim-add-id').value = '';
        document.getElementById('sim-add-short-name').value = '';
        document.getElementById('sim-add-wd').value = '';
        document.getElementById('sim-add-due-time').value = '';
        document.getElementById('sim-add-dependencies').value = '';
        document.getElementById('sim-add-process-type').value = 'standard';
        document.getElementById('error-sim-add-id').textContent = '';
        document.getElementById('error-sim-add-short-name').textContent = '';
        document.getElementById('error-sim-add-wd').textContent = '';
        document.getElementById('error-sim-add-due-time').textContent = '';
        document.getElementById('error-sim-add-dependencies').textContent = '';
        document.getElementById('error-sim-add-process-type').textContent = '';


        toggleSimulationPanel(false);
        
        renderDiagramAndRestoreState(); 
        if (currentlySelectedProcessId) { 
             const procToReselect = getAllProcessesFromData().find(p => p.ID === currentlySelectedProcessId);
             if(procToReselect) {
                selectProcess(currentlySelectedProcessId, true);
             } else { 
                currentlySelectedProcessId = null;
                resetVisualStates();
             }
        } else {
             resetVisualStates(); 
        }
        positionActionIcons();
    }
    
    function exportSimulationReport() {
        if (!isSimulationModeActive) {
            showNotification("No active simulation to report.", "warning");
            return;
        }

        let reportContent = "Simulation Report\n";
        reportContent += "===================\n\n";
        reportContent += `Date: ${new Date().toLocaleString()}\n`;

        if (currentSimulationType === 'add' && simulatedNewProcessData) {
            reportContent += `Simulation Type: Add New Process\n`;
            reportContent += `Simulated Process ID: ${simulatedNewProcessData.ID}\n`;
            reportContent += `Simulated Short Name: ${simulatedNewProcessData["Short name"]}\n`;
            reportContent += `Simulated WD: ${simulatedNewProcessData.WD}\n`;
            reportContent += `Simulated Due Time: ${simulatedNewProcessData["Due time"]}\n`;
            reportContent += `Simulated Dependencies: ${simulatedNewProcessData.Dependencies || 'None'}\n`;
            reportContent += `Simulated Process Type: ${simulatedNewProcessData["Process Type"]}\n`;
        } else if (simulationTargetProcessId) {
            const targetProc = getAllProcessesFromData().find(p => p.ID === simulationTargetProcessId && p._sourceSheet === simulationTargetProcessSheet);
            if (targetProc) {
                reportContent += `Target Process: ${targetProc["Short name"]} (ID: ${targetProc.ID}, Sheet: ${targetProc._sourceSheet})\n`;
            }
            reportContent += `Simulation Type: ${currentSimulationType.charAt(0).toUpperCase() + currentSimulationType.slice(1)}\n`;
            if (currentSimulationType === 'shift') {
                reportContent += `Shifted WD: ${simulatedShiftWd}\n`;
                reportContent += `Shifted Due Time: ${simulatedShiftDueTime || 'Not Changed'}\n`;
            }
        }
        reportContent += "\n--- Impact Summary ---\n";

        const impactLists = simulationImpactListContainer.querySelectorAll('ul');
        if (impactLists.length > 0) {
            impactLists.forEach(ul => {
                const titleEl = ul.previousElementSibling;
                if (titleEl && titleEl.tagName === 'H4') {
                    reportContent += `\n${titleEl.textContent.trim()}\n`;
                }
                const items = ul.querySelectorAll('li');
                if (items.length > 0) {
                    items.forEach(li => {
                        reportContent += `- ${li.textContent.trim()}\n`;
                    });
                } else {
                    reportContent += "- None\n";
                }
            });
        } else {
            reportContent += "No specific impacts listed in the panel.\n";
        }

        const blob = new Blob([reportContent], { type: 'text/plain;charset=utf-8' });
        const filename = `simulation_report_${simulationTargetProcessId || 'new_process'}_${new Date().toISOString().slice(0,10)}.txt`;
        
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        showNotification("Simulation report exported.", "success");
    }

    function storeCurrentSimulationParams() {
        previousSimulationParams = {
            type: activeSimulationTypeInput.value,
            shiftWd: simulationNewWdInput.value,
            shiftDueTime: simulationNewDueTimeInput.value,
            addId: document.getElementById('sim-add-id').value,
            addShortName: document.getElementById('sim-add-short-name').value,
            addWd: document.getElementById('sim-add-wd').value,
            addDueTime: document.getElementById('sim-add-due-time').value,
            addDependencies: document.getElementById('sim-add-dependencies').value,
            addProcessType: document.getElementById('sim-add-process-type').value
        };
    }

    function undoSimulationParameters() {
        if (Object.keys(previousSimulationParams).length === 0) {
            showNotification("No previous parameters to undo.", "info");
            return;
        }

        activeSimulationTypeInput.value = previousSimulationParams.type || 'remove';
        currentSimulationType = activeSimulationTypeInput.value;

        simulationTypeSelectorGroup.querySelectorAll('.simulation-type-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.simtype === currentSimulationType);
        });


        simulationNewWdInput.value = previousSimulationParams.shiftWd || '';
        simulationNewDueTimeInput.value = previousSimulationParams.shiftDueTime || '';
        document.getElementById('sim-add-id').value = previousSimulationParams.addId || '';
        document.getElementById('sim-add-short-name').value = previousSimulationParams.addShortName || '';
        document.getElementById('sim-add-wd').value = previousSimulationParams.addWd || '';
        document.getElementById('sim-add-due-time').value = previousSimulationParams.addDueTime || '';
        document.getElementById('sim-add-dependencies').value = previousSimulationParams.addDependencies || '';
        document.getElementById('sim-add-process-type').value = previousSimulationParams.addProcessType || 'standard';

        if (currentSimulationType === 'shift') {
            simulationShiftInputsDiv.style.display = 'block';
            simulationAddInputsDiv.style.display = 'none';
        } else if (currentSimulationType === 'add') {
            simulationShiftInputsDiv.style.display = 'none';
            simulationAddInputsDiv.style.display = 'block';
        } else {
            simulationShiftInputsDiv.style.display = 'none';
            simulationAddInputsDiv.style.display = 'none';
        }
        showNotification("Simulation parameters restored to previous state.", "info");
    }

    function saveSimulationScenario() {
        const scenarioName = prompt("Enter a name for this simulation scenario:");
        if (!scenarioName || scenarioName.trim() === "") {
            showNotification("Scenario name cannot be empty.", "warning");
            return;
        }

        const scenario = {
            name: scenarioName.trim(),
            targetProcessId: simulationTargetProcessId,
            targetProcessSheet: simulationTargetProcessSheet,
            type: activeSimulationTypeInput.value,
            shiftWd: simulationNewWdInput.value,
            shiftDueTime: simulationNewDueTimeInput.value,
            addId: document.getElementById('sim-add-id').value,
            addShortName: document.getElementById('sim-add-short-name').value,
            addWd: document.getElementById('sim-add-wd').value,
            addDueTime: document.getElementById('sim-add-due-time').value,
            addDependencies: document.getElementById('sim-add-dependencies').value,
            addProcessType: document.getElementById('sim-add-process-type').value
        };

        let savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
        savedScenarios[scenario.name] = scenario;
        localStorage.setItem(SIMULATION_SCENARIOS_STORAGE_KEY, JSON.stringify(savedScenarios));

        showNotification(`Simulation scenario "${scenario.name}" saved.`, "success");
        populateScenarioSelector();
    }

    function populateScenarioSelector() {
        const savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
        simulationScenarioSelector.innerHTML = '<option value="">- Select Scenario -</option>';
        Object.keys(savedScenarios).sort().forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            simulationScenarioSelector.appendChild(option);
        });
    }

    function loadSelectedSimulationScenario() {
        const scenarioName = simulationScenarioSelector.value;
        if (!scenarioName) {
            showNotification("Please select a scenario to load.", "info");
            return;
        }
        const savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
        const scenario = savedScenarios[scenarioName];

        if (!scenario) {
            showNotification(`Error: Scenario "${scenarioName}" not found.`, "error");
            return;
        }

        simulationTargetProcessId = scenario.targetProcessId;
        simulationTargetProcessSheet = scenario.targetProcessSheet;
        const targetProc = getAllProcessesFromData().find(p => p.ID === simulationTargetProcessId && p._sourceSheet === simulationTargetProcessSheet);
        if (targetProc) {
            simulationTargetNameSpan.textContent = targetProc["Short name"];
            simulationTargetIdSpan.textContent = `ID: ${targetProc.ID}`;
        } else if (scenario.type !== 'add') {
            showNotification(`Target process ${scenario.targetProcessId} for loaded scenario not found in current data. Simulation might not run correctly.`, "warning");
            simulationTargetNameSpan.textContent = "UNKNOWN";
            simulationTargetIdSpan.textContent = `ID: ${scenario.targetProcessId} (Not Found)`;
        }


        activeSimulationTypeInput.value = scenario.type || 'remove';
        currentSimulationType = activeSimulationTypeInput.value;

        simulationTypeSelectorGroup.querySelectorAll('.simulation-type-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.simtype === currentSimulationType);
        });

        simulationNewWdInput.value = scenario.shiftWd || '';
        simulationNewDueTimeInput.value = scenario.shiftDueTime || '';
        document.getElementById('sim-add-id').value = scenario.addId || '';
        document.getElementById('sim-add-short-name').value = scenario.addShortName || '';
        document.getElementById('sim-add-wd').value = scenario.addWd || '';
        document.getElementById('sim-add-due-time').value = scenario.addDueTime || '';
        document.getElementById('sim-add-dependencies').value = scenario.addDependencies || '';
        document.getElementById('sim-add-process-type').value = scenario.addProcessType || 'standard';

        if (currentSimulationType === 'shift') {
            simulationShiftInputsDiv.style.display = 'block';
            simulationAddInputsDiv.style.display = 'none';
            undoSimulationParamsButton.style.display = 'inline-block';
        } else if (currentSimulationType === 'add') {
            simulationShiftInputsDiv.style.display = 'none';
            simulationAddInputsDiv.style.display = 'block';
            undoSimulationParamsButton.style.display = 'inline-block';
        } else {
            simulationShiftInputsDiv.style.display = 'none';
            simulationAddInputsDiv.style.display = 'none';
            undoSimulationParamsButton.style.display = 'none';
        }
        storeCurrentSimulationParams();
        showNotification(`Simulation scenario "${scenarioName}" loaded. Click 'Run Simulation'.`, "success");
    }


    function saveCurrentViewConfiguration() {
        const configName = prompt("Enter a name for this view configuration (e.g., 'Month-End Review', 'Daily Tasks'):");
        if (!configName || configName.trim() === "") {
            showNotification("View configuration name cannot be empty.", "warning");
            return;
        }

        const viewConfig = {
            name: configName.trim(),
            appliedFilters: JSON.parse(JSON.stringify(currentAppliedFilters)), 
            axisFilter: JSON.parse(JSON.stringify(currentAxisFilter)),       
            colors: JSON.parse(JSON.stringify(configColors)),                 
            processTypeView: currentProcessTypeView
        };

        let savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        savedConfigs[viewConfig.name] = viewConfig;
        localStorage.setItem(VIEW_CONFIGS_STORAGE_KEY, JSON.stringify(savedConfigs));

        showNotification(`View configuration "${viewConfig.name}" saved.`, "success");
        populateViewConfigSelector(); 
        menuContent.style.display = 'none';
    }

    function populateViewConfigSelector() {
        const savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        loadViewConfigSelector.innerHTML = '<option value="">- Select View -</option>'; 

        Object.keys(savedConfigs).sort().forEach(configName => {
            const option = document.createElement('option');
            option.value = configName;
            option.textContent = configName;
            loadViewConfigSelector.appendChild(option);
        });
    }

    function loadSelectedViewConfiguration() {
        if (isSimulationModeActive) endSimulation();
        const configName = loadViewConfigSelector.value;
        if (!configName) return;

        const savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        const configToLoad = savedConfigs[configName];

        if (!configToLoad) {
            showNotification(`Error: Could not find saved view configuration "${configName}".`, 'error');
            loadViewConfigSelector.value = ""; 
            return;
        }

        currentAppliedFilters = JSON.parse(JSON.stringify(configToLoad.appliedFilters || {}));
        temporaryActiveFilters = { ...currentAppliedFilters }; 
        currentAxisFilter = JSON.parse(JSON.stringify(configToLoad.axisFilter || { type: null, value: null, valueEnd: null }));
        
        const defaultColorsObject = { 
            node: '#aedff7', lightning: '#00ff00', inputProcess: '#90ee90', outputProcess: '#ffb6c1',
            inputArrow: '#50c878', outputArrow: '#ff7f7f', inputArrowBlocking: '#FF0000',
            outputArrowBlocking: '#FF0000', inputArrowInformational: '#0000FF', outputArrowInformational: '#0000FF',
            nodeSymbolColor: '#333333', blockingNode: '#ffcc80', informationalNode: '#b3e5fc'
        };
        configColors = { ...defaultColorsObject, ...(configToLoad.colors || {}) };


        currentProcessTypeView = configToLoad.processTypeView || "All";

        processTypeViewSelector.value = currentProcessTypeView;
        initializeColorPickers(); 

        populateFilterPanel(); 
        if (filterOptionsContainer) {
            filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(inputEl => {
                if (inputEl.tagName === 'SELECT' && inputEl.multiple) {
                    Array.from(inputEl.options).forEach(option => option.selected = false);
                } else {
                    inputEl.value = "";
                }
                const filterKey = inputEl.dataset.filterKey;
                if (currentAppliedFilters[filterKey]) {
                     if (inputEl.tagName === 'SELECT' && inputEl.multiple) {
                        const values = Array.isArray(currentAppliedFilters[filterKey]) ? currentAppliedFilters[filterKey] : [currentAppliedFilters[filterKey]];
                        Array.from(inputEl.options).forEach(option => {
                            option.selected = values.includes(option.value);
                        });
                    } else if (filterKey === "Due time" && typeof currentAppliedFilters[filterKey] === 'object') {
                         if (inputEl.id.endsWith('-from')) inputEl.value = currentAppliedFilters[filterKey].from || '';
                         if (inputEl.id.endsWith('-to')) inputEl.value = currentAppliedFilters[filterKey].to || '';
                    } else {
                        inputEl.value = currentAppliedFilters[filterKey];
                    }
                }
            });
        }


        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        currentlySelectedProcessId = null; 

        resetVisualStates(); 
        renderDiagramAndRestoreState(); 

        showNotification(`View configuration "${configName}" loaded.`, "success");
        saveStateToLocalStorage(); 
        loadViewConfigSelector.value = ""; 
    }

    function populateDeleteViewDropdown() {
        const savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        deleteViewConfigDropdown.innerHTML = ''; 

        const configNames = Object.keys(savedConfigs).sort();

        if (configNames.length === 0) {
            const noItemsMsg = document.createElement('div');
            noItemsMsg.textContent = "No views to delete.";
            noItemsMsg.style.padding = "8px 12px";
            noItemsMsg.style.color = "#777";
            noItemsMsg.style.fontSize = "0.9em";
            deleteViewConfigDropdown.appendChild(noItemsMsg);
            return;
        }

        configNames.forEach(configName => {
            const item = document.createElement('div');
            item.className = 'delete-item';
            item.textContent = configName;
            item.dataset.configName = configName;
            item.addEventListener('click', (e) => {
                e.stopPropagation(); 
                const nameToDelete = e.target.dataset.configName;
                if (confirm(`Are you sure you want to delete the view configuration "${nameToDelete}"? This cannot be undone.`)) {
                    deleteSpecificViewConfiguration(nameToDelete);
                }
                deleteViewConfigDropdown.style.display = 'none'; 
            });
            deleteViewConfigDropdown.appendChild(item);
        });
    }

    function deleteSpecificViewConfiguration(configName) {
        let savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        if (savedConfigs[configName]) {
            delete savedConfigs[configName];
            localStorage.setItem(VIEW_CONFIGS_STORAGE_KEY, JSON.stringify(savedConfigs));
            showNotification(`View configuration "${configName}" deleted.`, "info");
            populateViewConfigSelector(); 
            populateDeleteViewDropdown(); 
        } else {
            showNotification(`Error: Could not find view configuration "${configName}" to delete.`, "error");
        }
    }
</script>
<div class="page-footer">
    <svg class="bridgestone-footer-symbol" version="1.2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1531 1373">
        <title>Bridgestone Symbol</title>
        <style>
            .s0, .s1 { fill: currentColor; } 
        </style>
        <path id="path137" fill-rule="evenodd" class="s0" d="m1519.9 340.3c-51.9 209.9-197.4 267.7-341.5 292.5-5.8 0.7-2.9 6.6 0 7.3 170.4 35.9 277.2 174.1 223 378.1-67.2 249.3-252.2 353.9-590.1 353.9h-802.2c-8.8 0-11.7-10.3-5.9-16.8 205.5-258.2 534.6-599.6 806.6-833.6 8.1-6.6 18.3 0.7 16.1 10.2l-185.7 645.7h117.7c59.3 0 121.4-48.3 137.5-106.1l306.4-1070.5q9.5-0.7 19-0.7c192.3-3.6 354 119.9 299.1 340z"/>
        <path id="path151" class="s1" d="m188.3 784.9l187.2-654.4c18.2-68 92.8-129.5 168.2-129.5h571.8c9.5 0 13.2 13.2 5.1 17.6-296.9 203.3-655.9 504.5-916.3 775.1-6.5 6.6-19 0.7-16-8.8z"/>
    </svg>
    Project created by Patryk Broński, Anna Maik, Aneta Bugajewska, Kubacka Irena
</div>
</body>
</html>